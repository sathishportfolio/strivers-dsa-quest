{
    "all_syllabus": {
        "all_syllabus": [
            {
                "category_id": "extras",
                "category_name": "Beginner Problems",
                "category_slug": "beginner-problem",
                "category_rank": 0,
                "subcategories": [
                    {
                        "subcategory_id": "fundamentals_basics",
                        "subcategory_name": "Language Basics",
                        "subcategory_slug": "language-basics",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_fundamentals_basics_cppsetup",
                                "problem_name": "CPP Setup",
                                "problem_slug": "cpp-setup",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "fundamentals_fundamentals_basics_cpporjava",
                                "problem_name": "Cpp Basics",
                                "problem_slug": "cpp",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_javasetup",
                                "problem_name": "Java Setup",
                                "problem_slug": "java-setup",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "fundamentals_fundamentals_basics_java",
                                "problem_name": "Java Basics",
                                "problem_slug": "java-basics",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_javaoopsbasic",
                                "problem_name": "Java OOPs Basic",
                                "problem_slug": "java-oops-basics",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_inputoutput",
                                "problem_name": "Input Output",
                                "problem_slug": "input-output",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_ifelseadultteenproblem",
                                "problem_name": "If Else Adult Teen Problem",
                                "problem_slug": "if-else-adult-teen-problem",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_ifelseif",
                                "problem_name": "If ElseIf",
                                "problem_slug": "if-elseif",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_switchcase",
                                "problem_name": "Switch Case",
                                "problem_slug": "switch-case",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_sumoffirstlastelementinarray",
                                "problem_name": "Sum of first last element in array",
                                "problem_slug": "sum-of-first-last-element-in-array",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_printxnnumbersoftimes",
                                "problem_name": "Print X N numbers of times",
                                "problem_slug": "print-x-n-numbers-of-times",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_fundamentals_basics_printlastcharacterofstring",
                                "problem_name": "Print last character of string",
                                "problem_slug": "print-last-character-of-string",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "fundamentals_logicbuilding(patterns)",
                        "subcategory_name": "Logic Building (Patterns)",
                        "subcategory_slug": "logic-building-patterns",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "fundamentals_fundamentals_logicbuilding(patterns)_logicbuildingwithpatterns",
                                "problem_name": "Easy and Medium",
                                "problem_slug": "easy-and-medium",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_logicbuilding(patterns)_pattern2",
                                "problem_name": "Hard",
                                "problem_slug": "hard",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_patterns",
                        "subcategory_name": "Patterns",
                        "subcategory_slug": "patterns",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_patterns_pattern1",
                                "problem_name": "Pattern 1",
                                "problem_slug": "pattern-1",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: Though simple, generating patterns like this one is a foundational skill for graphical programming and game development. Many retro, text-based games like rogue or Dwarf Fortress use text characters to represent the game world, and modern games use more advanced versions of these same principles to create their levels and worlds! Spefically, being able to generate a repetitive pattern like this can be crucial in designing background graphics, creating tile-based games, designing user interfaces and even in certain testing scenarios.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern2",
                                "problem_name": "Pattern 2",
                                "problem_slug": "pattern-2",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This programming problem, often considered a basic exercise for beginners, is more significant than it seems at first glance. The underlying concept of using loops to generate patterns is a foundational concept of algorithm design and text data visualization in the software industry. A real-world application can be seen in terminal-based applications or console game development where text output needs to be visually organized in a certain pattern. Additionally, SVG graphics in web development use similar concepts to generate visual patterns and shapes.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern3",
                                "problem_name": "Pattern 3",
                                "problem_slug": "pattern-3",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem is a fundamental example of string manipulation and loop control flow, both of which are essential in almost every area of software development. For example, this type of functionality is used in progress bar components, where each increment in the bar might require an additional character or content. Similarly, it's often used in visual representations of hierarchical data, like threaded discussion threads where each nested level might have an additional space or icon. In short, understanding and solving this problem can help a developer create visually intuitive and user-friendly interfaces.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern4",
                                "problem_name": "Pattern 4",
                                "problem_slug": "pattern-4",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Many website and application development technologies use the concept underlying this problem, known as \"looping\". For example, in Javascript, repeating elements are often rendered in a webpage using loops. If a React developer needs to display a repeating component, they could use a pattern similar to the given problem. This could be a list where each item should display a number of times corresponding to its value, like stars in a rating system or in creating user interface patterns. It's a fundamental concept in creating dynamic content based on variable data.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern5",
                                "problem_name": "Pattern 5",
                                "problem_slug": "pattern-5",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun fact: This basic problem is designed to test your understanding of loops and string manipulation, which are basic in almost any programming language. In the real world, similar patterns and principles might be used for creating complex data visualization tools, ASCII art, or templating engines that generate HTML for web pages. Drawing patterns, grids, or other specific shapes is often a core part of game development as well, so praticing such problems can be a kick-start towards learning how to develop basic graphical elements in game designing.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern6",
                                "problem_name": "Pattern 6",
                                "problem_slug": "pattern-6",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem, while simple, forms the basic building block for algorithms related to pattern recognition and generation. In real-world software development, these kind of pattern algorithms underlie many different aspects, from simple user interface design (creating repetitive patterns or layouts) to more complex concepts like creating game stages procedurally in video game development. This exercise of generating patterns based on a given number can also serve as the elementary introduction to recursive functions and loops, vital concepts in any kind of programming.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern7",
                                "problem_name": "Pattern 7",
                                "problem_slug": "pattern-7",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem, at its core, is about iteration, conditional logic, and string manipulation - fundamental concepts in many programming languages. In real world applications, a form of this problem can be seen in creating dynamic visualizations or graphical outputs in console-based applications. For example, console-based games, progress bar visualization, and console animations all use similar logic to create dynamic, visually-oriented outputs.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern8",
                                "problem_name": "Pattern 8",
                                "problem_slug": "pattern-8",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "While this problem may not seem directly applicable to real-world software development, the skills you use to solve it certainly are. This type of problem teaches two key programming concepts: loops and string manipulation. Both are widely applied in many fields of software development. For example, in web development, loops and string manipulations are often used to dynamically generate HTML or format text content. In data analysis, these skills are essential for parsing and cleaning data. Drawing a pattern like this is also common in computer graphics, used perhaps in creating design elements or animations dynamically.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern9",
                                "problem_name": "Pattern 9",
                                "problem_slug": "pattern-9",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "While developing console-based games, animations, or other graphical representations in terminal, such pattern creation problems come handy. They give an understanding of how to use control structures (like loops) for producing repetitive and patterned output. These concepts are fundamental in developing console output display features in many kinds of software. The ability to create and manipulate these patterns can be extended to more complex graphics rendering challenges.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern10",
                                "problem_name": "Pattern 10",
                                "problem_slug": "pattern-10",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "In the software development, this pattern problem, or its underlying concept of nested iteration, can often be observed in creating visual effects or graphical interfaces. For example, such pattern logic might be used in creating loading animations, pyramid diagrams, or automated design elements in a web or mobile application. On a more abstract level, understanding how to construct and manipulate such patterns is fundamental to working with 2D arrays and matrices - structures widely used in image processing, to represent graphs, in machine learning algorithms, and more.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern11",
                                "problem_name": "Pattern 11",
                                "problem_slug": "pattern-11",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "While this problem may seem trivial, the concept underlying it - pattern recognition and generation, is frequently used in software development. For example, in web development, design patterns such as MVC (Model View Controller) and MVVM (Model View ViewModel) are used. In artificial intelligence, machine learning algorithms often use pattern recognition to make predictions or decisions without being specifically programmed to perform the task. Consequently, having a solid understanding of simple pattern generation problems like this one can build a foundation for understanding more complex pattern-related concepts in various fields of software development and data science.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern12",
                                "problem_name": "Pattern 12",
                                "problem_slug": "pattern-12",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Though this problem seems purely academic, the underlying concepts - the manipulation of strings and control structures like loops, are fundamental in many areas of software development. For instance, generating dynamic SQL queries for specific situations often requires sophisticated string manipulation. Also, the understanding and usage of nested loops are crucial in rendering hierarchical data or multi-dimensional arrays, like creating expandable menu systems in app development. So while this exact problem may not be seen in the wild, its elemental concepts are heavily utilized in coding.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern13",
                                "problem_name": "Pattern 13",
                                "problem_slug": "pattern-13",
                                "problem_rank": 13,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of this problem is often used in the display logic of many applications. For instance, in social media apps like Instagram, the images are displayed in a similar pattern, where each new row may have more images than previous. Similar logic can be seen in calendar based applications and games, where the positions of different data points or objects are calculated dynamically based on a specific pattern. Understanding this ensures that developers can create interfaces that are adaptable and user friendly.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern14",
                                "problem_name": "Pattern 14",
                                "problem_slug": "pattern-14",
                                "problem_rank": 14,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This programming problem trains you in understanding and manipulating strings, which is a fundamental concept in software development. In real-world applications, this exercise could apply to systems requiring hierarchical data representation or nested data structures. For instance, consider a file manager where files/folders are nested within other folders. Each level of the hierarchy could be represented by a different letter of the alphabet, giving a visual indicator of the current depth in the hierarchy. Likewise, file paths in Unix-like operating systems could be shown using this pattern, with each subsequent directory represented by an additional alphabet letter. This problem can also have its applications in generating different patterns which is a key aspect of creating graphs or visualizations in software applications.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern15",
                                "problem_name": "Pattern 15",
                                "problem_slug": "pattern-15",
                                "problem_rank": 15,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This type of problem is not directly applied in the software industry, but the underlying concept of iteration and pattern generation is frequently used. For instance, it forms a basic approach in developing functionalities for pattern matching, text formatting, and UI elements rendering in web and app development. This kind of progressive reduction is also seen in progressive loading of images or elements on web pages or in game developments to save on resource usage.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern16",
                                "problem_name": "Pattern 16",
                                "problem_slug": "pattern-16",
                                "problem_rank": 16,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: This problem may seem simple but it mirrors a fundamental concept in programming: loops and control structures. While in this problem it is used to print patterns, in real world applications, these loops could be used to iterate through data, increment counters, insert into databases or update UI components. Moreover, concepts used in this problem are extensively used in animation software, framework development, and even in game development where such pattern logic can be used to create various levels or stages. So next time when you see a pattern in a game, remember, it could be something as simple as this problem behind the scene!",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern17",
                                "problem_name": "Pattern 17",
                                "problem_slug": "pattern-17",
                                "problem_rank": 17,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This programming problem essentially tests the concept of pattern/problem recognition and string manipulation, which are vital in many areas of software development. For instance, in data analysis or processing platforms, there often are requirements to detect and manipulate data patterns. Moreover, in various machine learning models such as natural language processing, the concept of pattern recognition and string manipulation is extensively used to train the models to understand, recognize, and generate human-like text.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern18",
                                "problem_name": "Pattern 18",
                                "problem_slug": "pattern-18",
                                "problem_rank": 18,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "One practical application of this problem in software development is in web development frameworks like JavaScript's React. This problem teaches the concept of iterative rendering, a technique wherein components are rendered repeatedly based off a value or dataset, similar to how the alphabet patterns are being generated iteratively in the problem. In React, this can be seen in rendering lists of elements where individual components are rendered based on the number of items in the array. This problem aids in strengthening the concept of handling such dynamic data rendering.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern19",
                                "problem_name": "Pattern 19",
                                "problem_slug": "pattern-19",
                                "problem_rank": 19,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept underlying this problem, pattern generation, is frequently used in various aspects of software development. For example, in game development, similar algorithms are introduced to generate unique textures or to progress game levels. In data visualization libraries and apps, pattern generation algorithms are used to create aesthetically pleasing and easy to understand visual representations of data. Furthermore, ASCII art, which is similar to this problem, has applications in stylizing console output and creating visually appealing comment blocks in code.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern20",
                                "problem_name": "Pattern 20",
                                "problem_slug": "pattern-20",
                                "problem_rank": 20,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem demonstrates the concept of loops and pattern recognition/matching which is a fundamental aspect in many software applications. In the real-world, pattern generation problems like this are commonly used in computer graphics and game development to generate textures, shapes, or terrain. It is also used in tools like regular expression engines which are widely used in text parsing, syntax highlighting, data validation, and search functionalities which are core to numerous software applications. Interesting fact: Algorithms to generate complex patterns are also pivotal in certain aspects of cryptography and data security.",
                                    "hints": [],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern21",
                                "problem_name": "Pattern 21",
                                "problem_slug": "pattern-21",
                                "problem_rank": 21,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This simple programming problem highlights the use of loops and control flow which forms the basis of many graphics and game development concepts. For example, such pattern drawing exercises lay the groundwork for understanding nested loops which are very common in game grids or tile maps, bitmap graphics, and visual simulations. Moreover, this is the core concept behind rendering of shapes in computer graphics, interfaces, animation, and even 3D modeling software. It is also used in designing UI layout and border styles in web development.",
                                    "hints": [],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_patterns_pattern22",
                                "problem_name": "Pattern 22",
                                "problem_slug": "pattern-22",
                                "problem_rank": 22,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "One real-world application of this problem is in graphic design software and games, where such patterns might be used to create programmatically generated visuals or puzzles. Understanding how to construct complex patterns from simple mathematical rules is a fundamental aspect of procedural generation, a technique commonly used in game design to create vast, explorable worlds on the fly.",
                                    "hints": [],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "fundamentals_timecomplexity",
                        "subcategory_name": "Time Complexity",
                        "subcategory_slug": "time-complexity",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "fundamentals_fundamentals_timecomplexity_theorywithexamples",
                                "problem_name": "Theory with examples",
                                "problem_slug": "theory-with-examples",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "fundamentals_stlandcollections",
                        "subcategory_name": "STL and Collections",
                        "subcategory_slug": "stl-and-collections",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "fundamentals_fundamentals_stlandcollections_stl",
                                "problem_name": "STL",
                                "problem_slug": "stl",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "fundamentals_fundamentals_stlandcollections_javacollections",
                                "problem_name": "Java Collections",
                                "problem_slug": "java-collections",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "fundamentals_conceptbasics",
                        "subcategory_name": "Concept Basics",
                        "subcategory_slug": "concept-basics",
                        "subcategory_rank": 6,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "fundamentals_fundamentals_conceptbasics_basicmaths",
                                "problem_name": "Basic Maths",
                                "problem_slug": "basic-maths",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "fundamentals_fundamentals_conceptbasics_basichashing",
                                "problem_name": "Basic Arrays",
                                "problem_slug": "basic-arrays-hashing-and-strings",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_conceptbasics_basichashing",
                                "problem_name": "Basic Hashing",
                                "problem_slug": "basic-hashing",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_fundamentals_conceptbasics_basicstring",
                                "problem_name": "Basic String",
                                "problem_slug": "basic-string",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_basicmaths",
                        "subcategory_name": "Basic Maths",
                        "subcategory_slug": "basic-maths",
                        "subcategory_rank": 7,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_basicmaths_countalldigitsofanumber",
                                "problem_name": "Count all digits of a number",
                                "problem_slug": "count-all-digits-of-a-number",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This simple programming problem teaches you how to work with integers at a deep level, essential knowledge for many aspects of computing. For example, in video games, a similar concept is used to calculate scores or health points, which involve lots of operations with integers. Also, in data analysis software or ETL (Extract, Transform, Load) processes, the size and format of figures need to be manipulated and processed, which requires deep understanding and competence in handling numbers and digits.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_countnumberofodddigitsinanumber",
                                "problem_name": "Count number of odd digits in a number",
                                "problem_slug": "count-number-of-odd-digits-in-a-number",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem showcases the use of modulo operation and string manipulation which are both fundamental concepts in programming. In real-world applications, the problem can be related to the processing of user input in apps or software - for example, credit card numbers, phone numbers, or social security numbers. Here, each digit may need to be individually checked and processed, either for validation, encryption, or some other kind of transformation. In such cases, code similar to the solution of this problem could be used.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_reverseanumber",
                                "problem_name": "Reverse a number",
                                "problem_slug": "reverse-a-number",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: Reversing the digits of a number is often used in designing certain algorithms and applications, such as in credit card number processing or generating unique access codes. This kind of problem strengthens understanding of basic manipulation and conversion of data types, especially in languages that treat strings and integers distinctly.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_palindromenumber",
                                "problem_name": "Palindrome number",
                                "problem_slug": "palindrome-number",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Palindrome checking, as in this problem, is often used in error detection within computer systems. It's used specifically in the realm of ECC (Error Checking and Correction) memory, commonly seen in crucial systems such as servers. Here, bits are encoded with a simple algorithm which checks if a string of binary data reads the same backwards as forwards to prevent potential crashes from memory faults. Additionally, palindrome checking can be applied in string processing within Natural Language Processing (NLP) applications for linguistic pattern detection.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_returnthelargestdigitinanumber",
                                "problem_name": "Return the largest digit in a number",
                                "problem_slug": "return-the-largest-digit-in-a-number",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This concept is used widely in validation of inputs or entities in software applications. In banking software or financial applications, you may sometimes have to validate credit card numbers, account numbers, or other numeric inputs where identifying and manipulating the largest digit could be part of the process. Similarly, in gaming and sports applications, stats and scores often involve working with largest digits for comparison and ranking purposes.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_factorialofagivennumber",
                                "problem_name": "Factorial of a given number",
                                "problem_slug": "factorial-of-a-given-number",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: Factorial problems and algorithms are often used in real-world applications for solving problems involving permutations and combinations. This can be found in software related to statistics, probability, data analysis, and also in some optimization algorithms. For instance, Google's search algorithms use factorial calculations for providing various combinations of search results, and in machine learning, factorials play a critical role in calculating the probabilities in Bayesian Networks.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_checkifthenumberifarmstrong",
                                "problem_name": "Check if the number is armstrong",
                                "problem_slug": "check-if-the-number-if-armstrong",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: While the Armstrong number itself might not have a direct application in software development, the underlying logic of dealing with integer manipulation, loops, and conditionals can be found in various aspects of coding like data validation, checksum algorithms or hash functions. Algorithms to identify Armstrong numbers act as brain teasers to improve logical thinking and problem-solving skills which are essential in breaking down complex software development tasks. For instance, the concept can be used in encryption algorithms to add an extra layer of security.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_checkforperfectnumber",
                                "problem_name": "Check for perfect number",
                                "problem_slug": "check-for-perfect-number",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This simple mathematical concept is often used in error detection and correction algorithms in software development. In particular, it is used during checksum techniques where data is divided into equal parts. The sum of these parts should add up to a predefined value (a perfect number in some cases). If the sum isn't a perfect number, it indicates that an error has occurred during data transmission, allowing developers to detect and correct errors. These are especially useful in network communications and data storage systems which require high reliability.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_checkforprimenumber",
                                "problem_name": "Check for prime number",
                                "problem_slug": "check-for-prime-number",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Prime number checking is a foundational concept in cryptography, particularly in public key encryption algorithms such as RSA. RSA relies intensively on the properties of prime numbers. The security of RSA is based on the fact that factoring large prime numbers is computationally intensive. Hence, when your browser secures a connection to a website (HTTPS), prime numbers are being used to encrypt the data.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_countofprimenumberstilln",
                                "problem_name": "Count of prime numbers till N",
                                "problem_slug": "count-of-prime-numbers-till-n",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Prime number generation and recognition is an important concept in cryptographic algorithms, which serve as a basis for secure communication in the digital world. For example, RSA algorithm, which is widely used for secure data transmission, is based on the principle of factoring large prime numbers. The difficulty in factoring the product of two large prime numbers ensures that RSA is secure. Therefore, a function that can efficiently generate or identify prime numbers can contribute to the efficiency and strength of these algorithms.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_gcdoftwonumbers",
                                "problem_name": "GCD of two numbers",
                                "problem_slug": "gcd-of-two-numbers",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Here's a fun fact: the concept of finding the Greatest Common Divisor (GCD) is used in real-world encryption algorithms, particularly in RSA encryption. RSA, which stands for Rivest-Shamir-Adleman, is a public key encryption technology used widely in securing sensitive data, especially when being sent over an insecure network. It involves the use of large prime numbers, and the computation of their GCD, to generate secure public and private keys. So, the algorithm to solve this programming problem is integral to promoting online security and privacy.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_lcmoftwonumbers",
                                "problem_name": "LCM of two numbers",
                                "problem_slug": "lcm-of-two-numbers",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept of finding the Lowest Common Multiple (LCM) in this problem is commonly applied in real world scheduling and timer systems. For example, in operating systems, different tasks or processes can have different intervals or frequencies of operation. To ensure smooth co-existence, the system must determine a common time frame to accommodate all these processes. That common time frame is often calculated as the LCM of all the different intervals. Therefore, the concept of LCM is of fundamental importance in operating system design and other time-dependent systems.",
                                    "hints": [],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicmaths_divisorsofanumber",
                                "problem_name": "Divisors of a number",
                                "problem_slug": "divisors-of-a-number",
                                "problem_rank": 13,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The underlying concept from this problem, finding all the divisors of a number, is surprisingly important in cryptography, a critical part of information security. Specifically, it's used in the RSA encryption algorithm, which is widely implemented in communication protocols like HTTPS for secure data transmission over the internet. The algorithm uses two large prime numbers, whose product serves as a key. The security of RSA is based on the fact that, even knowing the product, it's difficult to determine the original primes (i.e., find the divisors), particularly as the prime numbers used become larger.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_basicarrays",
                        "subcategory_name": "Basic Arrays",
                        "subcategory_slug": "basic-arrays",
                        "subcategory_rank": 8,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_basicarrays_sumofarrayelements",
                                "problem_name": "Sum of array elements",
                                "problem_slug": "sum-of-array-elements",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This seemingly simple programming problem, calculating the sum of all elements in an array, has powerful real-world applications. For example, it's used in the creation of statistical software and data analysis applications, such as Excel and Google Sheets. Developers utilize this concept to implement features that enable users to sum up large columns or rows of numerical data in these spreadsheet applications, facilitating businesses and researchers to quickly perform financial or scientific calculations.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicarrays_countofoddnumbersinarray",
                                "problem_name": "Count of odd numbers in array",
                                "problem_slug": "count-of-odd-numbers-in-array",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Here's a fun fact: this problem is a basic exercise in data analytics, which is a massive part of the software industry. Almost all major companies - like Facebook, Google, Amazon - use data analytics to make informed decisions. This task is similar to finding specific patterns in the data, such as user habits or preferences. It's like asking, \"how many users made purchases at odd-numbered hours?\" or \"how many users have spent an odd amount of money on our platform?\" Understanding these patterns helps companies enhance their user experiences and profitability.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicarrays_reverseanarray",
                                "problem_name": "Reverse an array",
                                "problem_slug": "reverse-an-array",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "In many popular software applications such as video editors or music players, reversing an array, which is essentially reversing a sequence, is an important feature. For example, reversing a video clip plays the frames in backward order leading to a reversed video, which is achieved through the same underlying concept as reversing an array.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicarrays_checkifthearrayissorted",
                                "problem_name": "Check if the array is sorted",
                                "problem_slug": "check-if-the-array-is-sorted",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem's underlying concept plays an integral role in many database management systems. When you search for something in a database, for example, a name in the contact application on your phone, it doesn't start from the beginning and search through every single entry. Instead, it uses the concept of a \"sorted array\" to execute binary search algorithms, allowing for significantly faster search responses. So, this fundamental concept contributes critically to the overall efficiency and response time of numerous software applications.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_basichashing",
                        "subcategory_name": "Basic Hashing",
                        "subcategory_slug": "basic-hashing",
                        "subcategory_rank": 9,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_basichashing_highestoccurringelementinanarray",
                                "problem_name": "Highest occurring element in an array",
                                "problem_slug": "highest-occurring-element-in-an-array",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "The underlying concept of this problem is extensively used in data analytics, specifically in areas requiring analysis of user behaviour. For example, music streaming apps often need to find the most frequently listened song among a pool of users. In this case, the 'array of n integers' could represent users' song preferences and the 'most frequent element' would be the most popular song. Furthermore, finding the 'smallest of them' could be analogous to identifying the most popular song with the shortest duration, which could influence decisions in areas like marketing or content curation.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basichashing_secondhighestoccurringelement",
                                "problem_name": "Second highest occurring element",
                                "problem_slug": "second-highest-occurring-element",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This type of algorithm is quite often used in the world of data analytics and marketing. Understanding frequency distribution in a dataset is key for identifying trends or patterns. For example, a streaming service like Netflix or Spotify might use a similar algorithm to identify the second most frequently watched or listened-to genre or artist, to suggest it to their viewers or listeners, enhancing personalization and user experience based on these insights. It could also be used in text analytics or natural language processing to find the second most frequently used word in a text, which can be instrumental in sentiment analysis, SEO keyword analysis, and more.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basichashing_sumofhighestandlowestfrequency",
                                "problem_name": "Sum of highest and lowest frequency",
                                "problem_slug": "sum-of-highest-and-lowest-frequency",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This programming problem is conceptually related to data analysis and statistics, often used in the software industry for user behavior analysis, trend identification, and recommendation systems. The identification of the most and least frequent values (modal and anti-modal values) is commonly used in sectors like e-commerce and social media to understand user preferences and trends, such as the highest and lowest selling products, or the most and least liked posts.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_basicstrings",
                        "subcategory_name": "Basic Strings",
                        "subcategory_slug": "basic-strings",
                        "subcategory_rank": 10,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_basicstrings_reverseastring",
                                "problem_name": "Reverse a string",
                                "problem_slug": "reverse-a-string",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "The reverse string problem and its underlying concept of in-place algorithm with limited space complexity have a lot of practical applications. This concept is crucial in fields like data processing where memory space is a prime concern. For instance, when building content editing software such as those used in blogs or publishing tools, features like undo-redo management or palindrome checking often leverage the idea of reversing a string or sequence in-place. Even in popular databases, the optimization of data manipulation and retrieval operations uses these techniques. Sometimes, a clever application of such reversal logic can lead to efficient software solutions.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_palindromecheck",
                                "problem_name": "Palindrome Check",
                                "problem_slug": "palindrome-check",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Palindrome checking algorithms, similar to the problem statement, have interesting implications in the development of DNA sequence analysis tools used in Bioinformatics. Since DNA can be read in both directions, identifying palindromic sequences is a key in the detection of special genetic markers called Restriction sites, essential in Genetic Engineering. Even simple programming challenges have enormous potential in real world applications!",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_largestoddnumberinastring",
                                "problem_name": "Largest odd number in a string",
                                "problem_slug": "largest-odd-number-in-a-string",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: A real-world application of such a problem can be found within Big Data Processing software and Financial Technologies (Fintech). In these fields, theres often a need to deal with large integers, convert them to strings and extract specific parts. For instance, certain aspects of financial analysis require the extraction of specific digits or series of digits from large numbers. Similarly in network security, similar tasks are required for cryptographic operations to encrypt or decrypt data. Thus problems like these underpin several major operations in Fintech and Security industry.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_longestcommonprefix",
                                "problem_name": "Longest common prefix",
                                "problem_slug": "longest-common-prefix",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The problem of finding the longest common prefix among an array of strings is often used in the field of autocompletion and suggestion engines, which are quite prevalent in search engines, IDEs (Integrated Development Environments), and so on. When a user starts typing something, these engines use the longest common prefix algorithm to generate relevant and instant suggestions to the user based on historical and contextual data. Such functionalities optimize the user experience and efficiency in using the software application.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_isomorphicstring",
                                "problem_name": "Isomorphic string",
                                "problem_slug": "isomorphic-string",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept of string isomorphism, as in this problem, is often employed in the world of cryptography and data encryption. It's all about establishing a systematic correspondence from one set of characters to another. Converting plain text into encrypted data relies on such mappings to provide data security. So, next time you send a secure, encrypted message, do remember, it's all about the isomorphism!",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_rotatestring",
                                "problem_name": "Rotate string",
                                "problem_slug": "rotate-string",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun fact: The concept of string shifting like in this problem is actually used in certain types of encryption and decryption algorithms, especially in the field of cybersecurity. This concept is also used in implementing certain functions of text editors and data processing tools, where words, sentences, or paragraphs need to be shifted or rearranged. Solving such problems helps programmers in understanding how to manipulate and process strings effectively, which is a fundamental aspect in fields such as data management, web development, and more.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_validanagram",
                                "problem_name": "Valid Anagram",
                                "problem_slug": "valid-anagram",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept of checking for anagrams, as given in the problem, has practical uses in natural language processing and computer science. This logic is often incorporated in games such as Scrabble or Words with Friends, where users must form words from a given set of letters. It is also used in spell-checking algorithms and plagiarism detection software to spot potential copy-pasting by comparing anagrams. Highlighting the versatility of this concept, it is also applied in bioinformatics where it is necessary to look for anagrams in DNA sequencing, which can support meaningful discoveries in genetics.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstrings_sortcharactersbyfrequency",
                                "problem_name": "Sort characters by frequency",
                                "problem_slug": "sort-characters-by-frequency",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This problem is often encountered when developing data analysis tools or text editors, where understanding the frequency of character usage can be important. For instance, optimizing compression algorithms such as Huffman coding relies on knowing the frequency of each character in the dataset. This problem's concept is also used in SEO (Search Engine Optimization) analytics, where the frequency of certain words or characters can affect a webpages visibility in search engine results.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "extras_basicrecursion",
                        "subcategory_name": "Basic Recursion",
                        "subcategory_slug": "basic-recursion",
                        "subcategory_rank": 11,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "extras_extras_basicrecursion_recursiontheory",
                                "problem_name": "Recursion Theory",
                                "problem_slug": "recursion-theory",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_recursionconceptswithparameters",
                                "problem_name": "Recursion Concepts with Parameters",
                                "problem_slug": "recursion-concepts-with-parameters",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_sumoffirstnnumbers",
                                "problem_name": "Sum of first N numbers",
                                "problem_slug": "sum-of-first-n-numbers",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept of summing up the first N natural numbers is often used in the development of performance analysis and benchmarking tools. These tools help developers understand the performance of their software by simulating a series of operations, such as calculating how long it takes to sum up a series of numbers, and then analyze the time complexity. The principle also has real-world usages in databases when dealing with sequence generation or serial numbers, and in building progress bar logic in numerous softwares or apps.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_factorialofagivennumber",
                                "problem_name": "Factorial of a given number",
                                "problem_slug": "factorial-of-a-given-number",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Factorials are widely used in software industry, particularly in algorithms related to probabilistic modeling and calculations. For instance, in Google's search algorithms, factorials are used in calculating possible combinations of keywords and search entries to provide the most relevant search results. Similarly, in artificial intelligence and machine learning, factorials play a crucial role in statistical calculations and in computing combinations and permutations.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_sumofarrayelements",
                                "problem_name": "Sum of array elements",
                                "problem_slug": "sum-of-array-elements",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "While summing elements of an array using recursion might seem like a straightforward task, this concept and programming technique have wide-ranging applications in various aspects of software development. For instance, whenever a developer needs to traverse a tree-like data structure, such as the Document Object Model (DOM) in web development, or a directory structure in a filesystem, a recursive algorithm, similar to the one used in this problem, could be employed. Using recursion to traverse through these structures allows developers to perform operations likewise summing on nodes at each level effectively.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_reverseastring",
                                "problem_name": "Reverse a string",
                                "problem_slug": "reverse-a-string",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The 'reverse a string' problem comes in handy in the development of various real world applications such as undo functionality in software apps like Microsoft word, or any text editor which allows users to revert their actions. It's also commonly used in palindrome checking algorithms, data encryption/decryption, and in some database migrations.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_checkifstringispalindromeornot",
                                "problem_name": "Check if string is palindrome or not",
                                "problem_slug": "check-if-string-is-palindrome-or-not-",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Palindrome problems or algorithms are often used in the development of natural language processing technologies, like chatbots and digital assistants. The performance of these technologies significantly depends on their capability of detecting and understanding patterns, including palindromes, in natural language. This helps in analyzing sentences better, understanding contexts, improving user experience, and adding a pinch of humor. For example, a chatbot could be programmed to identify palindromes and respond with a humorous reply when a user inputs a palindromic phrase.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_checkifanumberisprimeornot",
                                "problem_name": "Check if a number is prime or not",
                                "problem_slug": "check-if-a-number-is-prime-or-not",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Prime number checking, the underlying concept of this problem, is a crucial component in cryptography, particularly RSA algorithm, which is widely used in secure data transmission. The security of RSA is based on the practical difficulty of factoring the product of two large prime numbers, the factoring problem.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_reverseanarray",
                                "problem_name": "Reverse an array",
                                "problem_slug": "reverse-an-array-ii",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Fun Fact: The concept of reversing an array is used in many popular applications like social media platforms or music streaming apps. For instance, in apps like Instagram or Facebook, when you scroll through comments or posts, you're actually traversing a reversed array. The latest posts/comments are at the beginning of the array and as you scroll, you move towards the older posts/comments at the end of the array. Similarly, in a music app's playlist, the 'play in reverse order' functionality also uses this concept. Also, reversing is a commonly used feature in data visualization, where one might want to flip the data to view it from a different perspective.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_checkifthearrayissorted",
                                "problem_name": "Check if the array is sorted",
                                "problem_slug": "check-if-the-array-is-sorted",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "Did you know that checking if an array is sorted or not has real world applications in the field of Data Analysis and Machine Learning? These fields often involve dealing with huge amounts of data that need to be sorted for efficient processing. Being able to quickly determine if a data set is already sorted can help minimize processing time and resources, leading to more efficient predictions and analyses. Having a function to do this can help streamline processes in these high-demand fields.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_sumofdigitsinagivennumber",
                                "problem_name": "Sum of digits in a given number",
                                "problem_slug": "sum-of-digits-in-a-given-number",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "This type of programming problem underlies many applications which need numeric validation, data integrity checks or compression tasks. For example, control digit computation, often used for credit cards number or ISBN code validation, implements similar logic. This problem's concept is also useful in checksum algorithms in data transmission to ensure data completeness. Also, digital root calculation, which is the essence of this task, is a part of various cryptographic techniques and pseudorandom number generation systems, fundamental for security and gaming software respectively.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicrecursion_fibonaccinumber",
                                "problem_name": "Fibonacci Number",
                                "problem_slug": "fibonacci-number",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "IBM",
                                        "HCL",
                                        "Tech Mahindra",
                                        "MindTree"
                                    ],
                                    "facts": "The Fibonacci sequence is a fundamental concept in computer science and finds use in several real-world applications. One fascinating example lies in agile project management, specifically Scrum. Team members use Fibonacci numbers to estimate the complexity or effort required for tasks. This system, known as Fibonacci estimation, is based on the theory that its harder to estimate bigger tasks with precision, so Fibonacci's ever-increasing gap between numbers reflects this uncertainty.",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "sorting",
                "category_name": "Sorting",
                "category_slug": "sorting",
                "category_rank": 1,
                "subcategories": [
                    {
                        "subcategory_id": "sorting_algorithms",
                        "subcategory_name": "Algorithms",
                        "subcategory_slug": "algorithms",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "sorting_sorting_algorithms_selectionsort",
                                "problem_name": "Selection Sort",
                                "problem_slug": "selection-sort",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "Bungie",
                                        "Qualcomm",
                                        "Uber",
                                        "Morgan Stanley",
                                        "Zoho",
                                        "Electronic Arts",
                                        "Reddit",
                                        "Ubisoft",
                                        "PwC",
                                        "Broadcom",
                                        "Rakuten",
                                        "OYO Rooms",
                                        "Seagate Technology",
                                        "Epic Games",
                                        "Nutanix",
                                        "Target",
                                        "Pinterest",
                                        "Boston Consulting Group",
                                        "Optum",
                                        "KPMG",
                                        "JPMorgan Chase",
                                        "Cerner",
                                        "MongoDB",
                                        "Red Hat",
                                        "McKinsey & Company",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The Selection Sort algorithm, which is the focus of this problem, is widely used in software development for its simplicity and efficiency when dealing with small data sets. It serves as a building block in various applications like e-commerce platforms and database technologies, where sorting of data is an important functionality. In real-world applications, it would often be used as a part of a more complex sorting algorithm to sort small sublists within a larger, more complex, sorting problem.",
                                    "hints": [
                                        {
                                            "hint": "Think Small First, at each step, identify the smallest element in the unsorted portion of the array and place it in its correct position."
                                        },
                                        {
                                            "hint": "Use Divide and Conquer Mindset, visualize sorting as splitting the array into sorted and unsorted parts, and shrinking the unsorted part one element at a time."
                                        },
                                        {
                                            "hint": "Focus on how you can repeatedly compare elements and rearrange them in-place without needing additional memory."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, selection sort can handle duplicate elements effectively. During each iteration, the algorithm identifies the smallest element in the unsorted portion, even if duplicates exist. The duplicates are treated like any other elements and sorted based on their relative positions, preserving the order among equal elements.",
                                            "question": "Can selection sort handle duplicate elements properly?"
                                        },
                                        {
                                            "answer": "Selection sort doesnt check if the array is already sortedit always performs O(n2) comparisons because the algorithm doesnt adapt to sorted inputs. While no swaps may occur if the array is sorted, the comparisons in the inner loop are still executed, making it inefficient for pre-sorted data.",
                                            "question": "What happens if the array is already sorted? Is it still efficient?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To sort the array in descending order, you need to modify the algorithm to find the largest element in the unsorted portion during each iteration instead of the smallest. Then, place this largest element at the current position in the sorted portion.\n\nHeres the adjusted approach:\n\nIn the inner loop, compare elements to find the maximum instead of the minimum.\nSwap the maximum element with the current index of the sorted portion.\nExample:\nInput: [4, 2, 9, 1]\nProcess:\n\nFind the largest (9) and swap with the first element: [9, 2, 4, 1].\nFind the next largest (4) in the unsorted portion and swap: [9, 4, 2, 1].\nContinue until sorted in descending order: [9, 4, 2, 1].\nThis change preserves the same O(n2) time complexity but adapts the algorithm for descending order.\n",
                                            "question": "Can you modify the selection sort algorithm to sort the array in descending order? What changes would you make?"
                                        },
                                        {
                                            "answer": "1. Selection sort works in-place and uses O(1) extra memory. For systems with strict memory limitations, it is a viable choice.\n2. For small arrays (e.g., fewer than 10 elements), the simplicity of selection sort can outweigh its inefficiency. The overhead of more complex algorithms, like merge sort or quicksort, might not be justified.\n\nExample: Sorting [5, 2, 1] in embedded systems with limited RAM can efficiently use selection sort.\n",
                                            "question": "Selection sort has O(n2) time complexity. Can you identify a scenario where selection sort might still be a preferred choice?"
                                        },
                                        {
                                            "answer": "Time Complexity: Both have O(n^2) worst-case time complexity. However, insertion sort can outperform selection sort for nearly sorted arrays because it minimizes shifts, while selection sort always performs n1 comparisons in the inner loop, regardless of the array's state.\n\nSwaps vs. Shifts: Selection sort minimizes swaps (n1 swaps in total), making it suitable for situations where swap costs are high (e.g., flash memory). Insertion sort involves more shifts, especially for large unsorted portions.\nExample:\nFor an array like [2, 3, 4, 5, 1], insertion sort will quickly sort it with fewer operations because most elements are already in place. In contrast, selection sort performs the same number of comparisons regardless of the initial order, making it less efficient in this case.",
                                            "question": "How does selection sort compare to insertion sort in terms of performance and use cases? Can you analyze and contrast them?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "sorting_sorting_algorithms_bubblesort",
                                "problem_name": "Bubble Sort",
                                "problem_slug": "bubble-sort",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Flipkart",
                                        "PayPal",
                                        "ARM",
                                        "Goldman Sachs",
                                        "Zomato",
                                        "Micron Technology",
                                        "Philips Healthcare",
                                        "Shopify",
                                        "Intel",
                                        "Morgan Stanley",
                                        "Cloudflare",
                                        "JPMorgan Chase",
                                        "Roblox",
                                        "Broadcom",
                                        "Target",
                                        "Square",
                                        "Bungie",
                                        "Swiggy",
                                        "IBM",
                                        "KPMG",
                                        "DoorDash",
                                        "OYO Rooms",
                                        "Nutanix",
                                        "Ubisoft",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Although bubble sort is widely regarded as inefficient for large datasets due to its worst-case and average time complexity of O(n), it is popular in teaching introductory computer science courses, both for its simplicity and because it performs well in scenarios with small and nearly sorted datasets. Some software testing and debugging tools, especially those maintaining watchlists or logs, may make use of bubble sort where the expected input size isn't large but the order is crucial for correct interpretation of results.",
                                    "hints": [
                                        {
                                            "hint": "Focus on comparing adjacent elements and swapping them if they are in the wrong order. Repeat this until no swaps are needed. After each iteration, the largest element in the unsorted portion moves to its correct position at the end."
                                        },
                                        {
                                            "hint": " For Optimization, Think about stopping the algorithm early if no swaps occur during an iteration, indicating the array is already sorted."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, bubble sort can handle duplicate elements. It treats duplicates like any other element and compares them during iterations. Since duplicates are not swapped unnecessarily, their relative order remains unchanged, preserving stability.\nExample:\nInput: [4, 2, 4, 1]\nOutput: [1, 2, 4, 4]",
                                            "question": "Can bubble sort handle duplicate elements?"
                                        },
                                        {
                                            "answer": "Already Sorted: The algorithm performs a single pass and terminates early if optimized. Without optimization, it will still make unnecessary passes.\nReverse Sorted: Bubble sort performs the maximum number of swaps (O(n2)) because every element needs to be repositioned.\nExample (Reverse Sorted):\nInput: [5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5]",
                                            "question": "What happens if the array is already sorted or reverse sorted?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To sort in descending order, modify the comparison condition to check if the current element is smaller than the next element. Swap them if so.\n\nExample:\nInput: [4, 2, 9, 1]\nProcess:\n\nCompare 4 and 2  No swap.\nCompare 2 and 9  Swap: [4, 9, 2, 1].\nContinue until sorted in descending order: [9, 4, 2, 1].",
                                            "question": "Can you modify bubble sort to sort in descending order?"
                                        },
                                        {
                                            "answer": "Time Complexity: All three have a worst-case time complexity of O(n2). However, bubble sort generally performs worse due to its many comparisons and swaps.\nOptimization: Bubble sort can be optimized to terminate early for sorted arrays, while insertion and selection sorts do not inherently have this feature.\nStability: Both bubble and insertion sorts are stable (preserve the order of duplicate elements). Selection sort is not stable unless modified.",
                                            "question": "How does bubble sort compare to insertion sort and selection sort?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "sorting_sorting_algorithms_insertionsorting",
                                "problem_name": "Insertion Sorting",
                                "problem_slug": "insertion-sorting",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "Medtronic",
                                        "PayPal",
                                        "Optum",
                                        "Pinterest",
                                        "Oracle",
                                        "Johnson & Johnson",
                                        "Byju's",
                                        "NVIDIA",
                                        "JPMorgan Chase",
                                        "Docker",
                                        "Zoho",
                                        "Shopify",
                                        "Etsy",
                                        "Alibaba",
                                        "Roche",
                                        "IBM",
                                        "Snowflake",
                                        "Salesforce",
                                        "McKinsey & Company",
                                        "Goldman Sachs",
                                        "Mastercard",
                                        "American Express",
                                        "Cloudflare",
                                        "Bain & Company",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Insertion sort, the algorithm underlying this problem, is used extensively in computer programming not only for sorting arrays but also for organizing and retrieving data efficiently. It is especially useful when dealing with small data sets or lists that are nearly sorted because it works faster in such cases. Flash memory algorithms typically use this sorting method due to its stability and less requirement of write swaps. Moreover, it's used in online sorting where the list is being actively updated while being maintained in sorted order.",
                                    "hints": [
                                        {
                                            "hint": " Think of the array as divided into a sorted and unsorted portion. Start with the first element as \"sorted\" and expand this portion by inserting elements from the unsorted part."
                                        },
                                        {
                                            "hint": "In cases where the key is already greater than or equal to the largest element in the sorted portion, no shifts are needed, improving efficiency for nearly sorted arrays."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In the worst case (reverse order), each element needs to be compared with all previous elements and shifted to the beginning of the array, leading to O(n2) time complexity.",
                                            "question": "What happens when the array is reversed?"
                                        },
                                        {
                                            "answer": "Insertion sort is efficient for small or nearly sorted datasets because fewer shifts are needed, and it avoids unnecessary comparisons.\nExample:\nInput: [1, 2, 3, 4, 5] (Sorted)\nThe algorithm completes in O(n) as no shifting is required.",
                                            "question": "When is insertion sort efficient?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": " Use binary search to find the correct position for the key in the sorted portion. While this reduces comparisons to O(logn), the shifting operation still takes O(n), so the overall complexity remains O(n2).",
                                            "question": "How can insertion sort be optimized?"
                                        },
                                        {
                                            "answer": "Insertion sort is rarely used for large datasets but is practical for Online Sorting, It is effective for dynamic datasets where elements are added incrementally, as it can quickly re-sort the array.\nExample: Sorting a deck of cards, where new cards are added one at a time.",
                                            "question": "Is insertion sort practical for real-world applications?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "sorting_sorting_algorithms_mergesorting",
                                "problem_name": "Merge Sorting",
                                "problem_slug": "merge-sorting",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Mastercard",
                                        "Stripe",
                                        "Pinterest",
                                        "ARM",
                                        "Snowflake",
                                        "Rockstar Games",
                                        "Cerner",
                                        "Splunk",
                                        "Medtronic",
                                        "Oracle",
                                        "Broadcom",
                                        "Uber",
                                        "DoorDash",
                                        "GE Healthcare",
                                        "Nutanix",
                                        "Electronic Arts",
                                        "Docker",
                                        "Epic Systems",
                                        "Alibaba",
                                        "HCL Technologies",
                                        "Goldman Sachs",
                                        "Red Hat",
                                        "Seagate Technology",
                                        "Optum",
                                        "Airbnb",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "Amazon",
                                        "Google"
                                    ],
                                    "facts": "The merge sort algorithm, which is the core concept of this problem, is widely used in practical software development. One fun fact is that it's the primary algorithm behind the efficient and powerful `sort()` function in many programming languages like Java and Python. This method is used across a wide range of applications, from ranking search engine results to sorting a user's social media feed. It's also often used in database algorithms for efficient data retrieval and storage.",
                                    "hints": [
                                        {
                                            "hint": "Merge sort works by recursively dividing the array into two halves, sorting each half, and then merging the two sorted halves back together. Focus on understanding the \"divide\", \"conquer\", and \"merge\" steps."
                                        },
                                        {
                                            "hint": "Think about how the recursive function handles sorting the left and right halves independently before merging them."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Merge sort requires extra space to store temporary arrays during the merge process. At each step, two halves are merged into a temporary array before copying back into the original array. The space complexity is O(n), where n is the size of the input array.\nExample:\nInput: [4, 3, 2, 1]\nMerge process uses temporary arrays to combine [4, 3] and [2, 1] into sorted halves, and finally merges them into [1, 2, 3, 4].",
                                            "question": "Why does merge sort require extra space, and how much?"
                                        },
                                        {
                                            "answer": "Yes, merge sort naturally handles duplicates by preserving their relative order during the merging process. This makes it a stable sorting algorithm.",
                                            "question": " Can merge sort handle duplicate elements?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Standard merge sort is not in-place because merging two sorted arrays requires additional memory to combine them. However, there are in-place variations of merge sort, but they are complex and trade simplicity and performance for reduced memory usage.",
                                            "question": "Can merge sort be implemented in-place? If not, why?"
                                        },
                                        {
                                            "answer": "Linked lists do not support random access, making quicksort inefficient.\nMerge sort efficiently splits linked lists into halves using pointers without needing extra space for copying.\nMerging two sorted linked lists can be done in O(n) without additional memory overhead.\nExample:\nInput: 4  2  9  1\nProcess:\nSplit into 4  2 and 9  1.\nSort each half: 2  4 and 1  9.\nMerge: 1  2  4  9.",
                                            "question": "Why is merge sort preferred for linked lists?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "sorting_sorting_algorithms_quicksorting",
                                "problem_name": "Quick Sorting",
                                "problem_slug": "quick-sorting",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "Ubisoft",
                                        "Riot Games",
                                        "Mastercard",
                                        "Byju's",
                                        "Splunk",
                                        "Morgan Stanley",
                                        "Electronic Arts",
                                        "Bloomberg",
                                        "Salesforce",
                                        "Epic Games",
                                        "Robinhood",
                                        "Ernst & Young",
                                        "Roche",
                                        "IBM",
                                        "Docker",
                                        "Siemens Healthineers",
                                        "Rockstar Games",
                                        "McKinsey & Company",
                                        "Johnson & Johnson",
                                        "Boston Consulting Group",
                                        "Pinterest",
                                        "Rakuten",
                                        "Activision Blizzard",
                                        "Intel",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: Quick Sort algorithm, which is at the heart of this problem, is a widely used sorting algorithm in practical software development. It is often used in file and database systems due to its efficient runtime performance. For example, the Unix system command 'sort', used for arranging lines of text files or concatenating, is implemented using Quick Sort. It's not only fast, but the algorithm also efficiently sorts in-place, meaning it doesn't require additional memory space to store sorted elements, unlike some other sorting algorithms.",
                                    "hints": [
                                        {
                                            "hint": "Focus on choosing a pivot element. All elements smaller than the pivot go to its left, and all larger elements go to its right. Think about recursively applying the same partitioning logic to the left and right subarrays created by the pivot."
                                        },
                                        {
                                            "hint": "Consider how swapping elements helps to ensure that the pivot ends up in its correct position after partitioning."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Quick sort ensures efficiency by:\nDividing the array into smaller subproblems.\nRecursively sorting these subproblems with O(nlogn) complexity on average.\nBeing cache-friendly due to in-place operations, reducing memory overhead.\nIts performance depends on balanced partitioning, which is achieved through good pivot selection strategies like randomization or median-of-three.",
                                            "question": "How does quick sort ensure efficiency for large datasets?"
                                        },
                                        {
                                            "answer": "Partitioning is the core of quick sort. It rearranges the array so that all elements smaller than the pivot appear before it, and all larger elements appear after it. This ensures the pivot is placed in its correct position. The process enables quick sort to recursively sort smaller subarrays.\nExample:\nInput: [4, 2, 9, 1] with pivot = 4.\nPartitioning results in: [2, 1], [4], [9].\nNow the pivot (4) is correctly positioned in the sorted array.",
                                            "question": "How does quick sort partition the array, and why is it critical?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Quick sort is inherently unstable because the partitioning step involves swapping elements, which can disrupt the relative order of duplicate elements. \nUse extra memory to track original indices.\nModify the partitioning process to preserve the order of equal elements.\n",
                                            "question": "Can quick sort be made stable?"
                                        },
                                        {
                                            "answer": "Partitioning is the core of quick sort. It rearranges the array so that all elements smaller than the pivot appear before it, and all larger elements appear after it. This ensures the pivot is placed in its correct position. The process enables quick sort to recursively sort smaller subarrays.\n\nExample:\nInput: [4, 2, 9, 1] with pivot = 4.\nPartitioning results in: [2, 1], [4], [9].\nNow the pivot (4) is correctly positioned in the sorted array.",
                                            "question": "How does quick sort partition the array, and why is it critical?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "arrays",
                "category_name": "Arrays",
                "category_slug": "arrays",
                "category_rank": 2,
                "subcategories": [
                    {
                        "subcategory_id": "arrays_fundamentals",
                        "subcategory_name": "Fundamentals",
                        "subcategory_slug": "fundamentals",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "arrays_arrays_fundamentals_linearsearch",
                                "problem_name": "Linear Search",
                                "problem_slug": "linear-search",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Texas Instruments",
                                        "Qualcomm",
                                        "Swiggy",
                                        "American Express",
                                        "Zomato",
                                        "Roblox",
                                        "Red Hat",
                                        "Lyft",
                                        "Ubisoft",
                                        "HCL Technologies",
                                        "GE Healthcare",
                                        "Roche",
                                        "Oracle",
                                        "AMD",
                                        "Byju's",
                                        "Dropbox",
                                        "KPMG",
                                        "Deloitte",
                                        "Epic Games",
                                        "Goldman Sachs",
                                        "Splunk",
                                        "Intel",
                                        "McKinsey & Company",
                                        "Flipkart",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: This problem is fundamental to search algorithms within many software applications. One place you see search algorithms used frequently is in databases - when you query a database, the database software utilizes search algorithms to find the data you are looking for. Similarly, when you use a search engine like Google, the search engine is using algorithmic concepts similar to the one presented in this problem to find and sort the results.",
                                    "hints": [
                                        {
                                            "hint": "Start at the first element and compare it with the target. Continue until you find the target or reach the end of the array. Ensure to stop searching and return the index as soon as the target is found, as you are looking for the smallest index."
                                        },
                                        {
                                            "hint": " Remember to handle edge cases where the target is at the beginning or end of the array, or if it is not present at all."
                                        }
                                    ],
                                    "language": [
                                        "cpp",
                                        "java",
                                        "python",
                                        "javascript"
                                    ],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the target is not present, the function should return -1. This indicates that no index contains the target value. \nExample: Input: nums = [1, 2, 3, 4], target = 5 \nOutput: -1",
                                            "question": "What happens if the target is not found in the array? "
                                        },
                                        {
                                            "answer": "Linear search is not ideal for large datasets because of its  O(n) time complexity. For unsorted arrays, it's often the only choice. However, for sorted arrays, use binary search O(logn)) to improve efficiency. Alternatively, hash-based methods O(1) average case) can be used if the data structure supports it.",
                                            "question": "Is linear search suitable for very large arrays? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To return all indices: Traverse the array completely, even after finding the first occurrence. Use a list to store indices of all occurrences of the target. \nExample: Input: nums = [1, 2, 3, 2, 4], target = 2 \nOutput: [1, 3]",
                                            "question": "How would you modify the function to return all indices of the target instead of just the smallest? "
                                        },
                                        {
                                            "answer": "Linear search can be optimized for: If a specific target appears frequently, keep track of its last found index to start the search from there in subsequent searches. If the array is partially sorted or has a specific pattern, consider stopping early when certain conditions are met.",
                                            "question": "How can linear search be optimized for specific scenarios? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_fundamentals_largestelement",
                                "problem_name": "Largest Element",
                                "problem_slug": "largest-element",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Mastercard",
                                        "Unity Technologies",
                                        "Nutanix",
                                        "Electronic Arts",
                                        "Etsy",
                                        "Cloudflare",
                                        "Bain & Company",
                                        "Bloomberg",
                                        "Square",
                                        "Johnson & Johnson",
                                        "Seagate Technology",
                                        "Oracle",
                                        "Intel",
                                        "Docker",
                                        "Salesforce",
                                        "American Express",
                                        "Robinhood",
                                        "Epic Games",
                                        "Reddit",
                                        "IBM",
                                        "Lyft",
                                        "Boston Consulting Group",
                                        "McKinsey & Company",
                                        "Target",
                                        "Philips Healthcare",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This problem's foundational concept is frequently used in data analysis software and algorithms. For example, finding the largest or maximum value in a data set is commonly needed in statistical computations, such as when calculating the range (the difference between the highest and lowest values) or understanding the distribution of data. Furthermore, in real-time systems or applications like weather forecasting and stock market analysis, determining the highest value is crucial to predict potential peaks.",
                                    "hints": [
                                        {
                                            "hint": "Start by assuming the first element is the largest, then iterate through the array to compare each element with the current largest."
                                        },
                                        {
                                            "hint": "Use a single loop to traverse the array and update the largest element whenever a larger value is found."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The algorithm still works correctly. It will identify the first occurrence of the largest element, but since the value remains the same, it doesn't matter which occurrence is tracked. \nExample: Input: nums = [3, 5, 2, 5, 1] \nOutput: 5",
                                            "question": " How does the algorithm behave if there are multiple occurrences of the largest element?  "
                                        },
                                        {
                                            "answer": "The algorithm works the same way with negative numbers. It starts with the first element as the largest and updates it whenever a larger (less negative) number is found. \nExample: Input: nums = [-3, -1, -7, -2] \nOutput: -1",
                                            "question": "How does the algorithm handle arrays with all negative numbers? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Check if the array is empty at the beginning. If it is, return a specific value (e.g., None) or raise an error. \nExample: Input: nums = [] \nOutput: None or raise a \"ValueError: Array is empty\"",
                                            "question": "How would you handle an empty array or invalid input? "
                                        },
                                        {
                                            "answer": "Use a loop to track both the value and the index of the largest element. Update the index whenever the largest value is updated.  \nExample: Input: nums = [1, 3, 5, 2] \nOutput: (5, 2) (Value = 5, Index = 2)",
                                            "question": "How would you modify the algorithm to return both the largest element and its index?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_fundamentals_secondlargestelement",
                                "problem_name": "Second Largest Element",
                                "problem_slug": "second-largest-element",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Bloomberg",
                                        "Alibaba",
                                        "Epic Systems",
                                        "Seagate Technology",
                                        "HCL Technologies",
                                        "Lyft",
                                        "Unity Technologies",
                                        "Electronic Arts",
                                        "Visa",
                                        "Broadcom",
                                        "PwC",
                                        "JPMorgan Chase",
                                        "Databricks",
                                        "Ernst & Young",
                                        "Pinterest",
                                        "Red Hat",
                                        "Deloitte",
                                        "Reddit",
                                        "Stripe",
                                        "Intel",
                                        "HashiCorp",
                                        "Micron Technology",
                                        "Swiggy",
                                        "Texas Instruments",
                                        "Docker",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "The underlying concept of finding the second largest number in an array is a crucial part of recommendation algorithms utilized in e-commerce platforms and streaming services. In these systems, it is often required not only to find the most relevant choice (the largest element), but also the next best alternatives (the second largest, third largest, etc.) to provide users with a variety of options, hence improving user experience and engagement.",
                                    "hints": [
                                        {
                                            "hint": "Use two variables to track the largest and second-largest elements as you iterate through the array. Update the second-largest only if you find an element smaller than the largest but larger than the current second-largest."
                                        },
                                        {
                                            "hint": "Avoid sorting, as a single traversal O(n) is sufficient to find the second-largest element."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the array has fewer than two elements, there is no second-largest element. Return -1 to indicate this scenario. \nExample: Input: nums = [7] \nOutput: -1",
                                            "question": "What happens if the array has fewer than two elements? "
                                        },
                                        {
                                            "answer": "If all elements are identical, there is no second-largest distinct value. Return -1 in this case. \nExample: Input: nums = [4, 4, 4]\nOutput: -1",
                                            "question": "How does the algorithm handle arrays with identical elements? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For a stream of data (where elements arrive one at a time):  Maintain two variables, largest and second_largest, initialized to -.Update these variables dynamically as new elements arrive. \nExample: Stream: [2, 5, 1, 8, 3] \nProcess:  Start with largest = , second_largest = . \nAfter processing the stream: largest = 8, second_largest = 5.",
                                            "question": "How would you handle finding the second-largest element in a stream of data? "
                                        },
                                        {
                                            "answer": "Yes, a min-heap of size 2 can be used to maintain the two largest elements:  Insert the first two elements into the heap. For each new element, compare it with the smallest element in the heap. If it is larger, replace the smallest element. At the end, the heap will contain the two largest elements. \nExample: Input: nums = [3, 1, 4, 2] Heap after processing: [3, 4] \nOutput: 3 (second-largest element).",
                                            "question": "Can you solve this problem using a different approach, such as heap data structures? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_fundamentals_maximumconsecutiveones",
                                "problem_name": "Maximum Consecutive Ones",
                                "problem_slug": "maximum-consecutive-ones",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Byju's",
                                        "Oracle",
                                        "Mastercard",
                                        "Bain & Company",
                                        "Splunk",
                                        "HashiCorp",
                                        "Reddit",
                                        "Zynga",
                                        "Micron Technology",
                                        "OYO Rooms",
                                        "Roche",
                                        "Activision Blizzard",
                                        "Uber",
                                        "Ernst & Young",
                                        "Nutanix",
                                        "ARM",
                                        "American Express",
                                        "Morgan Stanley",
                                        "Philips Healthcare",
                                        "JPMorgan Chase",
                                        "Pinterest",
                                        "Swiggy",
                                        "Optum",
                                        "Stripe",
                                        "Wayfair",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "Amazon"
                                    ],
                                    "facts": "A fun and practical application of this problem exists in data compression techniques, used in various aspects of software development. In particular, a variant of this problem is employed in Run-Length Encoding (RLE) that is a simple form of data compression where runs of data are stored as a single data value and count. It counts the occurrences of consecutive 1s (or 0s), which is similar to the given problem. RLE is used in graphics files formats including BMP, TIFF, and in certain PDF compression schemes.",
                                    "hints": [
                                        {
                                            "hint": "Traverse the array while keeping a running count of consecutive 1s. Reset the count to 0 whenever a 0 is encountered."
                                        },
                                        {
                                            "hint": "Maintain a variable to track the maximum count of consecutive 1s observed during traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The time complexity of the solution is  O(n), where n is the length of the array. This is optimal as each element must be inspected at least once to determine the number of consecutive 1s. It cannot be optimized further without additional assumptions about the input.",
                                            "question": "What is the time complexity, and can it be optimized further? "
                                        },
                                        {
                                            "answer": "The algorithm correctly identifies the length of each segment of consecutive 1s and tracks the maximum. Alternating 1s and 0s do not affect the algorithm's correctness.",
                                            "question": " How does the algorithm handle arrays with alternating 1s and 0s? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track the starting index of each segment of consecutive 1s. Update the start and end indices whenever a new maximum is found. \nExample: Input: nums = [1, 1, 0, 1, 1, 1, 0] \nOutput: Indices (3, 5)",
                                            "question": "How would you modify the algorithm to return the indices of the maximum segment of consecutive 1s? "
                                        },
                                        {
                                            "answer": "For streaming data, maintain a running count of consecutive 1s and update the maximum whenever a 0 is encountered. Use a single variable to track the current count. Update the maximum count dynamically without storing the full array. \nExample: Stream: [1, 1, 0, 1, 1, 1, 0] \nOutput after processing: 3",
                                            "question": "How would you handle a streaming input (data arriving one bit at a time)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_fundamentals_leftrotatearraybyone",
                                "problem_name": "Left Rotate Array by One",
                                "problem_slug": "left-rotate-array-by-one",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Walmart",
                                        "MongoDB",
                                        "Roche",
                                        "Roblox",
                                        "Seagate Technology",
                                        "Bungie",
                                        "Goldman Sachs",
                                        "Deloitte",
                                        "OYO Rooms",
                                        "Byju's",
                                        "Rakuten",
                                        "Visa",
                                        "Texas Instruments",
                                        "Etsy",
                                        "HCL Technologies",
                                        "Epic Systems",
                                        "NVIDIA",
                                        "Reddit",
                                        "DoorDash",
                                        "Teladoc Health",
                                        "PayPal",
                                        "Red Hat",
                                        "Zoho",
                                        "Robinhood",
                                        "Micron Technology",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Focus on moving the first element of the array to the end while shifting all other elements one position to the left."
                                        },
                                        {
                                            "hint": "Think about how swapping or overwriting elements can achieve the desired rotation within the same array."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, the logic applies to arrays of any type. For complex objects, ensure that only references are moved and no deep copying is unintentionally triggered.",
                                            "question": "Can this logic handle nested arrays or complex objects?"
                                        },
                                        {
                                            "answer": "Validation involves testing:\n- Empty arrays: Output should remain empty.\n- Single-element arrays: Output should remain unchanged.\n- Arrays with duplicates: Check that all duplicates are correctly preserved and shifted.\n- Arrays with mixed values: Ensure the logic handles all types of elements consistently.",
                                            "question": "How can you validate correctness across various test cases?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "\nFor multidimensional arrays (e.g., matrices), rotation involves more complex transformations:\n- Left Rotation: Shifting rows or columns depending on the axis of rotation.\n- Right Rotation: Similar logic but reversed.",
                                            "question": "How would the algorithm handle multidimensional arrays?"
                                        },
                                        {
                                            "answer": "\n- In-Place Rotation: Rearranges elements directly in the original array without using additional memory. It is more space-efficient but often requires more careful handling of indices.\n- Using Extra Space: Creates a temporary array to hold shifted elements, simplifying the process but increasing memory usage.",
                                            "question": " What is the difference between in-place rotation and using extra space?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_fundamentals_leftrotatearray",
                                "problem_name": "Left Rotate Array by K Places",
                                "problem_slug": "left-rotate-array",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Docker",
                                        "Byju's",
                                        "Twilio",
                                        "Johnson & Johnson",
                                        "JPMorgan Chase",
                                        "Visa",
                                        "Shopify",
                                        "HashiCorp",
                                        "Flipkart",
                                        "Siemens Healthineers",
                                        "Teladoc Health",
                                        "Cerner",
                                        "Western Digital",
                                        "KPMG",
                                        "Goldman Sachs",
                                        "AMD",
                                        "Ubisoft",
                                        "McKinsey & Company",
                                        "Mastercard",
                                        "Oracle",
                                        "Robinhood",
                                        "Cloudflare",
                                        "Optum",
                                        "Roche",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Rotating an array by 'k' steps is a frequently used operation in digital signal processing, particularly in operations such as circular convolution and in implementing algorithms like FFT (Fast Fourier Transform). This concept finds applications in many areas including data compression tools, image processing software, and audio signal processing tools. It is the fundamental operation that allows you to shift frames, process signals and handle buffers -- which is critical, for instance, when streaming video or audio.",
                                    "hints": [
                                        {
                                            "hint": "Split the array into two parts at index k: the first k elements and the rest. Then rearrange the two parts to place the second part before the first part."
                                        },
                                        {
                                            "hint": "Think about how you can achieve the rotation by reversing parts of the array rather than using extra space."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "\nWhen k  nums.length, the rotation repeats unnecessarily. \nTo simplify:\nReduce k to k % nums.length.\nThis ensures that the rotation is performed only as much as necessary.\nExample:\nInput: nums = [1, 2, 3], \nk=4\nEffective k=4%3=1. Output: [2, 3, 1].",
                                            "question": "What if k is greater than or equal to the array length?"
                                        },
                                        {
                                            "answer": "Instead of creating a new array:\n- Reverse the entire array.\n- Reverse the first nk elements (left part).\n- Reverse the last k elements (right part).\n- This method achieves the same result in O(1) extra space.",
                                            "question": "How can this be done in-place?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, but for 2D arrays (e.g., matrices), rotation involves more complex transformations:\n- For left rotation, each row/column is treated as a separate 1D array and rotated individually.\n- For k>1, the process must account for overlapping boundaries in 2D structures.",
                                            "question": "Can this logic be extended to multidimensional arrays?"
                                        },
                                        {
                                            "answer": "Rotation shifts elements in a structured, cyclic order, preserving their relative positions. Shuffling, on the other hand, rearranges elements randomly without preserving order. Rotation is deterministic, whereas shuffling introduces randomness.",
                                            "question": "Whats the difference between rotation by k and shuffling?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "arrays_logicbuilding",
                        "subcategory_name": "Logic Building",
                        "subcategory_slug": "logic-building",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "arrays_arrays_logicbuilding_movezerostoend",
                                "problem_name": "Move Zeros to End",
                                "problem_slug": "move-zeros-to-end",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Roblox",
                                        "Flipkart",
                                        "Ubisoft",
                                        "Boston Consulting Group",
                                        "Medtronic",
                                        "Seagate Technology",
                                        "AMD",
                                        "Bain & Company",
                                        "Target",
                                        "Dropbox",
                                        "DoorDash",
                                        "KPMG",
                                        "HCL Technologies",
                                        "Snowflake",
                                        "PayPal",
                                        "Docker",
                                        "Rockstar Games",
                                        "IBM",
                                        "Pinterest",
                                        "Salesforce",
                                        "HashiCorp",
                                        "Twilio",
                                        "Intel",
                                        "Zoho",
                                        "Byju's",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "Amazon"
                                    ],
                                    "facts": "This problem and its underlying concept are commonly applied in memory management within computation. An everyday example could be when a streaming service needs to manage its content list. When a user finishes watching a TV show, it could be marked as '0' and sent to the 'end of the list', making way for new or unwatched content. So, this programming problem is like creating an algorithm to keep the recommendation engine engaging by bringing fresh content to the front while pushing consumed or less important items to the back.",
                                    "hints": [
                                        {
                                            "hint": "Use two pointers to iterate through the array. One pointer keeps track of the current position, and the other identifies where the next non-zero element should go."
                                        },
                                        {
                                            "hint": "Focus on swapping non-zero elements to the front while keeping track of the current index for placing zeros at the end. Avoid creating a new array by modifying the original array directly. Shift non-zero elements left and fill zeros at the end."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By iterating through the array from left to right and moving each non-zero element to the next available position, the algorithm maintains the original order of non-zero elements. Zeros are simply moved to the end without disrupting this sequence.\n\n",
                                            "question": "What ensures the relative order of non-zero elements is preserved?"
                                        },
                                        {
                                            "answer": "For multi-dimensional arrays, apply the same principle to each row or column independently. The complexity increases due to additional dimensions, requiring nested loops or recursive logic to process all elements",
                                            "question": "Can this logic be generalized for multi-dimensional arrays?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To move zeros to the beginning:\n- Iterate through the array from right to left.\n- Shift non-zero elements to the rightmost available position, and place zeros at the beginning.\n- This maintains the relative order of non-zero elements.",
                                            "question": "How would you modify the algorithm to move all zeros to the beginning instead?"
                                        },
                                        {
                                            "answer": "Instead of checking for zeros, modify the condition to identify negative numbers. Use the same two-pointer approach to shift non-negative numbers to the front while maintaining their order.",
                                            "question": "How can you adapt this algorithm for other conditions, like moving all negative numbers to the end?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_logicbuilding_removeduplicatesfromsortedarray",
                                "problem_name": "Remove duplicates from sorted array",
                                "problem_slug": "remove-duplicates-from-sorted-array",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Unity Technologies",
                                        "Byju's",
                                        "Electronic Arts",
                                        "JPMorgan Chase",
                                        "Reddit",
                                        "Roche",
                                        "Freshworks",
                                        "Walmart",
                                        "Mastercard",
                                        "Medtronic",
                                        "Shopify",
                                        "Rakuten",
                                        "Swiggy",
                                        "Seagate Technology",
                                        "Docker",
                                        "Philips Healthcare",
                                        "Cerner",
                                        "Twilio",
                                        "Zomato",
                                        "PayPal",
                                        "NVIDIA",
                                        "Zynga",
                                        "Uber",
                                        "Red Hat",
                                        "Qualcomm",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The concept of removing duplicates from an array, as illustrated in the programming problem, is commonly applied in the real world software industry. One well-known example is in database management systems. If we consider a database as an array where each row corresponds to an array element, removing duplicates is equivalent to the SQL operation \"SELECT DISTINCT\", which is frequently used to obtain a list of unique records. Furthermore, this operation is often implemented in Javascript-based web development for data manipulation in various web apps to ensure data integrity and avoid redundancy.",
                                    "hints": [
                                        {
                                            "hint": "Since the array is sorted, duplicates will always be consecutive. Compare adjacent elements to identify duplicates and move unique elements forward."
                                        },
                                        {
                                            "hint": "Keep a counter to track the number of unique elements as you traverse the array."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The problem specifies that the elements after the first k unique values (where k is the number of unique elements) are irrelevant. They do not need to be in any particular order or have specific values, as only the first k elements are considered part of the result.",
                                            "question": "What happens to the remaining elements after placing the unique elements?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the array was unsorted, the sorted property could not be used to identify duplicates in one pass. Instead:\nSort the array first (O(nlogn)), then apply the two-pointer technique.\nAlternatively, use a hash set to track seen elements, but this would require O(n) extra space.",
                                            "question": "How would the solution change if the array was not sorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_logicbuilding_findmissingnumber",
                                "problem_name": "Find missing number",
                                "problem_slug": "find-missing-number",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "HCL Technologies",
                                        "ARM",
                                        "Rockstar Games",
                                        "Roblox",
                                        "PayPal",
                                        "Robinhood",
                                        "Snowflake",
                                        "Philips Healthcare",
                                        "Mastercard",
                                        "Byju's",
                                        "HashiCorp",
                                        "Deloitte",
                                        "NVIDIA",
                                        "Texas Instruments",
                                        "GE Healthcare",
                                        "Freshworks",
                                        "IBM",
                                        "Lyft",
                                        "Wayfair",
                                        "Bloomberg",
                                        "Teladoc Health",
                                        "Chewy",
                                        "Shopify",
                                        "Salesforce",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The problem concept of identifying missing elements in a sequence is commonly used in the software industry for a variety of purposes. For instance, its integral in database management where checking for missing IDs or sequence gaps is crucial. The concept is also highly relevant in network programming, specifically in TCP (Transmission Control Protocol) where packet sequence numbers are maintained. Identifying missing sequence numbers helps in detecting packet loss during data transmission.",
                                    "hints": [
                                        {
                                            "hint": "\"Use the formula for the sum of the first n natural numbers:  S= (n(n+1))/2. Subtract the sum of the array elements from  S to find the missing number.\""
                                        },
                                        {
                                            "hint": "Leverage the XOR property: xx=0 and x0=x. XOR all indices and array values; the missing number will be the result."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The sum formula is faster (O(n)) compared to iterative checks (O(n2)) because the sum formula requires only a single pass to compute the sum of array elements and one subtraction. Iterative checks require comparing each number in the range to the array, which is inefficient.",
                                            "question": "Why use the sum formula instead of iterative checks?"
                                        },
                                        {
                                            "answer": "If 0 is missing, the sum formula still works because S includes 0 by definition.\nIf n is missing, the sum formula accounts for n since it calculates the sum of the entire range, and subtracting the array sum leaves n",
                                            "question": "What happens if the missing number is 0 or n?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "\nIf duplicates are allowed:\nUse a hash set to track numbers present in the array.\nIterate through 0 to n, checking if each number exists in the set.\nThis approach requires O(n) time and O(n) space.",
                                            "question": "How would you handle the problem if duplicates are allowed in the array?"
                                        },
                                        {
                                            "answer": "Both methods have O(n) time complexity and O(1) space complexity.\nThe sum formula involves addition and subtraction, while the XOR method uses bitwise operations. XOR is slightly faster in practice due to the lower computational cost of bitwise operations.",
                                            "question": "How does the performance compare between the sum formula and XOR methods?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_logicbuilding_unionoftwosortedarrays",
                                "problem_name": "Union of two sorted arrays",
                                "problem_slug": "union-of-two-sorted-arrays",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Lyft",
                                        "Riot Games",
                                        "Swiggy",
                                        "Johnson & Johnson",
                                        "Salesforce",
                                        "Byju's",
                                        "Chewy",
                                        "GE Healthcare",
                                        "Pinterest",
                                        "Morgan Stanley",
                                        "Databricks",
                                        "Micron Technology",
                                        "Freshworks",
                                        "Activision Blizzard",
                                        "Qualcomm",
                                        "eBay",
                                        "KPMG",
                                        "Medtronic",
                                        "Airbnb",
                                        "Walmart",
                                        "Zynga",
                                        "Shopify",
                                        "Boston Consulting Group",
                                        "HashiCorp",
                                        "Stripe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This type of problem is often used in database management systems and search engines for combining and analyzing large data sets. Particularly, it serves as the underlying concept for SQL's UNION operation which helps in merging data from two SQL tables while removing duplicates. Additionally, search engine algorithms use similar concepts to combine search results from various sources into one single, sorted and non-repetitive result set.",
                                    "hints": [
                                        {
                                            "hint": "Utilize two pointers to traverse the sorted arrays simultaneously. This helps efficiently handle duplicates and maintain ascending order."
                                        },
                                        {
                                            "hint": "Since both arrays are sorted, you can skip elements that are equal to the last added element in the union array."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Merging ensures that elements from both arrays are included in the result in sorted order. Deduplication ensures that repeated elements (either within a single array or across both arrays) appear only once in the final result.",
                                            "question": "Why do we need both merging and deduplication?"
                                        },
                                        {
                                            "answer": "For very large arrays:\nIf they fit in memory, use the two-pointer approach to merge them efficiently.\nIf they dont fit in memory, use external sorting techniques or divide the arrays into manageable chunks, process each chunk separately, and merge the results.",
                                            "question": "What if the arrays are very large?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the input arrays are unsorted:\nSort each array first O(mlogm) and O(nlogn)).\nApply the two-pointer approach or merge logic.\nThis approach would have an overall time complexity of O(mlogm+nlogn+m+n).",
                                            "question": "How would you handle unsorted input arrays?"
                                        },
                                        {
                                            "answer": "To handle k sorted arrays:\nUse a min-heap to merge the arrays.\nPush the smallest element of each array into the heap.\nExtract the minimum element, add it to the result, and push the next element from the same array into the heap.\nThis has a time complexity of O(Nlogk), where N is the total number of elements.",
                                            "question": "How would you extend this to handle k sorted arrays?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_logicbuilding_intersectionoftwosortedarrays",
                                "problem_name": "Intersection of two sorted arrays",
                                "problem_slug": "intersection-of-two-sorted-arrays",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Zoho",
                                        "Ernst & Young",
                                        "Stripe",
                                        "Dropbox",
                                        "Johnson & Johnson",
                                        "Bungie",
                                        "Walmart",
                                        "Siemens Healthineers",
                                        "Goldman Sachs",
                                        "Byju's",
                                        "Morgan Stanley",
                                        "Zynga",
                                        "Bloomberg",
                                        "GE Healthcare",
                                        "Reddit",
                                        "Cloudflare",
                                        "AMD",
                                        "Airbnb",
                                        "Swiggy",
                                        "Deloitte",
                                        "Seagate Technology",
                                        "Cerner",
                                        "Texas Instruments",
                                        "Snowflake",
                                        "Boston Consulting Group",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "The concept behind this problem is extremely important in database operations, specifically in the SQL operations like JOINs. For example, an 'inner join' in SQL is essentially finding the intersection of two tables based on some common column. This operation is used extensively in software development where handling of databases is involved. This could include anything, from apps that need to pull up personalized user data, to large-scale data analysis and processing frameworks.",
                                    "hints": [
                                        {
                                            "hint": " Use two pointers to traverse both arrays simultaneously. This helps efficiently find common elements since both arrays are sorted.Add an element to the intersection only if it is present in both arrays at the same index of the pointers."
                                        },
                                        {
                                            "hint": " If duplicates are not allowed in the result, skip consecutive duplicate elements in either array during traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If either array is empty, the intersection is empty since there are no common elements.",
                                            "question": "What happens if one or both arrays are empty?"
                                        },
                                        {
                                            "answer": "\nIf duplicates are allowed in the intersection:\nInclude the common element as many times as it appears in both arrays.\nIf duplicates are not allowed:\nSkip consecutive duplicates in both arrays while processing.",
                                            "question": "How does the algorithm handle duplicates within the arrays?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For unsorted arrays:\nSort both arrays first O(mlogm+nlogn).\nApply the two-pointer technique to find the intersection.",
                                            "question": "How would you handle unsorted arrays?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "arrays_faqs(medium)",
                        "subcategory_name": "FAQs (Medium)",
                        "subcategory_slug": "faqs-medium",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_leadersinanarray",
                                "problem_name": "Leaders in an Array",
                                "problem_slug": "leaders-in-an-array",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "Dropbox",
                                        "Riot Games",
                                        "Mastercard",
                                        "ARM",
                                        "Deloitte",
                                        "Cloudflare",
                                        "Ernst & Young",
                                        "Lyft",
                                        "Rockstar Games",
                                        "Cerner",
                                        "Roche",
                                        "Philips Healthcare",
                                        "Nutanix",
                                        "Instacart",
                                        "Rakuten",
                                        "Visa",
                                        "HashiCorp",
                                        "Qualcomm",
                                        "Bungie",
                                        "JPMorgan Chase",
                                        "Target",
                                        "Unity Technologies",
                                        "McKinsey & Company",
                                        "GE Healthcare",
                                        "Broadcom",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "Amazon",
                                        "Google"
                                    ],
                                    "facts": "One interesting real-world usage of this problem is in financial software or stock market analysis tools, where it is used to find \"leaders\" or stocks that outperform all others that come after them in a given period. The concept of finding leaders in an array can be analogous to finding peak points in a financial graph, helping traders and investors make informed decisions. This is one example of how seemingly theoretical programming problems can be used in a practical business context.",
                                    "hints": [
                                        {
                                            "hint": "Traverse the array from right to left, as the rightmost element is always a leader and gives a starting point for comparison. Maintain a variable to keep track of the maximum value encountered so far during the traversal. An element is a leader if it is greater than this maximum."
                                        },
                                        {
                                            "hint": "As you identify leaders while traversing from right to left, add them to a temporary list and reverse it at the end to preserve the original order."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Traversing from right to left ensures that the current maximum is always the leader for the elements processed so far. This avoids revisiting elements multiple times and allows a single-pass O(n) solution.",
                                            "question": "Why traverse the array from right to left?"
                                        },
                                        {
                                            "answer": "By adding leaders to a temporary list during right-to-left traversal and reversing the list at the end, the leaders are presented in the same order as they appear in the original array.\n",
                                            "question": "How does the algorithm ensure the leaders appear in the correct order?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The presence of duplicate elements does not change the logic. The algorithm still traverses from right to left and checks if the current element is greater than the maximum seen so far. Only elements that strictly satisfy this condition are added to the leader list.",
                                            "question": "How would you handle an unsorted list with duplicate elements?"
                                        },
                                        {
                                            "answer": "For a circular array, you would need to iterate over the array twice (once normally and once wrapping around). Adjust the comparison logic to handle the circular property, ensuring no duplicates are considered as leaders.",
                                            "question": "What if the array is circular?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_rearrangearrayelementsbysign",
                                "problem_name": "Rearrange array elements by sign",
                                "problem_slug": "rearrange-array-elements-by-sign",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Micron Technology",
                                        "Etsy",
                                        "Intel",
                                        "Swiggy",
                                        "ARM",
                                        "Reddit",
                                        "Cerner",
                                        "Splunk",
                                        "Bungie",
                                        "Pinterest",
                                        "Optum",
                                        "Roche",
                                        "Square",
                                        "Lyft",
                                        "Rakuten",
                                        "GE Healthcare",
                                        "Wayfair",
                                        "OYO Rooms",
                                        "Bloomberg",
                                        "Activision Blizzard",
                                        "Ernst & Young",
                                        "Johnson & Johnson",
                                        "Deloitte",
                                        "Red Hat",
                                        "IBM",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro",
                                        "Amazon"
                                    ],
                                    "facts": "One practical application of this problem can be found in the financial software industry, specifically in the domain of portfolio management. There, the sequence and proportion of positive (profit) and negative (loss) financial transactions is crucial. Algorithms similar to this problem can be used to analyze transaction data, where consecutive transactions follow a pattern of gain and loss, helping a financial analyst to understand and predict the market dynamics.",
                                    "hints": [
                                        {
                                            "hint": "Extract positive and negative integers into two separate arrays while preserving their relative order. Iterate through the positive and negative arrays simultaneously, alternately adding elements from each to the result array."
                                        },
                                        {
                                            "hint": "Use two indices to track the position in the positive and negative arrays during merging."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The algorithm processes positives and negatives in the order they appear in the original array by iterating over the separated positive and negative arrays without modifying their relative order.",
                                            "question": "How does the algorithm ensure the order of positives and negatives is preserved?"
                                        },
                                        {
                                            "answer": "The algorithm treats duplicate integers the same as other integers, preserving their order during separation and merging. Duplicates do not affect the correctness of the alternation.",
                                            "question": "How does the algorithm handle edge cases like duplicates?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the counts are uneven:\nFill the result array with as many alternating pairs as possible.\nAppend the remaining elements (all positives or all negatives) to the end of the result array while preserving their order.",
                                            "question": "How would you modify the algorithm to handle uneven counts of positives and negatives?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_printthematrixinspiralmanner",
                                "problem_name": "Print the matrix in spiral manner",
                                "problem_slug": "print-the-matrix-in-spiral-manner",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "Reddit",
                                        "Twilio",
                                        "Square",
                                        "Nutanix",
                                        "Flipkart",
                                        "Target",
                                        "AMD",
                                        "American Express",
                                        "Alibaba",
                                        "Unity Technologies",
                                        "Activision Blizzard",
                                        "Bain & Company",
                                        "Medtronic",
                                        "Goldman Sachs",
                                        "Splunk",
                                        "Bloomberg",
                                        "Dropbox",
                                        "PwC",
                                        "Philips Healthcare",
                                        "Oracle",
                                        "Ubisoft",
                                        "Uber",
                                        "JPMorgan Chase",
                                        "IBM",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This programming problem is integral in the development of Medical Imaging technologies and apps using MRI or CT scans. These health-tech applications often include features that allow medical professionals to view and analyze 3D scans in a series of 2D slices, which basically requires handling 3D matrices. The traversal of these 2D slices in a specific orderly pattern, such as the spiral manner described in this problem, allows for efficient and thorough analysis of the images.",
                                    "hints": [
                                        {
                                            "hint": "Treat the matrix as a collection of concentric rectangular layers. Traverse each layer in four steps: top row (left to right), right column (top to bottom), bottom row (right to left), and left column (bottom to top)."
                                        },
                                        {
                                            "hint": "Maintain four boundaries (top, bottom, left, right) to keep track of the limits of the matrix as you spiral inward."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "After traversing a boundary, adjust it inward:\nIncrement top after traversing the top row.\nDecrement right after traversing the right column.\nDecrement bottom after traversing the bottom row.\nIncrement left after traversing the left column.",
                                            "question": "How does the algorithm avoid revisiting elements?"
                                        },
                                        {
                                            "answer": "In an odd-dimensional square matrix, the center element is visited during the last iteration. No special handling is needed as the shrinking boundaries naturally include it in the traversal.",
                                            "question": "How do I handle the center element in an odd-dimensional matrix?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For sparse matrices:\nUse a coordinate-based approach to track only non-zero elements.\nPerform the traversal using the coordinates of active elements instead of iterating through every cell.",
                                            "question": "How would you handle a sparse matrix?"
                                        },
                                        {
                                            "answer": "To traverse counterclockwise:Start with the left column (top to bottom).\nTraverse the bottom row (right to left).\nTraverse the right column (bottom to top).\nTraverse the top row (left to right).",
                                            "question": "How would you modify the algorithm for counterclockwise spiral traversal?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "pascal's_triangle_iii",
                                "problem_name": "Pascal's Triangle I",
                                "problem_slug": "pascals-triangle-i",
                                "problem_rank": 3,
                                "misc": null,
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "pascal's_triangle_ii",
                                "problem_name": "Pascal's Triangle II",
                                "problem_slug": "pascals-triangle-ii",
                                "problem_rank": 4,
                                "misc": null,
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_pascal'striangle",
                                "problem_name": "Pascal's Triangle III",
                                "problem_slug": "pascals-triangle-iii",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Cloudflare",
                                        "Dropbox",
                                        "Deloitte",
                                        "Docker",
                                        "Instacart",
                                        "Wayfair",
                                        "Swiggy",
                                        "Stripe",
                                        "Splunk",
                                        "Salesforce",
                                        "NVIDIA",
                                        "Zomato",
                                        "Teladoc Health",
                                        "Unity Technologies",
                                        "Nutanix",
                                        "Micron Technology",
                                        "Freshworks",
                                        "Activision Blizzard",
                                        "Philips Healthcare",
                                        "Flipkart",
                                        "Zoho",
                                        "Alibaba",
                                        "HCL Technologies",
                                        "Bungie",
                                        "Lyft",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Pascal's Triangle isn't just a fun programming problem, it's quite practical too! The triangle is used in mathematics and computing to calculate coefficients for polynomial expansion, which is useful in several algorithmic computations. For example, the routing algorithms used in networking, and more specifically in the widely used OSPF (Open Shortest Path First) routing protocol, utilize the concept of Pascal's Triangle. Beyond networking, formulas derived from Pascal's Triangle are used in algorithmic design, statistical analysis, and in creating curved graphical elements in computer graphics. It's pretty cool how this triangular array has such an impactful real-world application!",
                                    "hints": [
                                        {
                                            "hint": "Each element in a row (except the first and last) is the sum of the two elements directly above it from the previous row. This recursive relationship can be used to compute Pascal's triangle row by row."
                                        },
                                        {
                                            "hint": "For each row, initialize the first and last elements as 1. Compute the middle elements using values from the previous row."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Each middle element is the sum of the two elements directly above it in the triangle.\nIf the previous row is prevRow, then currRow[i] = prevRow[i - 1] + prevRow[i].",
                                            "question": "How do we calculate elements in the middle of a row?"
                                        },
                                        {
                                            "answer": "The sum of elements along the diagonals of Pascal's triangle gives Fibonacci numbers.",
                                            "question": "How can Pascal's triangle be used to compute Fibonacci numbers?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To compute the value at row r and column c (0-based indexing), use the combination formula:\nC(r,c)= r!/(c!(rc)!)\n\n",
                                            "question": "How would you compute a specific element in Pascals triangle without generating the entire triangle?"
                                        },
                                        {
                                            "answer": "The n-th row of Pascal's triangle represents the coefficients of the terms in the expansion of (a+b)^n.",
                                            "question": "How can Pascal's triangle be used in binomial expansion?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_rotatematrixby90degrees",
                                "problem_name": "Rotate matrix by 90 degrees",
                                "problem_slug": "rotate-matrix-by-90-degrees",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Epic Games",
                                        "Freshworks",
                                        "Bungie",
                                        "Robinhood",
                                        "Boston Consulting Group",
                                        "OYO Rooms",
                                        "Philips Healthcare",
                                        "Ernst & Young",
                                        "Visa",
                                        "Lyft",
                                        "Texas Instruments",
                                        "McKinsey & Company",
                                        "Chewy",
                                        "DoorDash",
                                        "Goldman Sachs",
                                        "Pinterest",
                                        "Wayfair",
                                        "Roblox",
                                        "Ubisoft",
                                        "Splunk",
                                        "Target",
                                        "Swiggy",
                                        "American Express",
                                        "Intel",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "One interesting application of this problem can be found in image processing. Many image-editing software or applications use rotation algorithms similar to this to adjust or manipulate images. For instance, when you rotate an image 90 degrees clockwise on your smartphone or computer, programs effectively apply a similar method in the background.",
                                    "hints": [
                                        {
                                            "hint": "Swap elements such that matrix[i][j] becomes matrix[j][i]. Reverse the order of elements in each row to complete the rotation."
                                        },
                                        {
                                            "hint": "Alternatively, rotate the matrix in layers, starting from the outermost layer and moving inward. For each layer, shift elements in groups of four."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The given problem assumes a square NN matrix. For non-square matrices, a 90-degree rotation would not be in place, as the dimensions change. Handling non-square matrices requires creating a new matrix to store the result.",
                                            "question": "How does the algorithm handle non-square matrices?"
                                        },
                                        {
                                            "answer": "Transposing: Converts rows into columns (flipping the matrix across its diagonal).\nReversing Each Row: Aligns the transposed columns to their new positions after rotation.",
                                            "question": " Why does transposing and reversing achieve a 90-degree rotation?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For k rotations of 90 degrees:\nReduce \nk modulo 4 (k%4) to minimize redundant rotations.\nPerform the k rotations iteratively using the 90-degree rotation logic.",
                                            "question": "How would you generalize this for multiple rotations?"
                                        },
                                        {
                                            "answer": "For sparse matrices:\nUse a coordinate-based representation (e.g., a dictionary of non-zero values).\nTransform the coordinates for the rotation rather than manipulating the entire matrix.\nThis reduces both time and space complexity for large sparse matrices.",
                                            "question": " What if the matrix is sparse?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_twosum",
                                "problem_name": "Two Sum",
                                "problem_slug": "two-sum",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Freshworks",
                                        "JPMorgan Chase",
                                        "Goldman Sachs",
                                        "Twilio",
                                        "Splunk",
                                        "Micron Technology",
                                        "Chewy",
                                        "Flipkart",
                                        "McKinsey & Company",
                                        "GE Healthcare",
                                        "Qualcomm",
                                        "Robinhood",
                                        "Zomato",
                                        "Alibaba",
                                        "Walmart",
                                        "Lyft",
                                        "MongoDB",
                                        "Electronic Arts",
                                        "Square",
                                        "Rakuten",
                                        "Activision Blizzard",
                                        "Morgan Stanley",
                                        "PayPal",
                                        "Riot Games",
                                        "Epic Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is known as the Two Sum problem and it plays an integral role in various aspects of software development. It is a common interview question used to gauge a candidates analytical and problem-solving skills. Moreover, its underlying concept, the utilization of data structures such as arrays and hash maps to optimize processing time, has many practical implementations. For instance, the Two Sum problem appears within e-commerce platforms where it helps in matching <strong>price pairs</strong> for combined products to a given target price. The faster and more efficient your algorithm, the better the customer experience in terms of performance.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash map (dictionary) to store the indices of elements as you iterate through the array. This allows for efficient lookups of the complement (i.e., targetcurrentelement)."
                                        },
                                        {
                                            "hint": "Alternatively, use two pointers, one starts at the beginning (smallest element) and the other at the end (largest element) of the sorted array.If the sum of the elements at the two pointers is less than the target, move the left pointer to the right. If the sum is greater than the target, move the right pointer to the left."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In a sorted array:\nIncreasing the left pointer increases the sum.\nDecreasing the right pointer decreases the sum.",
                                            "question": "Why does the two-pointer technique work only on sorted arrays?"
                                        },
                                        {
                                            "answer": "If the pointers cross (i.e., the left pointer exceeds the right pointer) without finding a match, it means no two numbers in the array sum to the target. In this case, the algorithm returns an empty result or an appropriate error message.",
                                            "question": " What if there are no valid pairs?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If multiple solutions are allowed:\nContinue moving the pointers inward even after finding a valid pair.\nStore all valid pairs in a result list.",
                                            "question": "How would you handle multiple solutions?"
                                        },
                                        {
                                            "answer": "While sorting, store the original indices as tuples (e.g., [(value, index)]). Use the sorted array to find the solution, and then map the indices back to their original positions.",
                                            "question": "How would you return the original indices after sorting?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_3sum",
                                "problem_name": "3 Sum",
                                "problem_slug": "3-sum",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Teladoc Health",
                                        "Oracle",
                                        "DoorDash",
                                        "Nutanix",
                                        "Epic Games",
                                        "ARM",
                                        "Wayfair",
                                        "Robinhood",
                                        "Cloudflare",
                                        "Mastercard",
                                        "Optum",
                                        "Stripe",
                                        "Goldman Sachs",
                                        "Bain & Company",
                                        "Visa",
                                        "Deloitte",
                                        "MongoDB",
                                        "Airbnb",
                                        "Rakuten",
                                        "KPMG",
                                        "AMD",
                                        "Johnson & Johnson",
                                        "Byju's",
                                        "Flipkart",
                                        "NVIDIA",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept underlying this problem is commonly used in data analysis and machine learning. For instance, it can be used to identify clusters or groups (triplets in this case) in larger datasets to which certain constraints apply such as their sum equaling zero. In finance, it can be used to identify combinations of transactions or investments that counterbalance each other, resulting in a net effect of zero. It's an interesting application of array traversal, hash-map utilization, and the two-pointer technique in real-world scenarios.",
                                    "hints": [
                                        {
                                            "hint": "Begin by sorting the input array to simplify the process of finding triplets and managing duplicates. Sorting ensures that duplicates are adjacent and allows the use of a two-pointer technique."
                                        },
                                        {
                                            "hint": "Iterate through the array, fixing one element at a time. For each fixed element, look for a pair of numbers in the remaining array that sum to the negative of the fixed element. Use two pointers, one starting from the next element after the fixed element and the other from the end of the array."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Skip duplicate values of nums[i] while iterating.\nSkip duplicate values of nums[left] and nums[right] during the two-pointer traversal.",
                                            "question": "How do we avoid duplicate triplets?"
                                        },
                                        {
                                            "answer": "Sorting allows:\nEfficient identification of duplicates by comparing adjacent elements.\nSimplification of the two-pointer logic, as the relationship between pointer movements and the sum becomes predictable.",
                                            "question": "Why sort the array?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Sorting is part of the solution and is necessary for efficient implementation. It adds O(nlogn) complexity, which is negligible compared to the O(n2) time required for finding triplets.",
                                            "question": " What if the input array is unsorted?"
                                        },
                                        {
                                            "answer": "Instead of finding triplets that sum to 0:\nLook for triplets that sum to a given target t.\nUse the same two-pointer approach, with nums[left]+nums[right]=tnums[i].",
                                            "question": "How would you modify the algorithm to find all unique triplets with a sum equal to a different target?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_4sum",
                                "problem_name": "4 Sum",
                                "problem_slug": "4-sum",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Etsy",
                                        "Deloitte",
                                        "Uber",
                                        "Unity Technologies",
                                        "AMD",
                                        "Wayfair",
                                        "Rockstar Games",
                                        "Zomato",
                                        "Swiggy",
                                        "Chewy",
                                        "Bain & Company",
                                        "Splunk",
                                        "GE Healthcare",
                                        "Western Digital",
                                        "Lyft",
                                        "Micron Technology",
                                        "Teladoc Health",
                                        "McKinsey & Company",
                                        "Square",
                                        "Riot Games",
                                        "Instacart",
                                        "JPMorgan Chase",
                                        "Pinterest",
                                        "Target",
                                        "Twilio",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Finding all unique quadruplets in an integer array that add up to a target sum may seem like a pure mathematical concept, but it has practical applications in a field known as data analysis. Often, in the data analysis and machine learning field, we are given a large dataset and need to find specific patterns or combinations within the data that lead to or explain a certain outcome. These combinations are not always limited to pairs (as in the two-sum problem), but can also be triples, quadruples or more, depending on the data and problem at hand. The underlying concept is used in predictive analytics, data mining and association rule learning. For instance, in retail sales, it's common to look for combinations of products that are commonly bought together, think of the \"customers who bought this item also bought another item\" recommendations. In our case, we could be looking for combinations of four items, whose total price adds up to a certain target amount.",
                                    "hints": [
                                        {
                                            "hint": "Begin by sorting the input array to simplify the identification of quadruplets and management of duplicates. Sorting ensures that duplicates are adjacent and facilitates the use of pointers for efficient searching."
                                        },
                                        {
                                            "hint": "Iterate through the array, fixing two elements at a time. For each pair, use the two-pointer technique on the remaining array to find pairs of numbers that sum to the complement of the fixed pair. After fixing two elements, use two pointers to traverse the remaining array, adjusting pointers based on the sum."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Fix two elements, nums[i] and nums[j].\nUse two pointers, left and right, on the remaining part of the array to find pairs that sum to targetnums[i]nums[j].\nAdjust pointers:If the sum is less than the target, move left forward to increase the sum.\nIf the sum is greater, move right backward to decrease the sum.",
                                            "question": "How does the two-pointer technique work in this context?"
                                        },
                                        {
                                            "answer": "Skip duplicate values for nums[i], nums[j], nums[left], and nums[right] during the iterations.",
                                            "question": "How do we avoid duplicate quadruplets?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Sorting is part of the solution and is necessary for efficient implementation. Sorting adds O(nlogn) complexity, which is manageable compared to O(n^3).",
                                            "question": " What if the input array is unsorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_sortanarrayof0's1'sand2's",
                                "problem_name": "Sort an array of 0's 1's and 2's",
                                "problem_slug": "sort-an-array-of-0's-1's-and-2's",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "Flipkart",
                                        "Roblox",
                                        "MongoDB",
                                        "JPMorgan Chase",
                                        "Boston Consulting Group",
                                        "Robinhood",
                                        "Broadcom",
                                        "Square",
                                        "Swiggy",
                                        "Qualcomm",
                                        "Reddit",
                                        "Docker",
                                        "NVIDIA",
                                        "PwC",
                                        "McKinsey & Company",
                                        "Epic Systems",
                                        "Red Hat",
                                        "Rakuten",
                                        "Morgan Stanley",
                                        "Bloomberg",
                                        "Byju's",
                                        "Western Digital",
                                        "Seagate Technology",
                                        "AMD",
                                        "KPMG",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, known as the Dutch National Flag problem, is actually quite common in software development. For instance, a practical application of the solution to this problem is in image processing, specifically in sorting the pixels by color. When working with RGB (Red, Green, Blue) pixel values, the colors can be classified into three categories (0, 1, 2), and therefore may need to be sorted in a similar manner for different image manipulation techniques. The key here is that the sorting procedure must not create a new copy of the pixel data (to save memory), which is parallel to the in-place sorting constraint in the problem.",
                                    "hints": [
                                        {
                                            "hint": "\"Use three pointers (low, mid, and high) to partition the array into three regions: Elements less than 1 (0) are moved to the left (region of 0s). Elements equal to 1 are in the middle. Elements greater than 1 (2) are moved to the right (region of 2s).\""
                                        },
                                        {
                                            "hint": "\"If the element at mid is 0, swap it with the element at low and move both pointers forward. If the element at mid is 1, move the mid pointer forward. If the element at mid is 2, swap it with the element at high and move high backward.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The three-pointer approach ensures that each element is placed in the correct region in a single pass. By categorizing elements into 0, 1, and 2 and moving them to their respective regions, the algorithm avoids unnecessary comparisons and swaps.",
                                            "question": "Why use three pointers?"
                                        },
                                        {
                                            "answer": "The algorithm directly modifies the input array by swapping elements as needed. No additional memory is used, resulting in O(1) space complexity.",
                                            "question": "How does the algorithm ensure in-place sorting?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, the algorithm can be generalized to sort arrays with more than three distinct values by extending the partitioning logic. However, for more than three distinct values, other sorting algorithms like quicksort or mergesort may be more appropriate.",
                                            "question": "Can this algorithm be extended to sort arrays with more than three distinct values?"
                                        },
                                        {
                                            "answer": "The algorithm performs the same operations regardless of whether the array is partially sorted. It will still complete in O(n) time, but fewer swaps may be required, improving practical performance slightly.",
                                            "question": "What if the array is partially sorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(medium)_kadane'salgorithm",
                                "problem_name": "Kadane's Algorithm",
                                "problem_slug": "kadane's-algorithm",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "Activision Blizzard",
                                        "Broadcom",
                                        "Teladoc Health",
                                        "Roche",
                                        "Zomato",
                                        "Pinterest",
                                        "Optum",
                                        "Epic Systems",
                                        "Twilio",
                                        "Rockstar Games",
                                        "Siemens Healthineers",
                                        "Red Hat",
                                        "McKinsey & Company",
                                        "Oracle",
                                        "Cloudflare",
                                        "Mastercard",
                                        "Salesforce",
                                        "Seagate Technology",
                                        "Qualcomm",
                                        "Flipkart",
                                        "Bain & Company",
                                        "PwC",
                                        "Electronic Arts",
                                        "Swiggy",
                                        "Philips Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, often referred to as the Maximum Subarray Problem, forms the basis for many real-world applications in the field of Financial Technology. One key application is in the analysis of stock prices. Given the changes in a stock's price over a sequence of time (which can be positive or negative), the maximum subarray problem can be used to determine the most profitable time to buy and sell for maximum profit. The subarray with the largest sum essentially represents the period with the most significant growth. The Kadane's algorithm, often used to solve this problem, is widely used in such financial analysis systems, reinforcing how theoretical computer science problems have direct, practical implications.",
                                    "hints": [
                                        {
                                            "hint": "\"Maintain two variables: currentMax: Tracks the maximum sum ending at the current index. globalMax: Stores the maximum sum seen so far.\""
                                        },
                                        {
                                            "hint": "If adding the current element decreases the sum, start a new subarray from the current element. This happens when the previous sum becomes negative."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Kadanes algorithm runs in O(n) time, making it much more efficient than the O(n^2) or O(n^3) time of nested loop approaches. It processes each element only once.",
                                            "question": "Why use Kadanes algorithm instead of nested loops?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For a 2D matrix:\nUse Kadanes algorithm on each possible submatrix.\nIterate over row pairs, calculating the sum of elements in each submatrix and applying Kadanes algorithm to find the largest subarray sum.",
                                            "question": "How would you generalize this to find the largest subarray sum for 2D arrays (matrices)?"
                                        },
                                        {
                                            "answer": "Track the start and end indices of the maximum subarray:\nWhen starting a new subarray (currentMax = nums[i]), record the start index.\nUpdate the end index when globalMax is updated.",
                                            "question": "How would you modify Kadanes algorithm to return the actual subarray?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "arrays_faqs(hard)",
                        "subcategory_name": "FAQs (Hard)",
                        "subcategory_slug": "faqs-hard",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_majorityelement-i",
                                "problem_name": "Majority Element-I",
                                "problem_slug": "majority-element-i",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "MongoDB",
                                        "GE Healthcare",
                                        "Zomato",
                                        "Lyft",
                                        "Zynga",
                                        "Swiggy",
                                        "Flipkart",
                                        "Walmart",
                                        "Uber",
                                        "Intel",
                                        "Micron Technology",
                                        "Optum",
                                        "Wayfair",
                                        "Red Hat",
                                        "Roblox",
                                        "Texas Instruments",
                                        "OYO Rooms",
                                        "PwC",
                                        "Instacart",
                                        "eBay",
                                        "Salesforce",
                                        "Epic Games",
                                        "Splunk",
                                        "Medtronic",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This kind of problem is frequent in data analytics applications such as marketing research and political polling where a determination needs to be made about the dominant preference expressed in a group of responses. It helps to categorize and understand large datasets and even widely in popularity algorithms used by social media platforms like Facebook or Twitter to detect trends or viral content faster. This algorithm lays the foundation of the Boyer-Moore Majority Voting algorithm, which is an efficient way to solve the problem with a time complexity of O(N) and a space complexity of O(1).",
                                    "hints": [
                                        {
                                            "hint": "Keep a count variable while iterating, Increase count when encountering the same candidate. Decrease count when encountering a different number. If count == 0, change candidate. The final candidate will be the majority element."
                                        },
                                        {
                                            "hint": "Recursively split the array into halves, find the majority element in each half, if both halves agree, return that element."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The majority element always dominates other numbers, so it cancels out non-majority elements when counting.\nEven if count resets, the majority element eventually overtakes.",
                                            "question": "Why does the Boyer-Moore algorithm work?"
                                        },
                                        {
                                            "answer": "Since the majority element appears more than n/2 times, it will always be at nums[n/2] in a sorted array.",
                                            "question": "Why does sorting work?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Boyer-Moore extended approach: Use two candidates instead of one.\nEach valid candidate must appear more than n/3 times.",
                                            "question": "How would you modify this to find all elements appearing more than n/3 times?"
                                        },
                                        {
                                            "answer": "Yes, count each bit position and reconstruct the majority element.",
                                            "question": "Can this problem be solved using bitwise operations?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_majorityelement-ii",
                                "problem_name": "Majority Element-II",
                                "problem_slug": "majority-element-ii",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Ernst & Young",
                                        "Oracle",
                                        "Red Hat",
                                        "MongoDB",
                                        "Bungie",
                                        "KPMG",
                                        "Roblox",
                                        "Lyft",
                                        "Bain & Company",
                                        "Flipkart",
                                        "Cloudflare",
                                        "Robinhood",
                                        "Pinterest",
                                        "Freshworks",
                                        "Reddit",
                                        "Electronic Arts",
                                        "Salesforce",
                                        "HashiCorp",
                                        "Unity Technologies",
                                        "Micron Technology",
                                        "AMD",
                                        "Splunk",
                                        "McKinsey & Company",
                                        "Shopify",
                                        "Qualcomm",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept used in solving this problem is frequently applied in data analytics and database management. For instance, in a system where it is necessary to detect the most common elements in a data set, like finding the most popular products in a shopping app or detecting spam or malicious activities, solutions to this problem can be used. Similarly, social networking applications utilize this concept to discover trending hashtags or posts that are being shared more frequently. It's a simple, but incredibly powerful concept used in many areas of software development.",
                                    "hints": [
                                        {
                                            "hint": "Use two counters to track two potential majority candidates. Count occurrences using a hash map (O(n) space). Collect elements that appear more than n/3 times."
                                        },
                                        {
                                            "hint": "\"Sort the array (O(n log n)). Scan linearly to find elements occurring more than n/3 times.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If there were 3 elements appearing more than n/3 times, their total count would exceed n, which is impossible.",
                                            "question": "Why can there be at most two elements appearing more than n/3 times?"
                                        },
                                        {
                                            "answer": "Sorting takes O(n log n), which is slower than O(n) Boyer-Moore.",
                                            "question": "Why is sorting less efficient?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use k-1 candidates in Boyer-Moore Voting Algorithm instead of just 2.",
                                            "question": "How would you modify this for elements appearing more than n/k times?"
                                        },
                                        {
                                            "answer": "Yes, count each bit position and reconstruct the elements.",
                                            "question": "Can this problem be solved using bitwise operations?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_findtherepeatingandmissingnumber",
                                "problem_name": "Find the repeating and missing number",
                                "problem_slug": "find-the-repeating-and-missing-number",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "Chewy",
                                        "Zoho",
                                        "Dropbox",
                                        "Byju's",
                                        "MongoDB",
                                        "Robinhood",
                                        "Alibaba",
                                        "Teladoc Health",
                                        "AMD",
                                        "JPMorgan Chase",
                                        "Texas Instruments",
                                        "Rakuten",
                                        "Riot Games",
                                        "Micron Technology",
                                        "eBay",
                                        "Red Hat",
                                        "Twilio",
                                        "Johnson & Johnson",
                                        "Seagate Technology",
                                        "Goldman Sachs",
                                        "Epic Systems",
                                        "Deloitte",
                                        "Flipkart",
                                        "ARM",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is essentially a variant of the classic \"find duplicate and missing numbers\" problem, which is extremely relevant in data analysis and database management in software development. For instance, when managing user generated content like user IDs, posts or comments in social media platforms, similar problems often occur - finding duplicate entries or missing entries. Efficiently solving this kind of problem can ensure data integrity and help improve the performance and user experience of the software.",
                                    "hints": [
                                        {
                                            "hint": "The sum of squares of numbers from 1 to n should be (n(n+1)(2n+1))/6. Using this along with the actual sum of squares from the array, we can derive two equations to solve for the missing and duplicate numbers."
                                        },
                                        {
                                            "hint": "The XOR approach works because XOR of the same number cancels out (x ^ x = 0), leaving only the difference between the missing and duplicate numbers."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "After sorting, adjacent duplicates appear together, making them easy to detect.\nMissing numbers are found by checking consecutive values.",
                                            "question": "How does sorting help?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a hash table to track frequencies (O(n) space).\nExtend XOR approach to detect multiple values.",
                                            "question": "How would you modify this if multiple numbers were duplicated or missing?"
                                        },
                                        {
                                            "answer": "Use a hash set or frequency array instead of 1 to n assumption.",
                                            "question": " How does this change for an unsorted list with arbitrary numbers?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_countinversions",
                                "problem_name": "Count Inversions",
                                "problem_slug": "count-inversions",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Bain & Company",
                                        "Mastercard",
                                        "Teladoc Health",
                                        "Zoho",
                                        "Unity Technologies",
                                        "Robinhood",
                                        "NVIDIA",
                                        "Salesforce",
                                        "Etsy",
                                        "Electronic Arts",
                                        "IBM",
                                        "Zomato",
                                        "OYO Rooms",
                                        "Docker",
                                        "Bloomberg",
                                        "Rockstar Games",
                                        "Boston Consulting Group",
                                        "Twilio",
                                        "Activision Blizzard",
                                        "Epic Games",
                                        "Riot Games",
                                        "Alibaba",
                                        "MongoDB",
                                        "Western Digital",
                                        "Broadcom",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem forms the core concept behind certain algorithmic functionalities in database management systems. When a database sorts data, it often uses similar concepts to inversion count. For instance, it can be used in optimizing query processing. The less the number of inversions, the more optimized the data arrangement would be. Additionally, in search engines, the concept of inversion is used to improve search result rankings, for example in determining the best arrangement of URLs given a specific query.",
                                    "hints": [
                                        {
                                            "hint": "We can use Merge Sort to count inversions efficiently in O(n log n). While merging, if nums[i] > nums[j], all elements from i onward in the left half form inversions with nums[j]."
                                        },
                                        {
                                            "hint": " If values in nums are bounded, a Fenwick Tree or Segment Tree can be used to count elements greater than nums[j] before index j in O(n log n)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "While merging two halves, if left[i] > right[j], all remaining elements in left contribute to inversions because they are all greater than right[j].",
                                            "question": "How does Merge Sort count inversions?"
                                        },
                                        {
                                            "answer": "The maximum inversions occur when the array is reverse sorted, which is n(n-1)/2.",
                                            "question": "What is the worst-case inversion count?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The number of inversions represents the minimum swaps needed to sort the array.",
                                            "question": "How does this relate to sorting algorithms?"
                                        },
                                        {
                                            "answer": "Modify the merge function to return both sorted output and the inversion count.",
                                            "question": "How can we modify Merge Sort to also return the sorted array alongside inversion count?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_reversepairs",
                                "problem_name": "Reverse Pairs",
                                "problem_slug": "reverse-pairs",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "Splunk",
                                        "American Express",
                                        "Unity Technologies",
                                        "Walmart",
                                        "Stripe",
                                        "Robinhood",
                                        "HCL Technologies",
                                        "Alibaba",
                                        "Databricks",
                                        "Epic Systems",
                                        "Activision Blizzard",
                                        "OYO Rooms",
                                        "Pinterest",
                                        "Electronic Arts",
                                        "PwC",
                                        "Rockstar Games",
                                        "Flipkart",
                                        "Chewy",
                                        "Boston Consulting Group",
                                        "Riot Games",
                                        "Broadcom",
                                        "Swiggy",
                                        "Visa",
                                        "Uber",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: While the problem of finding reverse pairs in an integer array might seem abstract, it actually finds use in data analysis and comparison-based sorting algorithms like Merge sort or Quick sort. In these cases, an efficient sorting of elements matters a lot, especially when dealing with large datasets. The concept of identifying and handling reverse pairs can be used to optimize these sorting algorithms, thereby improving the performance of software applications that rely on data processing, analysis, or management.",
                                    "hints": [
                                        {
                                            "hint": "Similar to counting inversions, we divide the array into two halves and count reverse pairs while merging. During merging, count the number of nums[j] where nums[i] > 2 * nums[j] for all i < j."
                                        },
                                        {
                                            "hint": "If values in nums are bounded, a Fenwick Tree or Segment Tree can efficiently count elements <= 2 * nums[j] in O(log n)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "While merging, count the number of nums[j] where nums[i] > 2 * nums[j] before merging the two halves to maintain order.",
                                            "question": "How does Merge Sort help in counting reverse pairs?"
                                        },
                                        {
                                            "answer": "If the array is in reverse sorted order with exponentially decreasing values, the count will be close to n(n-1)/2.",
                                            "question": "What is the worst-case number of reverse pairs?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Hash maps allow quick lookups, but they do not support range queries efficiently.",
                                            "question": "Can we use a hash map to store frequency counts instead of a Fenwick Tree?"
                                        },
                                        {
                                            "answer": "Negative values affect 2 * nums[j], but sorting-based approaches still work.",
                                            "question": "What happens if the array contains negative numbers?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_maximumproductsubarrayinanarray",
                                "problem_name": "Maximum Product Subarray in an Array",
                                "problem_slug": "maximum-product-subarray-in-an-array",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "Intel",
                                        "Freshworks",
                                        "Red Hat",
                                        "Docker",
                                        "Chewy",
                                        "Zoho",
                                        "Visa",
                                        "HCL Technologies",
                                        "Unity Technologies",
                                        "JPMorgan Chase",
                                        "Bain & Company",
                                        "Zynga",
                                        "Wayfair",
                                        "Databricks",
                                        "Micron Technology",
                                        "PayPal",
                                        "Mastercard",
                                        "Stripe",
                                        "AMD",
                                        "NVIDIA",
                                        "IBM",
                                        "PwC",
                                        "Riot Games",
                                        "Siemens Healthineers",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a classic example of dynamic programming, which is fundamentally used in various industry-level applications for optimizing solutions to complex problems. For instance, database software like Oracle and MySQL use similar concepts to optimize query parsing. Besides, algorithms similar to this are critical in financial technologies which rely on historical data to analyze trends or optimize investment portfolios. For instance, identifying the most lucrative series of transactions (which operates similarly to finding a subarray with the largest product) is a key strategy used in stock market analysis.",
                                    "hints": [
                                        {
                                            "hint": "Instead of keeping just a maximum sum, maintain both the maximum product and minimum product at each step, since negative numbers can flip signs."
                                        },
                                        {
                                            "hint": "A negative number can make a large positive product negative, but it can also turn a large negative product positive if multiplied with another negative. Therefore, keep track of both the max product so far and the min product so far, swapping when needed."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Because multiplication behaves differently with negative numbers and zeros, so we must track the min product as well.",
                                            "question": "Why does Kadanes algorithm for max sum not work directly for max product?"
                                        },
                                        {
                                            "answer": "A negative number can flip the sign, turning a small negative product into a large positive one.",
                                            "question": "Why do we track both max and min products?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track start and end indices whenever max_prod is updated.",
                                            "question": "How would you modify this to return the actual subarray instead of just the product?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_faqs(hard)_mergetwosortedarrayswithoutextraspace",
                                "problem_name": "Merge two sorted arrays without extra space",
                                "problem_slug": "merge-two-sorted-arrays-without-extra-space",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Texas Instruments",
                                        "Siemens Healthineers",
                                        "Oracle",
                                        "Epic Systems",
                                        "Robinhood",
                                        "Freshworks",
                                        "Qualcomm",
                                        "MongoDB",
                                        "NVIDIA",
                                        "Ernst & Young",
                                        "Square",
                                        "Electronic Arts",
                                        "Salesforce",
                                        "Walmart",
                                        "Cloudflare",
                                        "Bain & Company",
                                        "Intel",
                                        "Swiggy",
                                        "Chewy",
                                        "Pinterest",
                                        "Johnson & Johnson",
                                        "GE Healthcare",
                                        "Zomato",
                                        "Nutanix",
                                        "Red Hat",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: This type of problem is commonly encountered when programmers work with databases. If you have two sorted lists of records (perhaps from two different databases), and you need to merge them into a single sorted list, you might use this type of algorithm. Similarly, this is also a key part of how 'merge sort', a popular and efficient sorting algorithm, works! So, when your data in different apps or systems need to be sorted and merged together, this type of programming solution often comes into action.",
                                    "hints": [
                                        {
                                            "hint": "\"Use three pointers: i = m - 1 (last valid element in nums1) j = n - 1 (last element in nums2) k = m + n - 1 (last index in nums1)\""
                                        },
                                        {
                                            "hint": "\"If nums1[i] > nums2[j], place nums1[i] at nums1[k]. Otherwise, place nums2[j] at nums1[k]. Move the pointer(s) accordingly.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Placing elements from the end avoids shifting elements, making the process O(n + m) time instead of O((m+n) log(m+n)) using sorting.",
                                            "question": "Why start merging from the end instead of the beginning?"
                                        },
                                        {
                                            "answer": "Yes, but in-place merging is required, so no extra space should be used.",
                                            "question": "Can this be solved using extra space?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a temporary array, merge both, then copy back into nums1.",
                                            "question": "How would you modify this if nums1 did not have extra space?"
                                        },
                                        {
                                            "answer": "This is the merge step of merge sort, combining two sorted arrays efficiently.",
                                            "question": "How does this problem relate to merge sort?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "arrays_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 5,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "arrays_arrays_contest_maximumconsecutivegoodnumbers",
                                "problem_name": "Maximum Consecutive Good Numbers",
                                "problem_slug": "maximum-consecutive-good-numbers",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_contest_setdifferenceoftwoarrays",
                                "problem_name": "Set difference of two arrays",
                                "problem_slug": "set-difference-of-two-arrays",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "arrays_arrays_contest_numberofjumps",
                                "problem_name": "Number of Jumps",
                                "problem_slug": "number-of-jumps",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "hashing",
                "category_name": "Hashing",
                "category_slug": "hashing",
                "category_rank": 3,
                "subcategories": [
                    {
                        "subcategory_id": "hashing_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "hashing_hashing_faqs_longestconsecutivesequenceinanarray-dup",
                                "problem_name": "Longest Consecutive Sequence in an Array",
                                "problem_slug": "longest-consecutive-sequence-in-an-array",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "DoorDash",
                                        "Western Digital",
                                        "Unity Technologies",
                                        "Ernst & Young",
                                        "eBay",
                                        "Riot Games",
                                        "Bloomberg",
                                        "GE Healthcare",
                                        "HashiCorp",
                                        "Micron Technology",
                                        "Qualcomm",
                                        "Texas Instruments",
                                        "Docker",
                                        "PwC",
                                        "Swiggy",
                                        "PayPal",
                                        "JPMorgan Chase",
                                        "Ubisoft",
                                        "Activision Blizzard",
                                        "Teladoc Health",
                                        "NVIDIA",
                                        "Instacart",
                                        "Boston Consulting Group",
                                        "Rakuten",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem can be applied in the development of streaming multimedia platforms, for example, Netflix or YouTube. These platforms need to correctly sequence video packets, which could arrive out of order, to provide a seamless streaming experience. Understanding how to find/integrate sequences of consecutive numbers can therefore be crucial for designing the algorithms to handle this task.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash set to store all elements of the array. Iterate through the array, and for each element, check if it is the start of a sequence by ensuring that num1 is not in the set."
                                        },
                                        {
                                            "hint": "For each starting number, count the length of the consecutive sequence by checking for num+1, num+2, etc., in the set. Maintain a variable to store the length of the longest sequence encountered during the traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Using a hash set allows O(1) lookups and avoids the O(nlogn) overhead of sorting. The entire algorithm runs in O(n), making it more efficient for large arrays.",
                                            "question": "Why use a hash set instead of sorting the array? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In addition to tracking the length, maintain the starting number of the longest sequence. Once identified, reconstruct the sequence by iterating from the starting number up to its length.",
                                            "question": "How would you modify the algorithm to return the actual sequence instead of its length? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "hashing_hashing_faqs_longestsubarraywithsumk-dup",
                                "problem_name": "Longest subarray with sum K",
                                "problem_slug": "longest-subarray-with-sum-k",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "Nutanix",
                                        "Intel",
                                        "Oracle",
                                        "Johnson & Johnson",
                                        "Flipkart",
                                        "Docker",
                                        "Bloomberg",
                                        "GE Healthcare",
                                        "eBay",
                                        "PayPal",
                                        "American Express",
                                        "NVIDIA",
                                        "Robinhood",
                                        "Boston Consulting Group",
                                        "Goldman Sachs",
                                        "Philips Healthcare",
                                        "Medtronic",
                                        "Swiggy",
                                        "HashiCorp",
                                        "Airbnb",
                                        "PwC",
                                        "Deloitte",
                                        "Etsy",
                                        "Cerner",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is based on the concept of \"Sliding Window Algorithm\" which is very popular in dealing with array or list data structures in actual software development. Most commonly, this algorithm is used in networking protocols such as TCP to avoid network congestion by controlling the amount of data sent without receiving an acknowledgment, and in multimedia and graphics, where it improves user experience by ensuring smooth data flow and rendering.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash map to store the prefix sum of the array at each index. This helps efficiently track subarrays that sum to k."
                                        },
                                        {
                                            "hint": "For each index i, calculate the prefix sum up to that point. If the prefix sum minus k exists in the hash map, the subarray between those indices sums to k."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The algorithm works with negative numbers because prefix sums account for decreases in the sum. The condition prefixSumk correctly identifies subarrays that sum to k, regardless of the sign of the elements.",
                                            "question": "How does the algorithm handle negative numbers in the array? "
                                        },
                                        {
                                            "answer": "The hash map allows constant-time lookups to check if a subarray with the desired sum exists. This eliminates the need for nested loops, reducing the time complexity from O(n2) to O(n).",
                                            "question": "Why use a hash map for prefix sums? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In addition to storing the prefix sum, store the index where each prefix sum occurs. When a matching prefix sum is found, the subarray can be retrieved using the stored index and the current index.",
                                            "question": "How would you handle finding the subarray itself, not just its length? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "hashing_hashing_faqs_countsubarrayswithgivensum-dup",
                                "problem_name": "Count subarrays with given sum",
                                "problem_slug": "count-subarrays-with-given-sum",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "KPMG",
                                        "Morgan Stanley",
                                        "Rakuten",
                                        "Freshworks",
                                        "Byju's",
                                        "HashiCorp",
                                        "Cerner",
                                        "Zynga",
                                        "Flipkart",
                                        "ARM",
                                        "DoorDash",
                                        "Roblox",
                                        "Databricks",
                                        "Uber",
                                        "IBM",
                                        "Instacart",
                                        "Johnson & Johnson",
                                        "Wayfair",
                                        "Teladoc Health",
                                        "Rockstar Games",
                                        "Swiggy",
                                        "Roche",
                                        "Bungie",
                                        "Medtronic",
                                        "Broadcom",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of this problem is extensively used in the development of financial software and analytical tools. They often require fetching and calculating subarrays of financial data with a certain sum to perform risk assessment, portfolio optimization, model investment scenarios, and track financial anomalies. It forms an integral part of the data analysis engine of these software systems.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash map to store the frequency of prefix sums encountered so far. This allows efficient calculation of the number of subarrays that sum to k."
                                        },
                                        {
                                            "hint": "For each index i, calculate the prefix sum up to that point. If prefixSumk exists in the hash map, it indicates that there are subarrays ending at index i with a sum equal to k."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "For each prefix sum encountered: Check if prefixSumk exists in the map (count the subarrays ending at the current index). Increment the count of the current prefix sum in the map.",
                                            "question": "How is the hash map updated during the process? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Multiple zeros allow multiple overlapping subarrays with sum k. The prefix sum logic naturally counts these overlapping subarrays correctly.  \nInput: nums = [0, 0, 0], k = 0 \nOutput: 6 (Subarrays: [0], [0], [0], [0, 0], [0, 0], [0, 0, 0])",
                                            "question": "How does the algorithm handle arrays with multiple zeros?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "hashing_hashing_faqs_countsubarrayswithgivenxork-dup",
                                "problem_name": "Count subarrays with given xor K",
                                "problem_slug": "count-subarrays-with-given-xor-k",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Qualcomm",
                                        "Seagate Technology",
                                        "Twilio",
                                        "PayPal",
                                        "JPMorgan Chase",
                                        "Instacart",
                                        "Square",
                                        "Etsy",
                                        "Epic Games",
                                        "Broadcom",
                                        "Pinterest",
                                        "Riot Games",
                                        "Bungie",
                                        "Reddit",
                                        "Teladoc Health",
                                        "Byju's",
                                        "Siemens Healthineers",
                                        "Roblox",
                                        "Western Digital",
                                        "OYO Rooms",
                                        "Robinhood",
                                        "Rockstar Games",
                                        "Snowflake",
                                        "Cerner",
                                        "Databricks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of this problem is extensively used in cryptographic algorithms and network protocols in the realm of Cybersecurity. XOR operations, as used in this problem, are an integral part of many encryption methods for safeguarding data. These are used not just for encoding messages, but also for error detections in data transmission and storage, as well as generating hash functions and pseudorandom number sequences. A practical application of this problem's solution can hence lie in cracking certain encryption codes, or testing the strength of these encryption methodologies.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash map to store the frequency of prefix XOR values encountered so far. This allows efficient computation of subarrays with a given XOR sum."
                                        },
                                        {
                                            "hint": "For a subarray ending at index i, if prefixXOR[i]k exists in the hash map, it means there is a subarray whose XOR is k. For each index, count the subarrays ending at that index that satisfy the XOR condition and update the hash map with the current prefix XOR."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "XOR has the property that AB=CA=BC. Using this property, you can efficiently determine if a subarray with the desired XOR exists by comparing the current prefix XOR with previously seen values.",
                                            "question": "Why does XOR work for subarray problems?  "
                                        },
                                        {
                                            "answer": "The hash map keeps track of the frequency of each prefix XOR. If multiple subarrays end at different indices with the same XOR, they are all counted correctly. \nExample: Input: nums = [4, 2, 2, 6], k = 6 \nOutput: 3 (Subarrays: [4, 2], [2, 6], [4, 2, 2, 6])",
                                            "question": "What happens if there are overlapping subarrays with the same XOR? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain two separate hash maps for k1 and k2. Alternate between the two as you traverse the array, counting valid subarrays for each condition.",
                                            "question": "What if you need to count subarrays whose XOR alternates between two values, k1 and k2?  "
                                        },
                                        {
                                            "answer": "XOR-based approaches are limited to problems where the target condition involves XOR properties. They cannot be directly applied to sum, product, or other arithmetic-based subarray problems.",
                                            "question": "What are the limits of XOR-based approaches for subarray problems? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "hashing_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 2,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "hashing_hashing_contest_countofsubarrayswithsumdivisiblebyk",
                                "problem_name": "Count of Subarrays with Sum Divisible by K",
                                "problem_slug": "count-of-subarrays-with-sum-divisible-by-k",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "hashing_hashing_contest_groupwordsbyanagrams",
                                "problem_name": " Group Words by Anagrams",
                                "problem_slug": "group-words-by-anagrams",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "hashing_hashing_contest_maximumpointsonaline",
                                "problem_name": "Maximum Points on a Line",
                                "problem_slug": "maximum-points-on-a-line",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "binarysearch",
                "category_name": "Binary Search",
                "category_slug": "binary-search",
                "category_rank": 4,
                "subcategories": [
                    {
                        "subcategory_id": "binarysearch_fundamentals",
                        "subcategory_name": "Fundamentals",
                        "subcategory_slug": "fundamentals",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_fundamentals_searchxinsortedarray",
                                "problem_name": "Search X in sorted array",
                                "problem_slug": "search-x-in-sorted-array",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Mastercard",
                                        "Epic Systems",
                                        "Walmart",
                                        "PwC",
                                        "Morgan Stanley",
                                        "Rockstar Games",
                                        "Western Digital",
                                        "JPMorgan Chase",
                                        "Byju's",
                                        "Ernst & Young",
                                        "OYO Rooms",
                                        "Splunk",
                                        "DoorDash",
                                        "GE Healthcare",
                                        "Stripe",
                                        "Wayfair",
                                        "Lyft",
                                        "Dropbox",
                                        "NVIDIA",
                                        "Shopify",
                                        "Red Hat",
                                        "Ubisoft",
                                        "McKinsey & Company",
                                        "KPMG",
                                        "Teladoc Health",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This problem is the basic concept behind search engines. Whether you're searching for a specific email in your inbox or a keyword on Google, the underlying program is using a more complex version of this algorithm to find and return the results you're looking for. Without it, the internet as we know it wouldn't exist.",
                                    "hints": [
                                        {
                                            "hint": "Instead of scanning through the array element by element (linear search), leverage the fact that the array is sorted. Divide the search space into halves repeatedly to locate the target. Each step either discards or keeps half the array."
                                        },
                                        {
                                            "hint": "Always start by calculating the midpoint of the current search range. If the midpoint value matches the target, youre done. If its smaller, the target must be on the right; if larger, it must be on the left."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "While linear search works, it requires O(n) time. Binary search reduces the complexity to O(logn), which is much faster for large arrays.",
                                            "question": "Why not use linear search?"
                                        },
                                        {
                                            "answer": "For an infinite sorted array, start with a bounded range and double the range size until the target is within the bounds. Then apply binary search within that range.",
                                            "question": "What if the array is infinite?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "To find the first occurrence, adjust your logic to continue searching the left half even after finding a match. Similarly, for the last occurrence, search the right half after finding a match. This ensures you locate the boundary of duplicate elements.",
                                            "question": "How would you modify binary search to find the first or last occurrence of the target?"
                                        },
                                        {
                                            "answer": "For a rotated sorted array, modify the binary search to check which half of the array is sorted at each step. Use this information to decide whether to search in the left or right half.",
                                            "question": "What if the array is rotated?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_fundamentals_lowerbound",
                                "problem_name": "Lower Bound",
                                "problem_slug": "lower-bound-",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Morgan Stanley",
                                        "Western Digital",
                                        "Qualcomm",
                                        "Broadcom",
                                        "Ubisoft",
                                        "ARM",
                                        "Etsy",
                                        "Instacart",
                                        "Lyft",
                                        "Chewy",
                                        "GE Healthcare",
                                        "Siemens Healthineers",
                                        "Docker",
                                        "HashiCorp",
                                        "JPMorgan Chase",
                                        "Epic Games",
                                        "Twilio",
                                        "Robinhood",
                                        "Teladoc Health",
                                        "Optum",
                                        "Swiggy",
                                        "Salesforce",
                                        "Target",
                                        "Goldman Sachs",
                                        "AMD",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: Lower bound algorithms are commonly used in database queries and search engines. They help improve the speed of searches by eliminating sections of data that don't need to be searched. For example, when you're typing in the search bar of an e-commerce app, a lower bound algorithm can quickly find the starting point of the products that start with the letters you've entered, significantly speeding up the search process. So, every time you search for a product on a shopping app or a keyword on a search engine, there's a good chance you're using a lower bound algorithm!",
                                    "hints": [
                                        {
                                            "hint": "Its not just about finding x; youre looking for the first index where the array value is greater than or equal to x.Think of it as finding where x \"fits\" in the array while maintaining the sorted order."
                                        },
                                        {
                                            "hint": "\"Use binary search logic but modify the condition for moving the pointers. If nums[mid]x, the answer might lie to the left, so move the high pointer. Otherwise, move the low pointer to search the right half.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In regular binary search, you stop when you find the exact match. In lower bound, you dont stop there. You continue searching to find the smallest index satisfying nums[index]x.",
                                            "question": "How does lower bound differ from regular binary search?"
                                        },
                                        {
                                            "answer": "In this case, the algorithm correctly returns the size of the array, as x would be placed beyond the last index.",
                                            "question": "What if x is larger than all elements?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For a rotated sorted array:\nFind the pivot first (smallest element).\nApply lower bound logic in the correct half of the rotated array.",
                                            "question": "What if the array is rotated?"
                                        },
                                        {
                                            "answer": "Ensure your condition for updating pointers prevents overlapping:\nUse low=mid+1 for moving right.\nUse high=mid for moving left.\nTerminate when lowhigh.",
                                            "question": "How do I avoid infinite loops in binary search?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_fundamentals_upperbound",
                                "problem_name": "Upper Bound",
                                "problem_slug": "upper-bound",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "American Express",
                                        "Shopify",
                                        "Stripe",
                                        "Micron Technology",
                                        "Intel",
                                        "Siemens Healthineers",
                                        "Square",
                                        "Bloomberg",
                                        "Western Digital",
                                        "Teladoc Health",
                                        "Docker",
                                        "Airbnb",
                                        "Red Hat",
                                        "Roblox",
                                        "Target",
                                        "Swiggy",
                                        "Deloitte",
                                        "Broadcom",
                                        "HashiCorp",
                                        "Pinterest",
                                        "Optum",
                                        "NVIDIA",
                                        "Zomato",
                                        "Splunk",
                                        "Activision Blizzard",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "The underlying concept of the 'upper bound' problem is used in database indexing strategies. When querying data, databases often need to quickly find the range of entries that satisfy a certain condition. For instance, finding all customers whose yearly income is above a certain value. Here, the 'upper bound' function can efficiently return the first record that exceeds the specified income, and all successive records can be retrieved from there. This allows significant speedup in the processing of such queries, ultimately enhancing performance of applications that rely on large databases.",
                                    "hints": [
                                        {
                                            "hint": "\"The upper bound doesnt care about whether x exists in the array. Its about finding the smallest index where nums[index]>x.\""
                                        },
                                        {
                                            "hint": "\"Use the usual binary search setup, but adjust the condition: If nums[mid]>x, the result could be at mid, so move the high pointer to search the left half. Otherwise, move the low pointer to search the right half. Stop when the low pointer overtakes the high pointer.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The lower bound finds the first index where nums[index]x, while the upper bound looks for nums[index]>x. Its a subtle but crucial distinction that affects pointer movements in binary search.",
                                            "question": "How is upper bound different from lower bound?"
                                        },
                                        {
                                            "answer": "Data Filtering: Identifying elements greater than a threshold in sorted datasets.\nSearch Queries: Finding the smallest item larger than a user-defined parameter (e.g., \"next larger price\").",
                                            "question": "How can this be applied to real-world scenarios?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use external storage or chunked processing if the array doesnt fit in memory.\nBinary search works efficiently even for large datasets due to logarithmic complexity.",
                                            "question": "How would you optimize for very large arrays?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearch_logicbuilding",
                        "subcategory_name": "Logic Building",
                        "subcategory_slug": "logic-building",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_searchinsertposition",
                                "problem_name": "Search insert position",
                                "problem_slug": "search-insert-position",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Morgan Stanley",
                                        "IBM",
                                        "Shopify",
                                        "Salesforce",
                                        "Airbnb",
                                        "Rakuten",
                                        "Western Digital",
                                        "Alibaba",
                                        "Zoho",
                                        "Byju's",
                                        "OYO Rooms",
                                        "Teladoc Health",
                                        "Intel",
                                        "Cloudflare",
                                        "JPMorgan Chase",
                                        "Square",
                                        "Roche",
                                        "Riot Games",
                                        "Etsy",
                                        "MongoDB",
                                        "Stripe",
                                        "Robinhood",
                                        "Optum",
                                        "Splunk",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Use the binary search algorithm to narrow down the position of the target or where it should be inserted."
                                        },
                                        {
                                            "hint": "\"If the target is smaller than all elements, return 0 (insert at the beginning). If the target is larger than all elements, return the size of the array (insert at the end).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The low pointer always points to the first index where the target could fit without disrupting the sorted order.",
                                            "question": " Why return low as the insertion position?"
                                        },
                                        {
                                            "answer": "In a sense, this is equivalent to finding the lower bound of the target.\nHowever, here youre also explicitly checking whether the target exists in the array.",
                                            "question": "How is this different from finding the lower bound?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The algorithm can be adapted for floating-point numbers by changing the comparison logic. Ensure proper precision handling to avoid errors.",
                                            "question": "What happens if the target is a floating-point value?"
                                        },
                                        {
                                            "answer": "If duplicates are allowed, the algorithm still works and finds the first occurrence where the target can fit (lower bound logic).\nExample:\nInput: nums = [1, 3, 3, 5], target = 3  Output: 1.",
                                            "question": "What if the array contains duplicates?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_floorandceilinsortedarray",
                                "problem_name": "Floor and Ceil in Sorted Array",
                                "problem_slug": "floor-and-ceil-in-sorted-array",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Etsy",
                                        "Lyft",
                                        "Red Hat",
                                        "GE Healthcare",
                                        "KPMG",
                                        "McKinsey & Company",
                                        "Twilio",
                                        "Chewy",
                                        "Mastercard",
                                        "American Express",
                                        "Cloudflare",
                                        "Nutanix",
                                        "Wayfair",
                                        "Ubisoft",
                                        "Johnson & Johnson",
                                        "PwC",
                                        "Uber",
                                        "Snowflake",
                                        "Target",
                                        "Ernst & Young",
                                        "PayPal",
                                        "Roblox",
                                        "Zomato",
                                        "Instacart",
                                        "HashiCorp",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Perform a binary search for x in the sorted array. During the search: If nums[mid]x, update the floor to nums[mid] and move right. If nums[mid]x, update the ceiling to nums[mid] and move left.\""
                                        },
                                        {
                                            "hint": "If x is smaller than the smallest element, the floor is 1. If x is larger than the largest element, the ceiling is 1."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Binary search systematically narrows the range:\nFor the floor, you look for the largest element less than or equal to x.\nFor the ceiling, you look for the smallest element greater than or equal to x.",
                                            "question": "How does binary search naturally find the floor and ceiling?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Identify the pivot point first. Then: Search for the floor and ceiling in the left and right sorted halves separately.",
                                            "question": " What if the array is rotated?"
                                        },
                                        {
                                            "answer": "Once the floor and ceiling are identified, use binary search to find the range of indices between them.",
                                            "question": "How would you extend this to find all elements between the floor and ceiling?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_firstandlastoccurrence",
                                "problem_name": "First and last occurrence",
                                "problem_slug": "first-and-last-occurrence",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "PayPal",
                                        "Qualcomm",
                                        "Zoho",
                                        "Western Digital",
                                        "Johnson & Johnson",
                                        "Ernst & Young",
                                        "Roblox",
                                        "eBay",
                                        "Walmart",
                                        "Shopify",
                                        "Deloitte",
                                        "NVIDIA",
                                        "Goldman Sachs",
                                        "MongoDB",
                                        "Etsy",
                                        "Dropbox",
                                        "Riot Games",
                                        "Flipkart",
                                        "Bain & Company",
                                        "Freshworks",
                                        "Boston Consulting Group",
                                        "Philips Healthcare",
                                        "IBM",
                                        "Roche",
                                        "Robinhood",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: This problem is essentially about range queries which are a very common task in database management systems and search engines. For instance, if you use the filter function in an e-commerce website to specify a price range for a product, you're effectively asking the database to perform an operation much like this problem. The database will search through its sorted data to find the starting and ending positions of all products that fall within your specified price range. So the next time you're shopping online, remember you're indirectly solving this problem!",
                                    "hints": [
                                        {
                                            "hint": "\"Perform two separate binary searches: One to find the first occurrence of the target. Another to find the last occurrence of the target.\""
                                        },
                                        {
                                            "hint": "\"To find the first occurrence, move the search to the left half even after finding the target. To find the last occurrence, move the search to the right half after finding the target.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In a sorted array with duplicates:\nThe first binary search stops only when the leftmost occurrence of the target is found.\nThe second binary search ensures the rightmost occurrence is located by adjusting the search bounds appropriately.",
                                            "question": "How does the algorithm ensure correctness with duplicates?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The count is simply: count=lastIndexfirstIndex+1\nThis computation is direct and efficient once the first and last occurrences are identified.",
                                            "question": "How would you modify the algorithm to find the count of the target value in the array?"
                                        },
                                        {
                                            "answer": "Yes:\nFor floating-point numbers, ensure proper handling of precision in comparisons.\nFor custom logic (e.g., case-insensitive string comparisons), adapt the binary search condition to fit the requirement.",
                                            "question": " Can this algorithm handle floating-point numbers or custom comparison logic?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_searchinrotatedsortedarray-i",
                                "problem_name": "Search in rotated sorted array-I",
                                "problem_slug": "search-in-rotated-sorted-array-i",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Deloitte",
                                        "Square",
                                        "Reddit",
                                        "Roblox",
                                        "MongoDB",
                                        "Zynga",
                                        "Teladoc Health",
                                        "Ernst & Young",
                                        "Nutanix",
                                        "GE Healthcare",
                                        "Western Digital",
                                        "Medtronic",
                                        "ARM",
                                        "Snowflake",
                                        "Cloudflare",
                                        "Qualcomm",
                                        "McKinsey & Company",
                                        "IBM",
                                        "Twilio",
                                        "Chewy",
                                        "Lyft",
                                        "Seagate Technology",
                                        "NVIDIA",
                                        "Epic Games",
                                        "Walmart",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Use binary search to locate the target value while considering the rotation. During each iteration, check if the target lies in the sorted half of the array."
                                        },
                                        {
                                            "hint": "\"Compare the mid element with the first and last elements to determine which half is sorted: If nums[mid] >= nums[low], the left half is sorted. If nums[mid] <= nums[high], the right half is sorted.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Single-element array: Directly check if the element matches the target.\nNo rotation: Binary search works as usual because the array is sorted.\nTarget at the rotation point: The algorithm naturally handles this by detecting the sorted halves.\n",
                                            "question": "How do we handle edge cases like small arrays or extreme rotations?"
                                        },
                                        {
                                            "answer": "Linear search would work, but its inefficient with O(n) complexity. By leveraging binary search, we reduce the time complexity to O(logn), which is critical for handling large datasets efficiently.",
                                            "question": "Why not linear search?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "With duplicates, the sorted property may be unclear. For example, [2, 2, 2, 3, 1, 2]:\nIf nums[mid] == nums[low] == nums[high], skip duplicates by incrementing low or decrementing high.",
                                            "question": "What if duplicates are allowed in the array?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_searchinrotatedsortedarray-ii",
                                "problem_name": "Search in rotated sorted array-II",
                                "problem_slug": "search-in-rotated-sorted-array-2",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Robinhood",
                                        "Twilio",
                                        "Walmart",
                                        "Wayfair",
                                        "Unity Technologies",
                                        "Intel",
                                        "Mastercard",
                                        "Bain & Company",
                                        "HashiCorp",
                                        "Nutanix",
                                        "Goldman Sachs",
                                        "Qualcomm",
                                        "Epic Systems",
                                        "Stripe",
                                        "Etsy",
                                        "McKinsey & Company",
                                        "Databricks",
                                        "ARM",
                                        "HCL Technologies",
                                        "Freshworks",
                                        "MongoDB",
                                        "Byju's",
                                        "Riot Games",
                                        "NVIDIA",
                                        "GE Healthcare",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "In a rotated sorted array, at least one of the two halves is guaranteed to be sorted. Identify this sorted half by comparing nums[mid] with nums[low] and nums[high]. Use this information to decide where the target might lie and narrow down the search space."
                                        },
                                        {
                                            "hint": "Duplicates complicate determining the sorted half. When nums[low] == nums[mid] == nums[high], you cannot deduce which half is sorted. In this case, increment low or decrement high to skip duplicates and continue the binary search."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, even with duplicates, you ensure termination by updating low and high correctly:\nIncrement low or decrement high when duplicates are encountered.\nAlways check nums[mid] for the target before proceeding to analyze the sorted halves.",
                                            "question": "Can we guarantee a termination condition with duplicates?"
                                        },
                                        {
                                            "answer": "Binary search works because the rotation splits the array into two parts, at least one of which is sorted. By identifying the sorted segment during each step, you can confidently determine where the target might reside, halving the search space as you go.",
                                            "question": "Why does binary search work for rotated arrays?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the array is unsorted but rotated, the binary search logic breaks. Youd first need to sort the array (O(nlogn)) and then apply the standard binary search or rotated logic. This preprocessing step adds overhead.",
                                            "question": "What changes if the array is not sorted but still rotated?"
                                        },
                                        {
                                            "answer": "You can modify the algorithm to locate the smallest number greater than or equal to the lower bound and the largest number smaller than or equal to the upper bound. This would involve combining the rotated binary search logic with range queries.",
                                            "question": "What if you need to find the range of numbers within certain bounds in the rotated array?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_findminimuminrotatedsortedarray",
                                "problem_name": "Find minimum in Rotated Sorted Array",
                                "problem_slug": "find-minimum-in-rotated-sorted-array",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Ernst & Young",
                                        "Nutanix",
                                        "Red Hat",
                                        "Optum",
                                        "HashiCorp",
                                        "Philips Healthcare",
                                        "DoorDash",
                                        "Target",
                                        "Ubisoft",
                                        "Zomato",
                                        "Airbnb",
                                        "Reddit",
                                        "KPMG",
                                        "Morgan Stanley",
                                        "OYO Rooms",
                                        "Zynga",
                                        "Snowflake",
                                        "Databricks",
                                        "IBM",
                                        "Uber",
                                        "Siemens Healthineers",
                                        "Splunk",
                                        "Shopify",
                                        "American Express",
                                        "Twilio",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A rotated sorted array contains two sorted segments, with the rotation causing a discontinuity. The smallest element (minimum) is the pivot point where the rotation occurs. The minimum element is the only one smaller than its previous element (except at index 0, where it is compared to the last element)."
                                        },
                                        {
                                            "hint": "\"Compare the middle element (nums[mid]) with the rightmost element (nums[high]): If nums[mid] > nums[high], the minimum lies in the right half (low = mid + 1). If nums[mid] <= nums[high], the minimum lies in the left half (high = mid).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the array is sorted and not rotated, the first element (nums[0]) is the minimum. This is detected in O(1) by checking if nums[low] <= nums[high] at the start of the binary search.",
                                            "question": "What happens if the array is not rotated?"
                                        },
                                        {
                                            "answer": "If nums[mid] > nums[high], the minimum cannot lie in the left half because all elements in the left half are greater than nums[mid]. Move low = mid + 1.\nIf nums[mid] <= nums[high], the minimum could lie in the left half, so adjust high = mid.",
                                            "question": "How is the search space reduced at each step?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The algorithm remains the same, but instead of returning the element (nums[low]), return the index (low). This is particularly useful in applications like finding the rotation count.",
                                            "question": "How would you find the index of the minimum element?"
                                        },
                                        {
                                            "answer": "Check if nums[0] <= nums[N-1]:\nIf true, the array is sorted and not rotated.\nIf false, the array is rotated.",
                                            "question": "How would you detect if the array is rotated and not sorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_findouthowmanytimesthearrayisrotated",
                                "problem_name": "Find out how many times the array is rotated",
                                "problem_slug": "find-out-how-many-times-the-array-is-rotated",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "PwC",
                                        "Philips Healthcare",
                                        "Airbnb",
                                        "Byju's",
                                        "HCL Technologies",
                                        "ARM",
                                        "Pinterest",
                                        "Riot Games",
                                        "Splunk",
                                        "Goldman Sachs",
                                        "Boston Consulting Group",
                                        "Oracle",
                                        "Docker",
                                        "Johnson & Johnson",
                                        "Siemens Healthineers",
                                        "Nutanix",
                                        "Roblox",
                                        "Deloitte",
                                        "Databricks",
                                        "Intel",
                                        "Zoho",
                                        "Chewy",
                                        "Epic Games",
                                        "Unity Technologies",
                                        "Salesforce",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "The rotation count is equivalent to the index of the smallest element (pivot) in the rotated sorted array."
                                        },
                                        {
                                            "hint": "\"Use binary search to locate the smallest element (pivot) efficiently: If nums[mid] > nums[high], the pivot lies in the right half. Update low = mid + 1. If nums[mid] <= nums[high], the pivot lies in the left half or is the middle element itself. Update high = mid.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A right rotation shifts elements to the right, and the smallest element ends up at the pivot. Its index directly represents how many positions the array has been rotated.",
                                            "question": "Why does the pivot index indicate the number of rotations?"
                                        },
                                        {
                                            "answer": "Binary search leverages the fact that one half of the rotated array is always sorted:\nIf nums[mid] > nums[high], the rotation point is in the unsorted right half.\nIf nums[mid] <= nums[high], the rotation point lies in the left half, including the middle element.",
                                            "question": "How does binary search work in this context?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The pivot is the smallest element in the array. The binary search steps remain the same, and the rotation count is simply the index of this pivot.",
                                            "question": "How would you locate the pivot explicitly?"
                                        },
                                        {
                                            "answer": "A left-rotated array can be treated similarly by modifying the rotation count:\nFor a left rotation, the rotation count is npivotIndex, where n is the array size.",
                                            "question": "What if the array is left-rotated instead of right-rotated?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_logicbuilding_singleelementinsortedarray",
                                "problem_name": "Single element in sorted array",
                                "problem_slug": "single-element-in-sorted-array",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "McKinsey & Company",
                                        "GE Healthcare",
                                        "Roche",
                                        "Bain & Company",
                                        "Visa",
                                        "OYO Rooms",
                                        "Intel",
                                        "Alibaba",
                                        "Electronic Arts",
                                        "HCL Technologies",
                                        "Morgan Stanley",
                                        "Rockstar Games",
                                        "Bungie",
                                        "Snowflake",
                                        "Zoho",
                                        "Twilio",
                                        "Uber",
                                        "Walmart",
                                        "Salesforce",
                                        "ARM",
                                        "Dropbox",
                                        "Flipkart",
                                        "Broadcom",
                                        "Zomato",
                                        "Ubisoft",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "The array is sorted, which means duplicate numbers will appear consecutively. The single number will break this pattern of consecutive duplicates. Use this property to identify the single number efficiently."
                                        },
                                        {
                                            "hint": "\"Perform a binary search to locate the single number. At each step, check the pairing pattern: If nums[mid] == nums[mid + 1], the single number lies in the unsorted half beyond this pair. Otherwise, if nums[mid] == nums[mid - 1], the single number lies before this pair.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The minimum size of the array is 3, consisting of one single number and one pair. For example, [1, 2, 2] or [1, 1, 2].",
                                            "question": "What is the minimum size of the array, and why?"
                                        },
                                        {
                                            "answer": "If the single number is at the start (nums[0]) or end (nums[n-1]), the binary search will naturally identify it because no pairing is possible for these positions.",
                                            "question": "What happens if the single number is at the start or end of the array?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For an unsorted array, the optimal approach is to use the XOR operation. XOR has the property aa=0 and a0=a. XOR all elements in the array to isolate the single number in O(n).",
                                            "question": "How would you modify this approach for unsorted arrays?"
                                        },
                                        {
                                            "answer": "If there are multiple single numbers, XOR wont work directly. Use a hash map to count occurrences of each element, then return the numbers that appear once.",
                                            "question": "What if the array contains more than one single number?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearch_onanswers",
                        "subcategory_name": "On answers",
                        "subcategory_slug": "on-answers",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_onanswers_findsquarerootofanumber",
                                "problem_name": "Find square root of a number",
                                "problem_slug": "find-square-root-of-a-number",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Salesforce",
                                        "Nutanix",
                                        "Johnson & Johnson",
                                        "Oracle",
                                        "Instacart",
                                        "Riot Games",
                                        "Texas Instruments",
                                        "McKinsey & Company",
                                        "Deloitte",
                                        "Roblox",
                                        "Wayfair",
                                        "Red Hat",
                                        "Splunk",
                                        "IBM",
                                        "Zomato",
                                        "Freshworks",
                                        "Unity Technologies",
                                        "Bain & Company",
                                        "Teladoc Health",
                                        "Airbnb",
                                        "Activision Blizzard",
                                        "Goldman Sachs",
                                        "Square",
                                        "Epic Systems",
                                        "PwC",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "The goal is to calculate the integer square root of n, which is the largest integer x such that x2n. This can be efficiently solved using binary search as the square root function is monotonic (increases steadily)."
                                        },
                                        {
                                            "hint": "\"Use binary search to find x between 0 and n. At each step, calculate the middle value (mid) and its square (mid^2): If mid^2 == n, youve found the square root. If mid^2 < n, adjust low = mid + 1 to move right. If mid^2 > n, adjust high = mid - 1 to move left.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of directly calculating mid^2, compare mid with n/mid. If mid > n / mid, mid^2 exceeds n, and you should move left. This ensures safe arithmetic even for large n.",
                                            "question": "How do we avoid integer overflow when computing mid^2?"
                                        },
                                        {
                                            "answer": "The binary search naturally finds the exact square root when mid^2 == n. The result is returned directly without additional steps.",
                                            "question": "What happens if n is a perfect square?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use approximation techniques like Newtons method, which converges quickly and is well-suited for systems requiring rapid results.",
                                            "question": "What if the function needs to work in real-time systems?"
                                        },
                                        {
                                            "answer": "For floating-point numbers, extend the binary search to calculate the square root up to a desired precision (): Continue the search until mid^2n<.\nUpdate low and high with smaller increments as the range narrows.",
                                            "question": "How would you compute the square root for floating-point numbers?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_onanswers_findnthrootofanumber",
                                "problem_name": "Find Nth root of a number",
                                "problem_slug": "find-nth-root-of-a-number",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Swiggy",
                                        "DoorDash",
                                        "American Express",
                                        "Morgan Stanley",
                                        "Broadcom",
                                        "Stripe",
                                        "Qualcomm",
                                        "Rockstar Games",
                                        "Micron Technology",
                                        "Riot Games",
                                        "Splunk",
                                        "Bungie",
                                        "Pinterest",
                                        "Philips Healthcare",
                                        "Nutanix",
                                        "Salesforce",
                                        "PayPal",
                                        "Visa",
                                        "Lyft",
                                        "Target",
                                        "OYO Rooms",
                                        "Epic Systems",
                                        "Shopify",
                                        "Goldman Sachs",
                                        "McKinsey & Company",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This concept is widely used in game development, 3D graphics and image manipulation software. It's a key part in calculating distances and generating effects such as fog or light falloff. Additionally, the problem comes into play in audio processing for generating specific tones or adjusting volume and pitch. This mathematical operation, finding the Nth root, is an integral part of many algorithmic solutions in software.",
                                    "hints": [
                                        {
                                            "hint": "The N-th root of M is a number X such that X^N=M. The goal is to find X, and if X is not an integer, return 1. This problem involves numerical precision and logical decision-making to determine if X is an integer."
                                        },
                                        {
                                            "hint": "\"Use binary search to find X in the range [1,M]: Compute mid^N at each step.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Binary search will terminate without finding mid^N=M. Return 1 in such cases, as the N-th root is not an integer.",
                                            "question": "What happens if M is not a perfect N-th power?"
                                        },
                                        {
                                            "answer": "Instead of directly calculating mid^N, compute mid^N iteratively:\nMultiply mid^N times while checking if the result exceeds M. Stop early if overflow is detected.",
                                            "question": "How do we avoid integer overflow when calculating mid^N?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For large M, calculate mid^N iteratively to prevent overflow. For large N, reduce the problem to smaller powers using modular arithmetic or logarithms (log(M)/N) to estimate the root.",
                                            "question": "What if M and N are very large?"
                                        },
                                        {
                                            "answer": "For matrices or tensors, compute the root element-wise using the same binary search logic. If the root must satisfy additional conditions (e.g., orthogonality), integrate those into the solution.",
                                            "question": "How would you extend this to multi-dimensional data?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_onanswers_findthesmallestdivisor",
                                "problem_name": "Find the smallest divisor",
                                "problem_slug": "find-the-smallest-divisor",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "NVIDIA",
                                        "Square",
                                        "Byju's",
                                        "Mastercard",
                                        "Riot Games",
                                        "DoorDash",
                                        "Zynga",
                                        "Dropbox",
                                        "Pinterest",
                                        "Swiggy",
                                        "HCL Technologies",
                                        "Epic Systems",
                                        "Goldman Sachs",
                                        "Rakuten",
                                        "Cloudflare",
                                        "KPMG",
                                        "Broadcom",
                                        "Unity Technologies",
                                        "ARM",
                                        "Zomato",
                                        "Western Digital",
                                        "Epic Games",
                                        "eBay",
                                        "PwC",
                                        "Intel",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem plays a crucial part in video streaming services like Netflix, YouTube, or Twitch, where the system needs to dynamically adjust the quality of video (bitrate) based on network conditions. The total amount of data that can be sent (threshold) is fixed, and the task is to find the smallest denominator (lowest video quality) so that the sum of data (video chunks) stays under the threshold. By solving this problem, services can ensure smooth streaming experiences, without buffering, while taking full advantage of all available bandwidth.",
                                    "hints": [
                                        {
                                            "hint": "The task is to find the smallest positive integer divisor, d, such that the sum of ceil(nums[i]/d) across all elements of the array nums is less than or equal to a given threshold."
                                        },
                                        {
                                            "hint": "The divisor lies in the range [1,max(nums)]. Use binary search to efficiently find the smallest d. For a midpoint mid, calculate the sum of ceil(nums[i]/mid)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of using ceil(nums[i]/d), compute (nums[i]+d1)//d. This avoids floating-point arithmetic and directly calculates the rounded-up integer value.",
                                            "question": "How does the rounding work for division?"
                                        },
                                        {
                                            "answer": "If the threshold is larger than or equal to the sum of elements when divided by 1 (i.e., (nums)), the smallest divisor is 1, as no larger divisor is required.",
                                            "question": "What happens if the threshold is very high?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Reverse the binary search logic to prioritize larger divisors. Use the same sum calculation but adjust the bounds to find the maximum d that satisfies the condition.",
                                            "question": "What if you need the largest divisor instead of the smallest?"
                                        },
                                        {
                                            "answer": "Divide the array into chunks, calculate partial sums for each chunk, and combine them dynamically during the binary search. This reduces memory usage and ensures scalability.",
                                            "question": "How would you optimize this for extremely large datasets?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_onanswers_kokoeatingbananas",
                                "problem_name": "Koko eating bananas",
                                "problem_slug": "koko-eating-bananas",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Chewy",
                                        "NVIDIA",
                                        "Deloitte",
                                        "Cloudflare",
                                        "Johnson & Johnson",
                                        "Walmart",
                                        "Ubisoft",
                                        "Twilio",
                                        "MongoDB",
                                        "Intel",
                                        "Nutanix",
                                        "McKinsey & Company",
                                        "Etsy",
                                        "Ernst & Young",
                                        "JPMorgan Chase",
                                        "Medtronic",
                                        "Zoho",
                                        "Morgan Stanley",
                                        "Texas Instruments",
                                        "GE Healthcare",
                                        "Lyft",
                                        "AMD",
                                        "DoorDash",
                                        "Mastercard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is based on Binary Search, an algorithm which is extensively used in real world applications. It presents a system with limited resources (the monkey and time) and seeks to optimize consumption (bananas). This is a common scenario in software design. For example, when dealing with job scheduling in Computer Systems, where there are 'n' number of tasks and a limited processing power, system designers have to allocate resources in a way to get minimum execution time. Similarly, in Databases, index searching for a particular record is optimized using Binary Search. Which is the same concept of finding the minimum (or optimal) number to improve efficiency.",
                                    "hints": [
                                        {
                                            "hint": "The monkey must eat at least k bananas per hour to finish all the bananas in h hours. The task is to determine the smallest k that satisfies this condition. Eating k bananas per hour affects how quickly piles are depleted, and k must balance speed and efficiency."
                                        },
                                        {
                                            "hint": "\"The range for k is between 1 and max(nums). Perform binary search to find the smallest k: For each k, calculate the total hours required to eat all bananas.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the hours exceed h for a given k, k is too small, and the monkey needs to eat faster. Adjust the binary search range by setting low=mid+1.",
                                            "question": "What if the total hours required exceeds h?"
                                        },
                                        {
                                            "answer": "Use (nums[i]+k1)//k instead of floating-point division to avoid precision issues and maintain integer operations. This ensures accuracy even with large inputs.\n",
                                            "question": "How do we handle very large values of nums[i] or h?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the monkeys eating rate changes per hour (e.g., k depends on the hour), use a dynamic approach to calculate the minimum k for each hour, adjusting the binary search to consider these variations.",
                                            "question": "How would you extend this for varying hourly capacities?"
                                        },
                                        {
                                            "answer": "For dynamic or replenishing piles, track the rate of replenishment and modify the binary search to account for the changing size of nums[i] at each hour.",
                                            "question": "What if the piles of bananas can be replenished?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_onanswers_minimumdaystomakembouquets",
                                "problem_name": "Minimum days to make M bouquets",
                                "problem_slug": "minimum-days-to-make-m-bouquets",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Deloitte",
                                        "Johnson & Johnson",
                                        "Wayfair",
                                        "Walmart",
                                        "Medtronic",
                                        "Epic Games",
                                        "Siemens Healthineers",
                                        "Twilio",
                                        "Robinhood",
                                        "Rakuten",
                                        "Intel",
                                        "Philips Healthcare",
                                        "Flipkart",
                                        "Chewy",
                                        "Lyft",
                                        "Micron Technology",
                                        "Zomato",
                                        "Roblox",
                                        "Optum",
                                        "Qualcomm",
                                        "GE Healthcare",
                                        "DoorDash",
                                        "Zoho",
                                        "eBay",
                                        "OYO Rooms",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, at its essence, involves optimal scheduling and resource allocation - concepts critical to many areas in software development. An interesting real-world application is found in distributed computing or microservices architecture, where you need to manage the execution time and ordering of numerous independent tasks (roses blooming) to meet certain requirements (making bouquets). Similarly, this problem can reflect challenges in project management software, where tasks have specific start times (bloom days), and certain tasks have to be completed together (bouquet making) within specified time frames.",
                                    "hints": [
                                        {
                                            "hint": "\"Use binary search to determine the smallest d within the range [1,max(nums)]. For each mid-point d, simulate the blooming process to check if at least m bouquets can be formed.\""
                                        },
                                        {
                                            "hint": "On a given day d, a rose is considered bloomed if nums[i]d. Traverse the array and count adjacent bloomed roses. If k adjacent roses are found, form one bouquet and reset the count. Repeat until m bouquets are formed or the array is exhausted."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use a single pass through the array on day d:\nCount consecutive roses that bloom on or before d.\nReset the count whenever nums[i]>d.\nStop early if m bouquets are formed, optimizing the simulation.",
                                            "question": "How is bouquet feasibility checked efficiently?"
                                        },
                                        {
                                            "answer": "Testing each day from 1 to max(nums) linearly has O(nmax(nums)) complexity, which is inefficient. Binary search narrows down the range logarithmically, significantly reducing the number of simulations.",
                                            "question": "Why use binary search to find the minimum days?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For non-adjacent bouquets, modify the simulation to track individual roses that bloom on or before d. Count all such roses and check if their total is sufficient to form mk bouquets.",
                                            "question": "How would you handle non-adjacent bouquets?"
                                        },
                                        {
                                            "answer": "Model blooming as a graph, where edges represent dependencies. Use topological sorting to calculate effective blooming times and then apply the same binary search logic.",
                                            "question": "What if the roses bloom asynchronously, with delays or dependencies?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearch_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_aggressivecows",
                                "problem_name": "Aggressive Cows",
                                "problem_slug": "aggressive-cows",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "IBM",
                                        "Square",
                                        "Texas Instruments",
                                        "Morgan Stanley",
                                        "MongoDB",
                                        "Visa",
                                        "Roche",
                                        "Rockstar Games",
                                        "Bungie",
                                        "AMD",
                                        "Walmart",
                                        "Lyft",
                                        "Broadcom",
                                        "Oracle",
                                        "Activision Blizzard",
                                        "Western Digital",
                                        "Freshworks",
                                        "Epic Games",
                                        "Splunk",
                                        "Nutanix",
                                        "Instacart",
                                        "Reddit",
                                        "Twilio",
                                        "Airbnb",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem and its underlying concept have practical applications in wireless communication, specifically in cell tower placement to provide maximum coverage with minimum interference. Given a certain number of towers (cows), the goal is to place them at specific locations (stalls) such that the minimum distance (signal interference) between any two towers is as large as possible, aiming for maximum signal strength and coverage.",
                                    "hints": [
                                        {
                                            "hint": "Start by sorting the positions of the stalls in ascending order. This ensures the stalls are in logical order for placing cows, simplifying the distance calculation."
                                        },
                                        {
                                            "hint": "\"Use binary search to find the maximum possible minimum distance. To check if k cows can be placed with a minimum distance of mid. Place the first cow in the first stall. For each subsequent stall, place a cow only if the distance from the last placed cow is mid. Count the total cows placed; if k, mid is feasible.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures the stalls are in sequential order, which is necessary to calculate the distance between adjacent stalls. Without sorting, the distance calculations would be incorrect, making placement infeasible.",
                                            "question": "Why sort the stalls?"
                                        },
                                        {
                                            "answer": "The feasibility function checks if it is possible to place k cows such that the minimum distance between any two cows is mid. This involves greedily placing cows in the stalls and counting how many can be placed.",
                                            "question": "What is the feasibility function?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If some stalls are unavailable, exclude them from the sorted list. Adjust the feasibility function to skip unavailable stalls during placement.",
                                            "question": "What if there are constraints on stall availability?"
                                        },
                                        {
                                            "answer": "Use a data structure like a balanced binary search tree to maintain the sorted order of stall positions dynamically. Update the tree and re-evaluate the feasibility function as stalls are added or removed.",
                                            "question": "How would you handle dynamic updates to the stalls?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_bookallocationproblem",
                                "problem_name": "Book Allocation Problem",
                                "problem_slug": "book-allocation-problem",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "HashiCorp",
                                        "Airbnb",
                                        "Ubisoft",
                                        "Wayfair",
                                        "JPMorgan Chase",
                                        "Red Hat",
                                        "Micron Technology",
                                        "Unity Technologies",
                                        "Alibaba",
                                        "Oracle",
                                        "Zomato",
                                        "Roche",
                                        "Zynga",
                                        "Reddit",
                                        "Cloudflare",
                                        "Epic Systems",
                                        "Stripe",
                                        "Walmart",
                                        "Broadcom",
                                        "Texas Instruments",
                                        "Square",
                                        "Medtronic",
                                        "ARM",
                                        "eBay",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem statement emphasizes the concept of load balancing, which is a crucial aspect of modern software infrastructure. In real-world scenarios, this could be applied in designing a system that evenly distributes network or computational tasks across a network of servers. As in this problem, we aim to minimize the maximum load handled by any single server, enhancing efficiency and preventing overloading. Similarly, content delivery networks, cloud-based services, and parallel computing often use these principles to optimize resources.",
                                    "hints": [
                                        {
                                            "hint": "Perform binary search to find the smallest feasible value of the maximum pages a student can be allocated."
                                        },
                                        {
                                            "hint": "\"To check if a given maximum mid pages is feasible: Traverse the array and allocate books to students while keeping the sum of pages for each student mid. If more than m students are required, mid is not feasible, and a higher maximum needs to be considered. Otherwise, mid is feasible.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Start with the first student and a running sum of pages. Add books until the sum exceeds mid, then allocate a new student. If the number of students exceeds m, return false. Otherwise, return true.",
                                            "question": "How is the feasibility function implemented?"
                                        },
                                        {
                                            "answer": "The lower bound max(nums) ensures that no student is assigned less than the largest book.\nThe upper bound sum(nums) represents the scenario where one student gets all the books.",
                                            "question": "What is the significance of max(nums) and sum(nums) as bounds?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Incorporate the reading capacities into the feasibility function by limiting the maximum pages each student can handle. Adjust the binary search accordingly to account for these constraints.",
                                            "question": "What if the students have varying reading capacities?"
                                        },
                                        {
                                            "answer": "For dynamic updates, maintain a prefix sum array of book pages. Use this to quickly calculate the total pages in any contiguous subarray, speeding up feasibility checks.",
                                            "question": "What if the number of books or students changes dynamically?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_findpeakelement",
                                "problem_name": "Find peak element",
                                "problem_slug": "find-peak-element",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Epic Games",
                                        "Dropbox",
                                        "PwC",
                                        "Square",
                                        "Nutanix",
                                        "Ubisoft",
                                        "Alibaba",
                                        "Philips Healthcare",
                                        "Broadcom",
                                        "Intel",
                                        "Oracle",
                                        "Chewy",
                                        "Docker",
                                        "Mastercard",
                                        "IBM",
                                        "Optum",
                                        "Morgan Stanley",
                                        "Epic Systems",
                                        "Bloomberg",
                                        "Seagate Technology",
                                        "Roblox",
                                        "Qualcomm",
                                        "GE Healthcare",
                                        "Airbnb",
                                        "Flipkart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem or its underlying concept is commonly utilized in Data Analysis and Financial sectors. For example, in Stock Market Analysis, peak detection is critical in identifying patterns and trends, especially in time series data. When visualizing stock prices, a \"peak\" would represent a maximum point (local maxima) before prices drop, or in other words, an optimal sell point. Thus, efficient algorithms for identifying \"peaks\" from array-like data are crucial for decision-making processes in these areas. This gives a real-world importance to such a seemingly theoretical problem.",
                                    "hints": [
                                        {
                                            "hint": "You can find a peak in O(logn) using binary search"
                                        },
                                        {
                                            "hint": "\"If an element is not a peak, at least one of its neighbors is greater. This ensures that moving toward the greater neighbor will lead to a peak. The problem guarantees at least one peak exists, so binary search always converges to a peak.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the middle element is at the start (arr[0]) or end (arr[n1]) of the array, compare it with its only neighbor. Binary search adapts to these cases seamlessly.",
                                            "question": "How does the algorithm handle edge indices?"
                                        },
                                        {
                                            "answer": "Peaks are defined based on strict inequality, so duplicates may break the guarantee of finding a peak at some points. However, the algorithm will still find a valid peak if one exists.",
                                            "question": "What happens if the array has duplicates?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a linear scan to check each element and its neighbors. Record all indices where arr[i1]<arr[i]>arr[i+1]. This increases the complexity to O(n).",
                                            "question": "How would you modify the algorithm to find all peaks?"
                                        },
                                        {
                                            "answer": "Find all peaks and sort them by their values. This is useful in applications like optimization or ranking tasks where the relative height of peaks matters.",
                                            "question": "What if the peaks need to be ranked by their values?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_medianof2sortedarrays",
                                "problem_name": "Median of 2 sorted arrays",
                                "problem_slug": "median-of-2-sorted-arrays",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "Visa",
                                        "Target",
                                        "American Express",
                                        "Lyft",
                                        "Bungie",
                                        "Micron Technology",
                                        "Roche",
                                        "Ubisoft",
                                        "Alibaba",
                                        "Snowflake",
                                        "Ernst & Young",
                                        "Riot Games",
                                        "Reddit",
                                        "IBM",
                                        "Splunk",
                                        "Pinterest",
                                        "Etsy",
                                        "Unity Technologies",
                                        "Salesforce",
                                        "KPMG",
                                        "Western Digital",
                                        "Stripe",
                                        "Zomato",
                                        "Walmart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: In real-world software applications, finding the median of two sorted arrays is commonly used in statistical computations and data analysis. In particular, it is heavily used in big data processing where two different data sets need to be combined and subsequently analyzed, such as combining user behavior data from different servers or databases. Furthermore, the concept behind this problem is leveraged in creating recommendation engines where statistical calculations play an imperative role in predicting user preferences based on different datasets. So, next time when Netflix recommends you a movie, remember, the solutions of such programming problems might be working behind the scenes!",
                                    "hints": [
                                        {
                                            "hint": "Instead of merging the arrays fully, focus only on locating the required middle element(s)."
                                        },
                                        {
                                            "hint": "Divide both arrays into two halves such that the left halves contain the smaller elements and the right halves contain the larger elements."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Binary search works regardless of the sizes of the arrays. The smaller array is chosen for the binary search to ensure efficiency, reducing the time complexity to O(log(min(m,n))).",
                                            "question": "What if the arrays have different sizes?"
                                        },
                                        {
                                            "answer": "Special conditions handle scenarios like:\npartitionX=0: All elements in the left partition come from arr2.\npartitionX=m: All elements in the right partition come from arr2.",
                                            "question": "How does the algorithm ensure correctness for edge cases?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For k sorted arrays, use a priority queue (min-heap) to merge them while keeping track of their elements. After merging, compute the median in O(klogk+n).",
                                            "question": "Can this approach be extended to more than two arrays?"
                                        },
                                        {
                                            "answer": "The algorithm handles duplicates naturally. The median is determined based on the partitioned halves, irrespective of repeated values.",
                                            "question": "What if the arrays contain duplicates?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_minimisemaxdistancetogasstations",
                                "problem_name": "Minimise max distance to gas stations",
                                "problem_slug": "minimise-max-distance-to-gas-stations",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "Alibaba",
                                        "Broadcom",
                                        "Zynga",
                                        "Shopify",
                                        "Docker",
                                        "MongoDB",
                                        "Electronic Arts",
                                        "Chewy",
                                        "American Express",
                                        "Zomato",
                                        "Deloitte",
                                        "Splunk",
                                        "Snowflake",
                                        "Epic Games",
                                        "Seagate Technology",
                                        "HCL Technologies",
                                        "Activision Blizzard",
                                        "Epic Systems",
                                        "Intel",
                                        "NVIDIA",
                                        "Robinhood",
                                        "Oracle",
                                        "Micron Technology",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem embodies the concept of binary search, which can be used in real-life application route planning software. Tools like Google Maps, Waze or Apple Maps often have to solve similar problems when determining optimal locations for refueling or rest stops during a trip. The goal is to minimize the longest distance between stops, ensuring that the user's gas tank doesn't run out. Therefore, developers of such apps need to design and implement efficient algorithms to provide the best service to their users.",
                                    "hints": [
                                        {
                                            "hint": "For a given dist, calculate the number of new gas stations required to ensure that no gap exceeds dist. Sum the required gas stations across all gaps. If the total gas stations required is less than or equal to k, the given dist is feasible."
                                        },
                                        {
                                            "hint": "\"If dist is feasible (i.e., the required gas stations k), search for a smaller dist (high=mid). If dist is not feasible, search for a larger dist (low=mid+), where  ensures precision for floating-point values.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since gas stations can be placed at non-integer positions, floating-point arithmetic is used. The binary search stops when the range of possible dist values is smaller than a specified precision ().",
                                            "question": "How does floating-point precision affect the solution?"
                                        },
                                        {
                                            "answer": "If there is only one gas station (n=1), the gap is undefined. Any additional gas stations can be placed arbitrarily, making dist depend only on their positions.\n",
                                            "question": "What if the array has fewer than two gas stations?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If new stations must be placed at predefined positions (e.g., integer locations), modify the feasibility check to only consider those positions and adjust the binary search accordingly.",
                                            "question": "What if gas stations cannot be placed at arbitrary positions?"
                                        },
                                        {
                                            "answer": "For dynamic updates, maintain a sorted list of gas station positions. Use efficient data structures like balanced binary search trees to dynamically insert or remove stations and recompute dist.",
                                            "question": "How would you handle dynamic updates (e.g., removing stations)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_kthelementof2sortedarrays",
                                "problem_name": "Kth element of 2 sorted arrays",
                                "problem_slug": "kth-element-of-2-sorted-arrays",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "Flipkart",
                                        "Unity Technologies",
                                        "Etsy",
                                        "DoorDash",
                                        "eBay",
                                        "Wayfair",
                                        "Stripe",
                                        "Walmart",
                                        "Western Digital",
                                        "OYO Rooms",
                                        "Ernst & Young",
                                        "Red Hat",
                                        "ARM",
                                        "Electronic Arts",
                                        "Zomato",
                                        "Uber",
                                        "Nutanix",
                                        "PwC",
                                        "Alibaba",
                                        "Epic Games",
                                        "Docker",
                                        "Rockstar Games",
                                        "Epic Systems",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One fun fact related to this problem is its use in database management systems, particularly in operations such as merge and join. Companies that deal with large amounts of data (like Google, Facebook, or Amazon) often need to perform operations on sorted data from different sources or databases. By optimizing solutions to problems like this, they can ensure more efficient data retrieval, impacting overall system performance.",
                                    "hints": [
                                        {
                                            "hint": "\"At each step, calculate the partition indices for both arrays: Let i be the number of elements taken from array a, so j=ki elements are taken from array b.\""
                                        },
                                        {
                                            "hint": "Ensure that the largest element in the left half is less than or equal to the smallest element in the right half. If valid, the k-th element is the maximum of the last element in the left half"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Merging the arrays requires O(m+n) time and space. The binary search approach avoids the full merge and works in O(log(min(m,n))), which is significantly faster and more efficient.",
                                            "question": "Why not merge the arrays to find the k-th element?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For k-th element across multiple sorted arrays:\nUse a min-heap to track the smallest elements from each array. Extract k-1 elements from the heap to find the k-th smallest.\nComplexity: O(klog(numberofarrays)).",
                                            "question": "How would you extend this to more than two arrays?"
                                        },
                                        {
                                            "answer": "If the arrays are unsorted, sort them first (O(mlogm+nlogn)), then apply the same binary search logic. Sorting adds preprocessing overhead but ensures correctness.",
                                            "question": "What if the arrays are unsorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_faqs_splitarray-largestsum",
                                "problem_name": "Split array - largest sum",
                                "problem_slug": "split-array---largest-sum",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Siemens Healthineers",
                                        "Splunk",
                                        "Airbnb",
                                        "Optum",
                                        "Ernst & Young",
                                        "Robinhood",
                                        "Reddit",
                                        "Seagate Technology",
                                        "Roche",
                                        "Rockstar Games",
                                        "Alibaba",
                                        "AMD",
                                        "Walmart",
                                        "MongoDB",
                                        "Rakuten",
                                        "Qualcomm",
                                        "GE Healthcare",
                                        "Etsy",
                                        "Deloitte",
                                        "Electronic Arts",
                                        "IBM",
                                        "Epic Games",
                                        "Broadcom",
                                        "NVIDIA",
                                        "Freshworks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem reflects a practical problem in load balancing concept in distributed computing. A common task in managing a distributed system is distributing workload evenly across machines. This is a form of the problem where each machine is a subarray and the load is represented by the sum of the elements in the subarray. For optimum load balancing, the goal is to minimize the largest sum across all machines. This is necessary to ensure no single machine is overwhelmed with too much work while others are idle, thereby maximizing system efficiency and performance.",
                                    "hints": [
                                        {
                                            "hint": "Use binary search to find the smallest possible value of the maximum subarray sum."
                                        },
                                        {
                                            "hint": "\"If mid is feasible (subarrays can be formed with a maximum sum mid), search for a smaller maximum sum (high=mid). If mid is not feasible, search for a larger maximum sum (low=mid+1).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Testing all possible splits is computationally expensive (O(2^n)). Binary search narrows the range of possible sums, reducing the complexity to O(nlog(sum(a)max(a))).",
                                            "question": "Why use binary search to minimize the largest sum?"
                                        },
                                        {
                                            "answer": "Traverse the array and form subarrays:\nAdd elements to the current subarray until adding another element would exceed mid.\nStart a new subarray and increment the subarray count.\nIf the subarray count exceeds k, mid is not feasible.",
                                            "question": "How is the feasibility of mid checked?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For dynamic scenarios, maintain a prefix sum array to quickly recompute sums. Apply the binary search logic on the updated prefix sum.",
                                            "question": "Can this approach handle dynamic updates to the array?"
                                        },
                                        {
                                            "answer": "Modify the feasibility check to account for the maximum allowed subarray length. Ensure that the number of elements in each subarray does not exceed the constraint during the traversal.",
                                            "question": "How would you handle additional constraints, like maximum subarray length?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearch_2darrays",
                        "subcategory_name": "2D Arrays",
                        "subcategory_slug": "2d-arrays",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_2darrays_findrowwithmaximum1's",
                                "problem_name": "Find row with maximum 1's",
                                "problem_slug": "find-row-with-maximum-1's",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Alibaba",
                                        "JPMorgan Chase",
                                        "PwC",
                                        "Ernst & Young",
                                        "Roblox",
                                        "Zoho",
                                        "Philips Healthcare",
                                        "Salesforce",
                                        "Robinhood",
                                        "Uber",
                                        "GE Healthcare",
                                        "Visa",
                                        "ARM",
                                        "Cloudflare",
                                        "Wayfair",
                                        "Square",
                                        "Riot Games",
                                        "Epic Games",
                                        "DoorDash",
                                        "Optum",
                                        "Intel",
                                        "Epic Systems",
                                        "McKinsey & Company",
                                        "Docker",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One real-world application of this problem can be found in Image Processing. Notably, in the case of binary images, which consists solely of 1s (indicating white pixels) and 0s (indicating black pixels). By finding the row with the most white pixels (1s), certain characteristics of the image can be determined, such as the location of an object within the image. This concept is at the heart of many computer vision tasks that form the basis for features like facial recognition in apps like Facebook and Snapchat.",
                                    "hints": [
                                        {
                                            "hint": "\"Since rows are sorted, the first 1 in a row determines the count of 1s. If a row contains n columns and the first 1 appears at index j, then the count of 1s in that row is nj.\""
                                        },
                                        {
                                            "hint": "For each row, use binary search to find the index of the first 1. Keep track of the row with the maximum number of 1s as you iterate through the grid."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Counting 1s in each row requires O(nm), where n is the number of rows and m is the number of columns. By leveraging sorting properties, you can reduce the complexity.",
                                            "question": "Why not just count the 1s in each row directly?"
                                        },
                                        {
                                            "answer": "If multiple rows have the same number of 1s, return the smallest row index. Both binary search and column traversal naturally ensure this.",
                                            "question": "What happens if all rows have the same number of 1s?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If rows are unsorted, sort each row first (O(nmlogm)) and then apply the same logic.\nAlternatively, scan each row to count 1s directly, which takes O(nm).",
                                            "question": "What if the grid is not sorted?"
                                        },
                                        {
                                            "answer": "For higher-dimensional grids (e.g., 3D matrices), flatten the grid along one dimension (e.g., rows or columns) and apply the same logic.",
                                            "question": "Can this logic extend to multidimensional grids?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_2darrays_searchina2dmatrix",
                                "problem_name": "Search in a 2D matrix",
                                "problem_slug": "search-in-a-2d-matrix",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Pinterest",
                                        "Square",
                                        "Docker",
                                        "Airbnb",
                                        "Bloomberg",
                                        "Ernst & Young",
                                        "Robinhood",
                                        "Epic Games",
                                        "Mastercard",
                                        "IBM",
                                        "American Express",
                                        "McKinsey & Company",
                                        "Dropbox",
                                        "HCL Technologies",
                                        "Lyft",
                                        "Chewy",
                                        "Intel",
                                        "PayPal",
                                        "Medtronic",
                                        "Seagate Technology",
                                        "Ubisoft",
                                        "Freshworks",
                                        "ARM",
                                        "Flipkart",
                                        "Siemens Healthineers",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is essentially a form of sorted matrix search, a concept widely applied in database querying systems and search engines. When handling large volumes of data arranged in a sorted format (like timestamps/logs), efficient searching algorithms are critical for performance. Applications like Google, where millions of search queries are performed each second, need to effectively implement algorithms similar to this problem in their infrastructure. These systems frequently use multi-dimensional arrays (matrices) for quicker access and traversal, hence the significance of such problems.",
                                    "hints": [
                                        {
                                            "hint": "Treat the matrix as a 1D array with indices ranging from 0 to mn1, where m is the number of rows and n is the number of columns."
                                        },
                                        {
                                            "hint": "Map the 1D index mid to a 2D position using: row=mid/n, col=mid%n"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Treating the matrix as a 1D array enables a single binary search over the entire dataset, reducing complexity from O(mlogn) to O(log(mn)).",
                                            "question": "Why treat the matrix as a virtual 1D array?"
                                        },
                                        {
                                            "answer": "The algorithm works seamlessly with duplicates. It returns True for the first occurrence of the target encountered during the search.",
                                            "question": "How does this approach handle duplicates?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the algorithm to return the 2D index of the target (row,col) when found, or 1 if the target does not exist.",
                                            "question": "What if the target needs to be located instead of just checking its presence?"
                                        },
                                        {
                                            "answer": "For higher-dimensional arrays:\nFlatten the array into a 1D structure and apply binary search.\nUse modular arithmetic to map 1D indices to multi-dimensional coordinates.",
                                            "question": "Can this approach be extended to 3D or higher-dimensional arrays?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_2darrays_searchin2dmatrix-ii",
                                "problem_name": "Search in 2D matrix - II",
                                "problem_slug": "search-in-2d-matrix-ii",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Texas Instruments",
                                        "Shopify",
                                        "GE Healthcare",
                                        "Medtronic",
                                        "Nutanix",
                                        "Optum",
                                        "Freshworks",
                                        "Oracle",
                                        "HCL Technologies",
                                        "Unity Technologies",
                                        "Chewy",
                                        "Cerner",
                                        "Etsy",
                                        "Riot Games",
                                        "Deloitte",
                                        "Instacart",
                                        "Splunk",
                                        "Flipkart",
                                        "Rakuten",
                                        "Dropbox",
                                        "Philips Healthcare",
                                        "Bain & Company",
                                        "Zynga",
                                        "Target",
                                        "Red Hat",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is at the heart of many search engines, like Google Maps or Yelp, where a ton of geospatial data exists with specific sorting around latitude (rows) and longitude (columns). The restaurants, shops, or other points of interests are looked up efficiently, similar to searching for a target in a 2D matrix. Adopting a 2D array matrix search optimization like this can significantly speed up the search and improve the user interaction experience.",
                                    "hints": [
                                        {
                                            "hint": "Start at the top-right corner as it provides a vantage point: Moving left reduces the value. Moving down increases the value."
                                        },
                                        {
                                            "hint": "Perform binary search on each row to find the target. If the target may be present in multiple rows, narrow the search space by limiting to rows where row[0]targetrow[n1]."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Starting at the top-right corner simplifies the search logic:\nYou can directly move left or down based on comparisons.\nOther corners (e.g., bottom-left) also work but reverse the movement logic.",
                                            "question": "Why use the top-right corner for the search?"
                                        },
                                        {
                                            "answer": "Yes, duplicates do not affect the algorithm because the search is based on comparisons with the target, not the uniqueness of values.",
                                            "question": "Can this approach handle duplicate values in the matrix?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Keep track of the current candidate for the smallest element larger than the target while moving through the matrix.\nUse a modified version of the search logic to update the candidate whenever a larger element is encountered.",
                                            "question": "How would you find the smallest element larger than the target?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_2darrays_findpeakelement-dup",
                                "problem_name": "Find Peak Element",
                                "problem_slug": "find-peak-element-ii",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "Target",
                                        "American Express",
                                        "Mastercard",
                                        "Snowflake",
                                        "Zoho",
                                        "MongoDB",
                                        "Goldman Sachs",
                                        "Byju's",
                                        "Nutanix",
                                        "Optum",
                                        "Rakuten",
                                        "Electronic Arts",
                                        "KPMG",
                                        "HCL Technologies",
                                        "Deloitte",
                                        "Rockstar Games",
                                        "Roche",
                                        "Bungie",
                                        "Ubisoft",
                                        "Bain & Company",
                                        "Red Hat",
                                        "Riot Games",
                                        "Reddit",
                                        "Freshworks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem statement to find a peak element in a 2D grid can be seen as a core concept behind many terrain mapping systems in software like geographic information systems (GIS). In these scenarios, different altitudes can be represented as different values in the matrix, a 'peak' would represent the highest point in surrounding region (like a hill or mountain). Algorithms for finding such peak elements are crucial when it comes to features like terrain visualization, path planning or shortest path computations in uneven landscapes.",
                                    "hints": [
                                        {
                                            "hint": "For a given column or row, find the global maximum and compare it with its adjacent elements in the matrix."
                                        },
                                        {
                                            "hint": "\"Start by selecting the middle column (mid) of the matrix. Find the row index of the maximum element in that column. Compare this element with its left and right neighbors: If it is greater than its neighbors, it is a peak. If a neighbor is greater, move to the left or right half of the columns based on the larger neighbor and repeat the process.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Traverse the column or row once to find the index of the largest element (O(n) or O(m)), which is much faster than scanning the entire matrix.",
                                            "question": "How is the global maximum in a column or row found efficiently?"
                                        },
                                        {
                                            "answer": "The outer perimeter of 1 ensures that any element on the matrix boundary can be a peak if it is larger than its neighbors.",
                                            "question": "What if the peak lies at the boundary of the matrix?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the comparison condition to include equality. The algorithm remains the same, but more elements may qualify as peaks.",
                                            "question": "How would you handle non-strict peaks (i.e.,  neighbors)?"
                                        },
                                        {
                                            "answer": "A brute-force approach iterating over all elements is required. However, for large matrices, you can parallelize this computation or use divide-and-conquer techniques to find peaks in chunks.",
                                            "question": "How would you find all peaks in the matrix?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_2darrays_matrixmedian",
                                "problem_name": "Matrix Median",
                                "problem_slug": "matrix-median",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Optum",
                                        "Wayfair",
                                        "Riot Games",
                                        "Mastercard",
                                        "Electronic Arts",
                                        "Ernst & Young",
                                        "Docker",
                                        "McKinsey & Company",
                                        "Zynga",
                                        "Micron Technology",
                                        "IBM",
                                        "Zoho",
                                        "Roche",
                                        "Western Digital",
                                        "Etsy",
                                        "eBay",
                                        "NVIDIA",
                                        "Philips Healthcare",
                                        "Twilio",
                                        "PayPal",
                                        "Boston Consulting Group",
                                        "Dropbox",
                                        "Square",
                                        "Rakuten",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "In the field of image processing and computer graphics, a similar problem is frequently encountered. Pixels of an image are typically represented as a 2D matrix. Operations like median filtering, which involves finding the median of a submatrix or neighborhood of pixels, are applied to remove 'salt and pepper' noise from images while keeping the edges intact. Hence, understanding how to efficiently compute the median of a 2D matrix is crucial in these areas.",
                                    "hints": [
                                        {
                                            "hint": "Adjust the binary search range based on whether the count is greater or less than the desired position of the median."
                                        },
                                        {
                                            "hint": "\"Since each row is sorted, count the number of elements mid efficiently for each row using binary search (O(logm) per row). Sum the counts for all rows to get the total number of elements  mid.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use binary search for each row to count elements mid.\nFor a sorted row, the count is the index of the first element >mid, which can be found in O(logm).",
                                            "question": "How do we count elements mid efficiently?"
                                        },
                                        {
                                            "answer": "For matrices with variable row lengths, ensure that binary search skips empty rows and counts only valid elements. The logic remains unchanged.",
                                            "question": "What if the matrix has uneven row lengths?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Combine all matrices and find the median using a priority queue (min-heap) to maintain the smallest k elements while iterating through the rows.",
                                            "question": "What if we need the median of multiple matrices?"
                                        },
                                        {
                                            "answer": "Maintain a streaming median using two heaps (min-heap and max-heap) to balance elements dynamically as new rows arrive.",
                                            "question": "What if the median needs to be computed in real-time?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearch_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 6,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "binarysearch_binarysearch_contest_cleaningwindows",
                                "problem_name": "Cleaning Windows",
                                "problem_slug": "cleaning-windows",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_contest_neighbourswithinkdistance",
                                "problem_name": "Neighbours within k distance",
                                "problem_slug": "neighbours-within-k-distance",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearch_binarysearch_contest_z-score",
                                "problem_name": "Z-Score",
                                "problem_slug": "z-score",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "recursion",
                "category_name": "Recursion",
                "category_slug": "recursion",
                "category_rank": 5,
                "subcategories": [
                    {
                        "subcategory_id": "recursion_implementation",
                        "subcategory_name": "Implementation Problems",
                        "subcategory_slug": "implementation-problems",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "recursion_recursion_implementation_pow(x,n)",
                                "problem_name": "Pow(x,n)",
                                "problem_slug": "pow(x,n)",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Siemens Healthineers",
                                        "PwC",
                                        "Ubisoft",
                                        "Bloomberg",
                                        "Zynga",
                                        "Cloudflare",
                                        "Deloitte",
                                        "GE Healthcare",
                                        "Philips Healthcare",
                                        "Goldman Sachs",
                                        "Robinhood",
                                        "Zomato",
                                        "Roche",
                                        "Medtronic",
                                        "Chewy",
                                        "Western Digital",
                                        "Cerner",
                                        "Salesforce",
                                        "Etsy",
                                        "Databricks",
                                        "Square",
                                        "DoorDash",
                                        "Morgan Stanley",
                                        "Splunk",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "In Google's search algorithm, the concept of power function comes into play. This algorithm named PageRank, uses power iteration methodology to calculate the ranks of pages. The basic idea is to count the number and quality of links to a page to determine a rough estimate of how important the page is. The underlying assumption is that more important pages are likely to receive more links from other websites. Thus, a mathematically defined multiple number of iterations (x raised to n) helps in providing more precise page rankings.",
                                    "hints": [
                                        {
                                            "hint": "Use Exponentiation by Squaring, which reduces the time complexity to O(logn)"
                                        },
                                        {
                                            "hint": "\"Iterative: Avoids stack overflow and is more memory-efficient (O(1) space). Recursive: Cleaner and simpler code, but uses O(logn) space due to recursion.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "For negative n, the result is 1/x^n. Compute xn as if n were positive, then take the reciprocal.",
                                            "question": "What happens if n<0?"
                                        },
                                        {
                                            "answer": "Iterative implementation uses constant space (O(1)) and avoids stack overflow for large n. This makes it more robust for competitive programming scenarios.\n",
                                            "question": "Why is iterative implementation preferred in competitive programming?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use the formula ((amodm)(bmodm))modm at each step to keep intermediate results within bounds.\nModular exponentiation is widely used in cryptography and number theory.",
                                            "question": "How would you modify this algorithm for modular exponentiation ((x^n)modm)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_implementation_generateparanthesis",
                                "problem_name": "Generate Paranthesis",
                                "problem_slug": "generate-paranthesis",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Texas Instruments",
                                        "DoorDash",
                                        "Lyft",
                                        "Philips Healthcare",
                                        "PayPal",
                                        "Splunk",
                                        "Rakuten",
                                        "Zomato",
                                        "Etsy",
                                        "Walmart",
                                        "American Express",
                                        "Flipkart",
                                        "Stripe",
                                        "KPMG",
                                        "Siemens Healthineers",
                                        "Zoho",
                                        "Intel",
                                        "Uber",
                                        "Epic Systems",
                                        "Unity Technologies",
                                        "Boston Consulting Group",
                                        "Bungie",
                                        "Cerner",
                                        "Freshworks",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The concept behind well-formed parentheses is key in developing various software tools, especially in language parsing libraries and compilers. Programmers often deal with nested structures like functions, loops, and conditionals in coding, which are represented using parentheses, braces, etc. The formation or validation of these correctly structured parentheses and other symbols is of utmost importance for the correct interpretation of the code. Similarly, tools for checking the validity of XML or JSON also use this concept to ensure the correct pairing and nesting of tags and braces.",
                                    "hints": [
                                        {
                                            "hint": "Start with an empty string and keep adding ( or ) recursively. If the string has 2n characters, add it to the result."
                                        },
                                        {
                                            "hint": "Use a backtracking approach where you explore all possibilities and backtrack when the current combination is invalid."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use two counters to track the number of ( and ) added:\nAdd ( only if ( count < n.\nAdd ) only if ) count < ( count.",
                                            "question": "How do you ensure that the combinations are valid?"
                                        },
                                        {
                                            "answer": "The base case is when the length of the current combination reaches 2n. At this point, the combination is added to the result list.",
                                            "question": "What is the base case for recursion?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, use a stack to simulate the backtracking process. Push intermediate states onto the stack and pop them as you explore combinations.",
                                            "question": "Can this problem be solved iteratively instead of recursively?"
                                        },
                                        {
                                            "answer": "Modify the algorithm to handle multiple types of brackets. Track counts for each type separately and ensure valid nesting.",
                                            "question": "How would you extend this for other types of brackets (e.g., {}, [])?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_implementation_powerset",
                                "problem_name": "Power Set",
                                "problem_slug": "power-set",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Dropbox",
                                        "Red Hat",
                                        "Swiggy",
                                        "Bain & Company",
                                        "Roche",
                                        "Zynga",
                                        "Nutanix",
                                        "Morgan Stanley",
                                        "Freshworks",
                                        "Visa",
                                        "MongoDB",
                                        "Seagate Technology",
                                        "Bloomberg",
                                        "Bungie",
                                        "Optum",
                                        "Boston Consulting Group",
                                        "Micron Technology",
                                        "Splunk",
                                        "HCL Technologies",
                                        "Activision Blizzard",
                                        "DoorDash",
                                        "Philips Healthcare",
                                        "Riot Games",
                                        "JPMorgan Chase",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "The problem of finding all possible subsets from a set, also known as the power set, is an important concept in many areas of software development. In database technologies, such as SQL, this concept is used in designing queries that require combinations of data, such as generating all combinations of products that can be bundled together. In Machine Learning, power sets are used in feature selection, where combinations of different features are tested to see which set gives the best predictive accuracy. Meanwhile in Software Testing, generating all possible subsets of a feature set aids in creating exhaustive test cases which helps find potential bugs or issues.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to build subsets by deciding for each element whether to include it in the current subset."
                                        },
                                        {
                                            "hint": "\"At each recursive step: Add the current subset to the result. Recursively add subsets including the next element.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The problem guarantees that nums contains unique elements, so duplicates will not arise during subset generation.",
                                            "question": "How do you ensure no duplicates are included?"
                                        },
                                        {
                                            "answer": "The order of elements in subsets follows the input array's order. If specific ordering is required, sort the array before generating subsets.",
                                            "question": "How do subsets handle ordering?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a backtracking approach with a constraint that the subset's size equals k.",
                                            "question": "How would you modify this to generate subsets of a fixed size k?"
                                        },
                                        {
                                            "answer": "Sort the array first, then skip duplicate elements during subset generation to avoid redundant subsets. This ensures unique combinations.",
                                            "question": "What if duplicates are allowed in the input array?"
                                        },
                                        {
                                            "answer": "Represent subsets using binary strings, where each bit indicates whether an element is included. This is useful in optimization problems where subsets must be encoded compactly.",
                                            "question": "What are alternative representations of subsets?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "recursion_subsequencepatternproblems",
                        "subcategory_name": "Subsequence Pattern Problems",
                        "subcategory_slug": "subsequence-pattern-problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "recursion_recursion_subsequencepatternproblems_countallsubsequenceswithsumk",
                                "problem_name": "Count all subsequences with sum K",
                                "problem_slug": "count-all-subsequences-with-sum-k",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Teladoc Health",
                                        "Roblox",
                                        "Airbnb",
                                        "Rockstar Games",
                                        "MongoDB",
                                        "OYO Rooms",
                                        "Oracle",
                                        "Boston Consulting Group",
                                        "DoorDash",
                                        "Optum",
                                        "Rakuten",
                                        "Snowflake",
                                        "Databricks",
                                        "Bain & Company",
                                        "Shopify",
                                        "Square",
                                        "Byju's",
                                        "Chewy",
                                        "Cloudflare",
                                        "Riot Games",
                                        "Bungie",
                                        "AMD",
                                        "Lyft",
                                        "Stripe",
                                        "PayPal",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The \"sum of subsequence equals K\" problem concept has a broad range of applications. It is primarily used in financial software for portfolio optimization and risk management. For example, an investor may want to find all combinations of stocks (subsequences from an array of available stocks) that result in a specific target return (sum equals to K). Optimizing and streamlining this process can result in substantial investment efficiency. It is also used in budgeting apps for determining possible allocations of available resources to achieve a financial goal.",
                                    "hints": [
                                        {
                                            "hint": "Use a boolean DP array dp where dp[j] represents whether a subset with sum j can be formed."
                                        },
                                        {
                                            "hint": "\"Recursively explore all combinations of elements: Either include the current element in the subset or skip it. If the sum equals k at any point, return True.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The DP array tracks all possible subset sums that can be formed using elements seen so far. If dp[k] is True, it means a subset with sum k exists.",
                                            "question": "How does the DP array work?"
                                        },
                                        {
                                            "answer": "If k>sum(nums), it is impossible to find a subset with sum k. The algorithm naturally returns False in such cases.",
                                            "question": "What happens if k is larger than the sum of nums?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use backtracking to generate all subsets, and collect those with a sum of k. This can be more computationally intensive than checking for existence.",
                                            "question": "How would you modify this to find all subsets with sum k?"
                                        },
                                        {
                                            "answer": "Flatten the array and apply the same logic. For multi-dimensional constraints, modify the DP approach to include more states.",
                                            "question": "Can this be extended to multi-dimensional arrays?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_subsequencepatternproblems_checkifthereexistsasubsequencewithsumk",
                                "problem_name": "Check if there exists a subsequence with sum K",
                                "problem_slug": "check-if-there-exists-a-subsequence-with-sum-k",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "JPMorgan Chase",
                                        "Intel",
                                        "MongoDB",
                                        "Bain & Company",
                                        "IBM",
                                        "Epic Systems",
                                        "Wayfair",
                                        "Databricks",
                                        "Boston Consulting Group",
                                        "Docker",
                                        "Epic Games",
                                        "Micron Technology",
                                        "Roche",
                                        "Robinhood",
                                        "Unity Technologies",
                                        "Activision Blizzard",
                                        "Visa",
                                        "Optum",
                                        "Stripe",
                                        "Bloomberg",
                                        "Twilio",
                                        "DoorDash",
                                        "Freshworks",
                                        "Byju's",
                                        "AMD",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: Checking if a subsequence sums to a given value is a core problem in the development of financial software, particularly in portfolio management and risk analysis. By defining \"nums\" as investment returns and \"k\" as a desired return, this approach can help determine potential combinations of investments that could achieve a particular financial goal. Similarly, it's also used in encryption and decoding algorithms in cyber security, which is quite imperative for maintaining data integrity and confidentiality.",
                                    "hints": [
                                        {
                                            "hint": "Explore all possible subsequences recursively and count the valid ones where the sum equals k. Use a DP table where dp[j] represents the number of subsequences with sum j."
                                        },
                                        {
                                            "hint": "Use recursion to explore all subsequences:Count the number of valid subsequences where the sum equals k."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The DP table tracks how many subsequences can form a specific sum. For each element num, it updates possible sums to include subsequences containing num.",
                                            "question": "How does the DP table work?"
                                        },
                                        {
                                            "answer": "If k is greater than the sum of all elements in nums, return 0 immediately, as no subsequence can achieve that sum.",
                                            "question": "What if k>sum(nums)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the DP array or backtracking condition to include sums within the tolerance range.",
                                            "question": "How would you handle approximate sums (e.g., sumktolerance)?"
                                        },
                                        {
                                            "answer": "Use backtracking to collect all subsequences with sum k. Append valid subsequences to a result list instead of just counting them.",
                                            "question": "How would you modify this to return the subsequences instead of the count?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "recursion_faqs",
                        "subcategory_name": "FAQs (Medium)",
                        "subcategory_slug": "faqs-medium",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "recursion_recursion_faqs_combinationsum",
                                "problem_name": "Combination Sum",
                                "problem_slug": "combination-sum",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "JPMorgan Chase",
                                        "Mastercard",
                                        "Cerner",
                                        "Broadcom",
                                        "PayPal",
                                        "Shopify",
                                        "Snowflake",
                                        "Walmart",
                                        "Intel",
                                        "Boston Consulting Group",
                                        "Stripe",
                                        "Dropbox",
                                        "Philips Healthcare",
                                        "Morgan Stanley",
                                        "KPMG",
                                        "Byju's",
                                        "Unity Technologies",
                                        "Databricks",
                                        "Visa",
                                        "Pinterest",
                                        "Robinhood",
                                        "Ubisoft",
                                        "Wayfair",
                                        "Optum",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a classic demonstration of combinatorial search and dynamic programming, and it's often encountered in real-world scenarios, especially in e-commerce and budgeting-oriented applications. For example, given a budget, we might want to find all combinations of products (represented by their prices) that would total up to the budget. The problem also relates to other cases such as coin change problems, which are popular in coding interviews, and are used behind the scenes in ATM and cash transactions, to provide the fewest possible number of coins or bills.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to explore all combinations of numbers: Include the current number and subtract it from the target. Skip the current number and move to the next candidate."
                                        },
                                        {
                                            "hint": "Start each recursive call with the current index to avoid revisiting previous elements and prevent duplicate combinations."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In backtracking, allow the recursive call to revisit the same index to include the current candidate multiple times. Move to the next index only when the candidate is skipped.",
                                            "question": "How do you handle unlimited usage of a candidate?"
                                        },
                                        {
                                            "answer": "Sorting ensures that candidates are processed in ascending order. This allows early termination of branches when the target becomes smaller than the current candidate.",
                                            "question": "How does sorting the candidates help?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the recursive function to move to the next index after including the current candidate. This prevents reusing a candidate multiple times.",
                                            "question": "What if candidates can only be used once?"
                                        },
                                        {
                                            "answer": "For large targets, reduce the problem size using memoization to cache results for previously computed targets. This avoids redundant computations.",
                                            "question": "How would you handle large values of target?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs_combinationsumii",
                                "problem_name": "Combination Sum II",
                                "problem_slug": "combination-sum-ii",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Broadcom",
                                        "American Express",
                                        "Epic Systems",
                                        "Teladoc Health",
                                        "eBay",
                                        "NVIDIA",
                                        "Bain & Company",
                                        "Uber",
                                        "Western Digital",
                                        "Snowflake",
                                        "DoorDash",
                                        "Morgan Stanley",
                                        "Stripe",
                                        "Lyft",
                                        "HashiCorp",
                                        "Red Hat",
                                        "Instacart",
                                        "Splunk",
                                        "Chewy",
                                        "IBM",
                                        "Philips Healthcare",
                                        "Roblox",
                                        "MongoDB",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem can be framed as a subset sum problem, which has a wide range of applications in the software industry, particularly in financial technology (fintech) and inventory management systems. For example, in a stock trading application, an algorithm might need to find combinations of stocks that add up to a user's specified budget. Similarly, in inventory management, it could assist in finding combinations of items to fulfill a certain order, given constraints such as weight or cost.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to explore all possible combinations. Stop when the target becomes zero (a valid combination is found) or when the target becomes negative (discard the branch)."
                                        },
                                        {
                                            "hint": "\"Sort the input array candidates to handle duplicates easily. Skip duplicates during recursion: If candidates[i]==candidates[i-1] and i>start, skip the current element.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting simplifies duplicate handling and ensures that combinations are generated in lexicographical order.",
                                            "question": "Why sort the candidates array?"
                                        },
                                        {
                                            "answer": "Sorting candidates before recursion ensures that combinations are generated in ascending order.",
                                            "question": "How is the order of output combinations ensured?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the recursion to allow revisiting the same index instead of moving to the next index after including a number.",
                                            "question": "What if candidates can be used multiple times?"
                                        },
                                        {
                                            "answer": "Instead of storing valid combinations, maintain a counter to track the number of valid combinations found.",
                                            "question": "How would you modify this to return the number of unique combinations instead of the combinations themselves?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs_subsetsi",
                                "problem_name": "Subsets I",
                                "problem_slug": "subsets-i",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Docker",
                                        "Bloomberg",
                                        "Texas Instruments",
                                        "Seagate Technology",
                                        "Red Hat",
                                        "Bungie",
                                        "Epic Games",
                                        "Zomato",
                                        "Splunk",
                                        "Walmart",
                                        "Wayfair",
                                        "Cloudflare",
                                        "Boston Consulting Group",
                                        "HashiCorp",
                                        "Ubisoft",
                                        "Robinhood",
                                        "Snowflake",
                                        "Ernst & Young",
                                        "Rakuten",
                                        "Optum",
                                        "Instacart",
                                        "Unity Technologies",
                                        "Flipkart",
                                        "Teladoc Health",
                                        "Uber",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is actually a fundamental concept in business analytics and Big Data processing. Whenever companies perform market basket analysis (eg supermarket transaction data to find the association between different item sets) or power set calculations, this function for calculating the sum of all subsets can be heavily used. Having optimized algorithms to solve this problem can greatly improve the efficiency of processing large datasets. This subset sum problem is also related to cryptography, operations research, and complexity theory, all essential concepts in software industry.",
                                    "hints": [
                                        {
                                            "hint": "\"Each element in nums contributes to exactly half of the subsets because every element either appears or doesn't appear in any given subset. For an element x in nums, it contributes x2^n1 to the total sum, where n is the size of the array.\""
                                        },
                                        {
                                            "hint": "Generate all subsets of nums and compute their sums individually."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Generating all subsets is computationally expensive for large n. Optimizing using the 2^n1 contribution rule avoids this.",
                                            "question": "Why not generate all subsets explicitly?"
                                        },
                                        {
                                            "answer": "In a set of size n, each element appears in exactly half of the 2^n subsets because subsets either include or exclude the element.",
                                            "question": "How does each element contribute to 2^n1 subsets?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use backtracking or bit masking to generate subsets and compute their sums. This may be required in specific scenarios where all subsets are needed.",
                                            "question": "What if subsets must be generated explicitly?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs_subsetsii",
                                "problem_name": "Subsets II",
                                "problem_slug": "subsets-ii",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Goldman Sachs",
                                        "OYO Rooms",
                                        "Optum",
                                        "Chewy",
                                        "Zomato",
                                        "Etsy",
                                        "Salesforce",
                                        "Rockstar Games",
                                        "Flipkart",
                                        "Stripe",
                                        "Electronic Arts",
                                        "Uber",
                                        "Deloitte",
                                        "Rakuten",
                                        "Freshworks",
                                        "Zoho",
                                        "Intel",
                                        "Oracle",
                                        "Bungie",
                                        "Walmart",
                                        "Roblox",
                                        "Zynga",
                                        "HCL Technologies",
                                        "AMD",
                                        "Databricks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concept of the problem statement - power set - has real-world applications in a lot of areas within software development. An interesting fact is in the recommendation engines you interact with every day when you use platforms like Netflix or Amazon. These recommendation systems often use the concept of power sets in their algorithms to generate combinations of items (for instance, movies or products) that a user may be interested in based on their previous behavior. The concept of power sets, thus, plays a significant role in building personalized user experience across many applications.",
                                    "hints": [
                                        {
                                            "hint": "Sort the input array nums to group duplicate elements together. While generating subsets, skip duplicate elements to avoid generating the same subset multiple times"
                                        },
                                        {
                                            "hint": "Start with an empty subset. For each element in nums, add it to all existing subsets. To handle duplicates, only extend subsets created in the previous iteration for duplicate elements."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By skipping duplicate elements during recursion or tracking subsets generated in the last step during iteration, the algorithm avoids duplicate subsets.",
                                            "question": "How does the solution ensure subsets are unique?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use combinations from the itertools library or modify the backtracking approach to include a size constraint.",
                                            "question": "What if subsets of a specific size k are required?"
                                        },
                                        {
                                            "answer": "Sorting simplifies the process of skipping duplicates, but you can use a hash set to track generated subsets and ensure uniqueness without sorting.",
                                            "question": "Can this problem be solved without sorting the array?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs_combinationsumiii",
                                "problem_name": "Combination Sum III",
                                "problem_slug": "combination-sum-iii",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Lyft",
                                        "Medtronic",
                                        "Nutanix",
                                        "Byju's",
                                        "Morgan Stanley",
                                        "Johnson & Johnson",
                                        "IBM",
                                        "Mastercard",
                                        "DoorDash",
                                        "Texas Instruments",
                                        "ARM",
                                        "NVIDIA",
                                        "Freshworks",
                                        "Airbnb",
                                        "Alibaba",
                                        "MongoDB",
                                        "Riot Games",
                                        "Electronic Arts",
                                        "eBay",
                                        "Zynga",
                                        "Unity Technologies",
                                        "HashiCorp",
                                        "Cerner",
                                        "Zomato",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem is a variant of the classic combinatorial problem in computer science often encountered in financial software, where an organization might want to understand all possible combinations of assets that can achieve a given financial target. Beyond finance, it also broadly applies in decision-making algorithms, such as in Artificial Intelligence for exploring all potential paths or actions. By enumerating all possibilities, the software can make more informed decisions to achieve the desired goal.",
                                    "hints": [
                                        {
                                            "hint": "\"Use recursion to explore combinations. Include a number from 1 to 9 and reduce both n (target sum) and k (remaining numbers to select). Exclude the current number and move to the next.\""
                                        },
                                        {
                                            "hint": "Generate combinations by iterating through numbers from the current index to ensure each number is used only once. This avoids generating duplicate combinations."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By iterating from the current number onwards and avoiding revisits, duplicate combinations like [2,3] and [3,2] are naturally avoided.",
                                            "question": "How do you ensure combinations are unique?"
                                        },
                                        {
                                            "answer": "Brute force involves generating all subsets of size k and checking their sum, which is inefficient. Backtracking avoids unnecessary computations by pruning invalid branches early.",
                                            "question": "Why not use brute force to generate all subsets?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the recursion to allow revisiting the same number. Start recursive calls from the current number instead of the next number.",
                                            "question": "What if numbers can be reused?"
                                        },
                                        {
                                            "answer": "Use memoization to store intermediate results for previously computed states to avoid redundant calculations.",
                                            "question": "How would you handle very large n and k?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "recursion_hard",
                        "subcategory_name": "Hard",
                        "subcategory_slug": "hard",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "recursion_recursion_hard_lettercombinationsofaphonenumber",
                                "problem_name": "Letter Combinations of a Phone Number",
                                "problem_slug": "letter-combinations-of-a-phone-number",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Stripe",
                                        "HCL Technologies",
                                        "IBM",
                                        "Goldman Sachs",
                                        "Boston Consulting Group",
                                        "Broadcom",
                                        "Dropbox",
                                        "Epic Systems",
                                        "Cerner",
                                        "Flipkart",
                                        "Ernst & Young",
                                        "Epic Games",
                                        "Chewy",
                                        "HashiCorp",
                                        "Qualcomm",
                                        "Square",
                                        "Morgan Stanley",
                                        "MongoDB",
                                        "Micron Technology",
                                        "OYO Rooms",
                                        "Intel",
                                        "Mastercard",
                                        "Shopify",
                                        "Nutanix",
                                        "Seagate Technology",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "A practical application of this programming problem lies in the creation of telephone dial-in systems or mobile texting in old feature phones, where a combination of number presses resulted in different letters. The predictive text (T9 word) feature, for instance, used this method to help users type faster. The logic behind typing on old mobile phones is similar to the problem mentioned - every number corresponds to a different set of letters and a combination results in different words. Nowadays, even though smartphones with full QWERTY keyboards are dominant, this concept is very crucial for accessibility programs for visually impaired or specially-abled users.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to explore all combinations. For each digit, iterate over its mapped letters. Append each letter to the current combination and proceed to the next digit."
                                        },
                                        {
                                            "hint": "Start with an empty combination in a queue. For each digit, extend all existing combinations in the queue by appending each possible letter. Continue until all digits have been processed."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Backtracking systematically generates all combinations by exploring all possibilities at each digit. It avoids redundant computations by building combinations incrementally.",
                                            "question": "Why use backtracking for this problem?"
                                        },
                                        {
                                            "answer": "The order of combinations depends on the traversal order in the recursive or iterative approach. The problem does not specify any required order, so either lexicographical or arbitrary order is acceptable.",
                                            "question": "Can the order of combinations affect the result?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Define a mapping for 0 and 1 (e.g., 0\"\" and 1\"\"), or ignore them in the input.",
                                            "question": "How would you modify this problem to include digits 0 and 1?"
                                        },
                                        {
                                            "answer": "Sorting the mapped letters for each digit ensures the combinations are generated in lexicographical order.",
                                            "question": "What if a specific order (e.g., lexicographical) is required for the output?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "recursion_faqs(hard)",
                        "subcategory_name": "FAQs (Hard)",
                        "subcategory_slug": "faqs-hard",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_palindromepartitioning",
                                "problem_name": "Palindrome partitioning",
                                "problem_slug": "palindrome-partitioning",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Instacart",
                                        "PayPal",
                                        "Airbnb",
                                        "Walmart",
                                        "American Express",
                                        "Shopify",
                                        "Medtronic",
                                        "Seagate Technology",
                                        "Cloudflare",
                                        "Morgan Stanley",
                                        "Siemens Healthineers",
                                        "Qualcomm",
                                        "Unity Technologies",
                                        "Electronic Arts",
                                        "Pinterest",
                                        "Mastercard",
                                        "PwC",
                                        "Robinhood",
                                        "Salesforce",
                                        "Stripe",
                                        "Visa",
                                        "Ubisoft",
                                        "Wayfair",
                                        "Byju's",
                                        "Freshworks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem concept is heavily applied in building AI chatbots, particularly for checking if a sentence or phrase is the same forward and backward, an example of a palindrome. Natural language processing (NLP) is a massive part of AI chatbots that can parse, understand, and respond to user input in a way that simulates natural human conversation - the palindrome partitioning helps in this case. Besides, it's also used in DNA sequence analysis in bioinformatics, where analyzing palindromic sequences can play a critical role in understanding DNA sequences and their functions.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to explore all possible partitions. Backtrack to remove the last added substring and try other possibilities."
                                        },
                                        {
                                            "hint": "Use a helper function to check if a substring is a palindrome."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Duplicate partitions are naturally avoided because backtracking generates partitions by iterating through the string in order and only includes valid substrings.",
                                            "question": "How do you avoid duplicate partitions?"
                                        },
                                        {
                                            "answer": "The output will include all possible partitions, ranging from each character as a separate partition to the entire string as a single partition.",
                                            "question": "What if the input contains only palindromes?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Return the first partition found during backtracking. This reduces the search space and improves performance.",
                                            "question": "What if the problem required finding only one valid partition?"
                                        },
                                        {
                                            "answer": "Modify the recursion to include overlapping substrings. This would require additional bookkeeping to avoid duplicate results.",
                                            "question": "What if overlapping palindromic substrings are allowed?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_wordsearch",
                                "problem_name": "Word Search",
                                "problem_slug": "word-search",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Walmart",
                                        "Roche",
                                        "JPMorgan Chase",
                                        "Morgan Stanley",
                                        "Goldman Sachs",
                                        "Johnson & Johnson",
                                        "Activision Blizzard",
                                        "Shopify",
                                        "Ernst & Young",
                                        "OYO Rooms",
                                        "Intel",
                                        "Teladoc Health",
                                        "MongoDB",
                                        "Epic Systems",
                                        "Medtronic",
                                        "DoorDash",
                                        "Western Digital",
                                        "Rakuten",
                                        "Swiggy",
                                        "Riot Games",
                                        "Salesforce",
                                        "McKinsey & Company",
                                        "IBM",
                                        "Zoho",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concept of this problem is often used in word puzzle games like \"Boggle\" or \"Words With Friends\", where players are required to search for words in grids. Specifically, the logic of checking for word existence in a grid by looking horizontally or vertically - without reusing the same letter cell, is an integral part of such game development to validate a player's move.",
                                    "hints": [
                                        {
                                            "hint": "Start at every cell in the grid and try to match the first character of word. If a match is found, recursively explore the neighboring cells to match the subsequent characters. Mark the current cell as visited (e.g., by modifying its value temporarily) to prevent revisiting it in the same path."
                                        },
                                        {
                                            "hint": "If the current index of the word equals its length, it means the word is successfully found. If the current cell does not match the expected character or goes out of bounds, backtrack immediately."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Repeated characters are handled naturally since each character must be matched independently in adjacent cells.",
                                            "question": "What happens if the word contains repeated characters?"
                                        },
                                        {
                                            "answer": "Temporarily modify the grid value (e.g., set it to #) during the search. Restore it after backtracking to ensure the grid remains intact for other paths.",
                                            "question": "How do you handle visited cells?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the neighbor exploration step to include diagonal directions (top-left, top-right, bottom-left, bottom-right).",
                                            "question": "How would you handle diagonal moves?"
                                        },
                                        {
                                            "answer": "Modify the neighbor exploration to allow wrapping (e.g., moving off the right edge brings you to the left edge of the same row).",
                                            "question": "What if the word must wrap around the edges of the grid?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_nqueen",
                                "problem_name": "N Queen",
                                "problem_slug": "n-queen",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Morgan Stanley",
                                        "Zoho",
                                        "Deloitte",
                                        "Robinhood",
                                        "Stripe",
                                        "Philips Healthcare",
                                        "Electronic Arts",
                                        "GE Healthcare",
                                        "Texas Instruments",
                                        "NVIDIA",
                                        "PwC",
                                        "Qualcomm",
                                        "Broadcom",
                                        "Mastercard",
                                        "Western Digital",
                                        "IBM",
                                        "Cloudflare",
                                        "JPMorgan Chase",
                                        "Lyft",
                                        "Roblox",
                                        "Bungie",
                                        "Snowflake",
                                        "Dropbox",
                                        "Seagate Technology",
                                        "HashiCorp",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The N-Queens problem, while initially appearing as just a chess puzzle, actually has valuable implications in real-world applications. Its solution relies on a fundamental concept in technology: backtracking, which is used in recommendation algorithms, routing protocols, database queries optimizations and more. Any time you need to make a series of decisions, where each decision leads to a new set of choices, backtracking becomes a handy tool. The principles of this problem are even applied in branches of artificial intelligence for constraint satisfaction problems such as scheduling, map-coloring and Sudoku.",
                                    "hints": [
                                        {
                                            "hint": "Use backtracking to try placing queens row by row. "
                                        },
                                        {
                                            "hint": "Use sets to efficiently track conflicts in columns, main diagonals, and anti-diagonals. Prune invalid branches early to reduce unnecessary computations."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Backtracking systematically explores all possible configurations and prunes invalid ones early, making it well-suited for combinatorial problems like this.",
                                            "question": "Why use backtracking for this problem?"
                                        },
                                        {
                                            "answer": "Maintain the column index for each row where a queen is placed. Use this to build the board as a list of strings.",
                                            "question": "How do you construct the board from the solution?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Adjust the recursion to stop after placing k queens instead of n.",
                                            "question": "How would you modify the solution for a k-queens problem (fewer than n queens)?"
                                        },
                                        {
                                            "answer": "Use a counter instead of storing solutions. Increment the counter whenever a valid configuration is found.",
                                            "question": "How would you count the total number of solutions instead of returning them?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_ratinamaze",
                                "problem_name": "Rat in a Maze",
                                "problem_slug": "rat-in-a-maze",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Snowflake",
                                        "Unity Technologies",
                                        "Ubisoft",
                                        "OYO Rooms",
                                        "Broadcom",
                                        "Cloudflare",
                                        "MongoDB",
                                        "Chewy",
                                        "Teladoc Health",
                                        "Swiggy",
                                        "Splunk",
                                        "Walmart",
                                        "Johnson & Johnson",
                                        "Oracle",
                                        "Reddit",
                                        "Square",
                                        "Target",
                                        "Nutanix",
                                        "McKinsey & Company",
                                        "AMD",
                                        "Twilio",
                                        "ARM",
                                        "PwC",
                                        "Docker",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem statement is a practical manifestation of pathfinding algorithms used in a variety of disciplines in software development. A prime example can be found in video game development, where these algorithms allow characters to navigate around obstacles in an environment. In particular, the A* (A-star) search algorithm, which incorporates heuristic information, is commonly used for its efficiency and accuracy in finding the shortest path. Additionally, similar problem-solving structures are used in web routing protocols and Global Positioning System (GPS) for finding the shortest route between two locations.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to explore all possible moves from the current cell. At each step, check if the current cell is valid for traversal (inside the grid, unvisited, and not blocked). If valid, mark the cell as visited and attempt to move in all four possible directions. Append the direction (U, D, L, R) to the current path while moving."
                                        },
                                        {
                                            "hint": "If the current cell is (n1,n1), it means the rat has reached the destination. Add the current path to the list of results. If the current cell is invalid (out of bounds, blocked, or already visited), return immediately without proceeding further."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use a visited matrix or temporarily mark the grid cell as blocked (e.g., setting it to 0) while exploring it. After backtracking, restore the cell to its original state.",
                                            "question": "How do you ensure the rat doesnt revisit cells in the same path?"
                                        },
                                        {
                                            "answer": "Each recursive path is independently constructed by appending the current direction. As long as cells are not revisited within a path, duplicate paths are naturally avoided.",
                                            "question": "How do you ensure all paths are distinct? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of finding all paths, use a Breadth-First Search (BFS) approach to find the shortest path. BFS explores all possible paths layer by layer and guarantees the shortest path in unweighted grids.",
                                            "question": "How would you modify the algorithm to return only the shortest path?"
                                        },
                                        {
                                            "answer": "Add logic to track items or constraints (e.g., counting the number of specific cells visited). Include this information in the recursion state to enforce the constraints during path exploration.",
                                            "question": "What if the rat must collect items or satisfy constraints along the way?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_mcoloringproblem",
                                "problem_name": "M Coloring Problem",
                                "problem_slug": "m-coloring-problem",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Instacart",
                                        "Flipkart",
                                        "Bain & Company",
                                        "Rockstar Games",
                                        "Qualcomm",
                                        "Cerner",
                                        "KPMG",
                                        "eBay",
                                        "Swiggy",
                                        "Electronic Arts",
                                        "Philips Healthcare",
                                        "Broadcom",
                                        "GE Healthcare",
                                        "Salesforce",
                                        "Zomato",
                                        "ARM",
                                        "Medtronic",
                                        "Shopify",
                                        "Reddit",
                                        "Rakuten",
                                        "Seagate Technology",
                                        "Morgan Stanley",
                                        "McKinsey & Company",
                                        "PwC",
                                        "Western Digital",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The graph coloring problem is a critical concept in many real-world applications, such as register allocation in compilers, mobile radio frequency assignment, task scheduling and in Sudoku puzzles. For example, in register allocation during the compiling process, each register can be viewed as a color. The goal is to allocate the most efficiently without using the same register for intersecting live ranges of variables, similar to not coloring adjacent vertices with the same color in a graph. This graph-coloring method helps in writing efficient programs.",
                                    "hints": [
                                        {
                                            "hint": "This is a variation of the graph coloring problem, which is NP-complete. Start by attempting to color each vertex one by one. For each vertex, try assigning it a color from 1 to M."
                                        },
                                        {
                                            "hint": "\"Use an adjacency list or adjacency matrix to represent the graph. For a vertex v, a color c is valid if no vertex adjacent to v is already colored withc. This can be implemented by iterating through the neighbors of v and checking their current colors.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Treat each connected component independently. If any component cannot be colored with M colors, return False.",
                                            "question": "How do you handle disconnected graphs?"
                                        },
                                        {
                                            "answer": "For each vertex, check the colors of all its neighbors before assigning a color. Use a helper function to validate color assignments.",
                                            "question": "How do you ensure adjacent vertices have different colors?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Directed graphs require ensuring no two vertices in a directed path share the same color. This may require reinterpreting the problem as a graph partitioning problem.",
                                            "question": "How would you modify this for directed graphs?"
                                        },
                                        {
                                            "answer": "Yes, use an iterative approach with a stack or queue to simulate the backtracking process. However, recursion is simpler and more intuitive for this problem.",
                                            "question": "Can this problem be solved without recursion?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "recursion_recursion_faqs(hard)_sudokosolver",
                                "problem_name": "Sudoko Solver",
                                "problem_slug": "sudoko-solver",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Airbnb",
                                        "Visa",
                                        "McKinsey & Company",
                                        "ARM",
                                        "Stripe",
                                        "Bungie",
                                        "Alibaba",
                                        "Ernst & Young",
                                        "Flipkart",
                                        "Etsy",
                                        "Medtronic",
                                        "Zoho",
                                        "Zomato",
                                        "Broadcom",
                                        "Riot Games",
                                        "Goldman Sachs",
                                        "Uber",
                                        "Zynga",
                                        "Databricks",
                                        "Activision Blizzard",
                                        "Freshworks",
                                        "Optum",
                                        "Micron Technology",
                                        "Ubisoft",
                                        "Texas Instruments",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept behind solving Sudoku puzzles programmatically is often used in the real world as a common example of constraint satisfaction problems (CSPs). CSPs are mathematical questions defined as a set of objects whose state must satisfy a number of constraints or restrictions. CSPs are applied in areas like AI planning and scheduling, routing problems, and even efficiently allocating resources in large data centers. For instance, Google uses CSPs in their Or-Tools software to solve complex planning and resource allocation problems.",
                                    "hints": [
                                        {
                                            "hint": "Use recursion to try filling in each empty cell. For each empty cell, try placing numbers 1 through 9. After placing a number, recursively attempt to solve the rest of the puzzle."
                                        },
                                        {
                                            "hint": "Maintain data structures (e.g., sets or arrays) to track used numbers for each row, column, and sub-grid. This avoids repeatedly iterating over the grid to check constraints. Terminate as soon as the puzzle is solved, as only one solution exists for a valid Sudoku."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Backtracking systematically explores all possible configurations, ensuring that the solution satisfies all constraints. It is efficient for problems like Sudoku, where the solution space can be pruned early.",
                                            "question": "Why use backtracking for solving Sudoku?"
                                        },
                                        {
                                            "answer": "Validate the board before solving by checking for duplicates in rows, columns, and sub-grids. If invalid, return an appropriate error or flag.",
                                            "question": "How do you handle invalid Sudoku boards?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the backtracking function to terminate after finding the first valid number for the target cell.",
                                            "question": "What if only partial solutions are required (e.g., fill one cell)?"
                                        },
                                        {
                                            "answer": "Parallelizing backtracking is challenging due to its sequential nature. However, independent sub-grids can be solved in parallel for puzzles with partial constraints.",
                                            "question": "Can the algorithm be parallelized?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "recursion_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 6,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "different_series",
                                "problem_name": "Different Series",
                                "problem_slug": "different-series",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "combination_xor",
                                "problem_name": "Combination XOR",
                                "problem_slug": "combination-xor",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "find_distinct_outcomes",
                                "problem_name": "Find Distinct Expressions",
                                "problem_slug": "find-distinct-expressions",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "linked-list",
                "category_name": "Linked-List",
                "category_slug": "linked-list",
                "category_rank": 6,
                "subcategories": [
                    {
                        "subcategory_id": "linked-list_fundamentals(singlell)",
                        "subcategory_name": "Fundamentals (Single LL)",
                        "subcategory_slug": "fundamentals-single-ll",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(singlell)_introductiontosinglylinkedlist",
                                "problem_name": "Introduction to Singly LinkedList",
                                "problem_slug": "introduction-to-singly-linkedlist",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Swiggy",
                                        "Cerner",
                                        "Activision Blizzard",
                                        "IBM",
                                        "Byju's",
                                        "McKinsey & Company",
                                        "Oracle",
                                        "DoorDash",
                                        "Broadcom",
                                        "Siemens Healthineers",
                                        "Zynga",
                                        "Twilio",
                                        "Databricks",
                                        "GE Healthcare",
                                        "Walmart",
                                        "Deloitte",
                                        "Robinhood",
                                        "Ernst & Young",
                                        "Zoho",
                                        "Mastercard",
                                        "Texas Instruments",
                                        "KPMG",
                                        "Snowflake",
                                        "Micron Technology",
                                        "Alibaba",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(singlell)_traversalinlinkedlist",
                                "problem_name": "Traversal in Linked List",
                                "problem_slug": "traversal-in-linked-list",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Zoho",
                                        "Freshworks",
                                        "McKinsey & Company",
                                        "Splunk",
                                        "Robinhood",
                                        "Micron Technology",
                                        "Bain & Company",
                                        "MongoDB",
                                        "Philips Healthcare",
                                        "HCL Technologies",
                                        "American Express",
                                        "Uber",
                                        "OYO Rooms",
                                        "PwC",
                                        "AMD",
                                        "Cerner",
                                        "Broadcom",
                                        "ARM",
                                        "Walmart",
                                        "Ubisoft",
                                        "Etsy",
                                        "Teladoc Health",
                                        "Nutanix",
                                        "Alibaba",
                                        "Goldman Sachs",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "Fun Fact: The problem of traversing a singly Linked List is very commonly used in software development. One of its real-world applications is found in web browser history. When you navigate the web, your browser keeps track of the websites you've visited using a form of linked list. Each site is a node in the list and you can move backwards and forwards through your history, much like traversing a linked list. Additionally, linked lists are also frequently used in the implementation of filesystems, where directories are often represented as singly linked lists, with each node representing a file or sub-directory.",
                                    "hints": [
                                        {
                                            "hint": "Start at the head node. Use a loop to traverse through each node of the linked list."
                                        },
                                        {
                                            "hint": "Initialize an empty array to store the values. Use a pointer to traverse the list. When the pointer becomes null or None, the traversal is complete."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The iterative approach is preferred for large lists because it avoids the stack overflow risk associated with recursion.",
                                            "question": "How do you handle very large linked lists?"
                                        },
                                        {
                                            "answer": "The traversal order is guaranteed to be the same as the linked list order because each node is processed sequentially.",
                                            "question": "How do you confirm the traversal order?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a stack to store the values during traversal and pop elements from the stack to get them in reverse order. Alternatively, reverse the array after traversal.",
                                            "question": "What if you need to reverse the traversal order?"
                                        },
                                        {
                                            "answer": "Traversing a singly linked list cannot be parallelized because each node depends on the next pointer of the previous node. However, parallelization is possible for tasks performed on the data after traversal.",
                                            "question": "Can this algorithm be parallelized?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(singlell)_deletioninlinkedlist",
                                "problem_name": "Deletion in Linked List",
                                "problem_slug": "deletion-in-linked-list",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Roblox",
                                        "Riot Games",
                                        "Cerner",
                                        "Byju's",
                                        "Mastercard",
                                        "McKinsey & Company",
                                        "Visa",
                                        "Alibaba",
                                        "Wayfair",
                                        "Robinhood",
                                        "Square",
                                        "Unity Technologies",
                                        "American Express",
                                        "Morgan Stanley",
                                        "Stripe",
                                        "Goldman Sachs",
                                        "HashiCorp",
                                        "Flipkart",
                                        "Salesforce",
                                        "Databricks",
                                        "HCL Technologies",
                                        "Zynga",
                                        "Epic Games",
                                        "Uber",
                                        "Intel",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(singlell)_insertioninlinkedlist",
                                "problem_name": "Insertion in Linked List",
                                "problem_slug": "insertion-in-linked-list",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Airbnb",
                                        "Oracle",
                                        "Texas Instruments",
                                        "Siemens Healthineers",
                                        "Epic Systems",
                                        "Rockstar Games",
                                        "Shopify",
                                        "Deloitte",
                                        "KPMG",
                                        "Ubisoft",
                                        "Target",
                                        "Cerner",
                                        "Goldman Sachs",
                                        "Teladoc Health",
                                        "Dropbox",
                                        "NVIDIA",
                                        "Optum",
                                        "American Express",
                                        "ARM",
                                        "Walmart",
                                        "Flipkart",
                                        "Mastercard",
                                        "Zoho",
                                        "Square",
                                        "PayPal",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletionoftheheadofll",
                                "problem_name": "Deletion of the head of LL",
                                "problem_slug": "deletion-of-the-head-of-ll",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Texas Instruments",
                                        "Oracle",
                                        "Roche",
                                        "IBM",
                                        "MongoDB",
                                        "Riot Games",
                                        "eBay",
                                        "McKinsey & Company",
                                        "Morgan Stanley",
                                        "Pinterest",
                                        "Byju's",
                                        "Epic Systems",
                                        "PwC",
                                        "Shopify",
                                        "Seagate Technology",
                                        "Unity Technologies",
                                        "Stripe",
                                        "Target",
                                        "Nutanix",
                                        "Zoho",
                                        "Walmart",
                                        "Johnson & Johnson",
                                        "Chewy",
                                        "Flipkart",
                                        "DoorDash",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Check if the list is empty (i.e., head is null or None). If true, return null or None, as there's no node to delete. "
                                        },
                                        {
                                            "hint": "If the list contains at least one node, move the head pointer to the next node."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The new head is the node immediately following the current head (head.next). If the current head is the only node, the new head becomes None.",
                                            "question": "What is the new head after deletion?"
                                        },
                                        {
                                            "answer": "Traverse the modified list starting from the new head to ensure that the first node has been removed and all other nodes remain intact.",
                                            "question": "How do you verify the result?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If the list is circular, check if the head is the only node.\nIf true, set the head to None. Otherwise, update the tails next pointer to skip the deleted node and point to the new head.",
                                            "question": "What if the list is circular?"
                                        },
                                        {
                                            "answer": "Deleting the head does not require traversal or a previous pointer, making it simpler. Deleting other nodes requires maintaining a reference to the previous node.",
                                            "question": "What is the difference between deleting the head and other nodes?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletionofthetailofll",
                                "problem_name": "Deletion of the tail of LL",
                                "problem_slug": "deletion-of-the-tail-of-ll",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "McKinsey & Company",
                                        "ARM",
                                        "Oracle",
                                        "Bloomberg",
                                        "Goldman Sachs",
                                        "Salesforce",
                                        "Texas Instruments",
                                        "IBM",
                                        "Databricks",
                                        "Riot Games",
                                        "Ubisoft",
                                        "Stripe",
                                        "PwC",
                                        "Red Hat",
                                        "Flipkart",
                                        "DoorDash",
                                        "NVIDIA",
                                        "JPMorgan Chase",
                                        "Philips Healthcare",
                                        "Micron Technology",
                                        "Dropbox",
                                        "Broadcom",
                                        "Airbnb",
                                        "Western Digital",
                                        "Johnson & Johnson",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head == None), return None. If there is only one node (head.next == None), removing the tail leaves an empty list, so return None."
                                        },
                                        {
                                            "hint": "Traverse to the last node (tail), which is the node where next == None. Update the second last nodes next = None to remove the tail. Return the updated head of the list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "To update the second last nodes next to None, correctly removing the tail.",
                                            "question": "Why do we need to traverse to the second last node instead of directly removing the last node?"
                                        },
                                        {
                                            "answer": "No, removing the head requires updating head.next and its prev pointer.",
                                            "question": "Can we use the same logic for removing the head node?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Update prev.next and next.prev to unlink the node.",
                                            "question": "How would you modify this to remove a node from the middle of the list?"
                                        },
                                        {
                                            "answer": "Store the removed node in a temporary variable before modifying pointers.",
                                            "question": "How would you modify this to return the deleted node instead of just updating the list?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletionofthekthelementofll",
                                "problem_name": "Deletion of the Kth element of LL",
                                "problem_slug": "deletion-of-the-kth-element-of-ll",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "OYO Rooms",
                                        "Square",
                                        "Teladoc Health",
                                        "Activision Blizzard",
                                        "Walmart",
                                        "Morgan Stanley",
                                        "Bloomberg",
                                        "Red Hat",
                                        "Rakuten",
                                        "Micron Technology",
                                        "Philips Healthcare",
                                        "Johnson & Johnson",
                                        "McKinsey & Company",
                                        "Uber",
                                        "Reddit",
                                        "Riot Games",
                                        "JPMorgan Chase",
                                        "Electronic Arts",
                                        "Cloudflare",
                                        "eBay",
                                        "Salesforce",
                                        "Siemens Healthineers",
                                        "KPMG",
                                        "Cerner",
                                        "Epic Systems",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head == None), return None. If k == 1, remove the head node and return head.next. Traverse the list to find the k-th node."
                                        },
                                        {
                                            "hint": "Update the pointers, If the node has a previous node (prev), update prev.next = node.next. If the node has a next node (next), update next.prev = node.prev. If k is beyond the length of the list, return the original head."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If k is greater than the number of nodes, return the original list.",
                                            "question": "What happens if k is out of bounds?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If k == 1, update the tail's next to the new head.",
                                            "question": "How would you modify this for a circular doubly linked list?"
                                        },
                                        {
                                            "answer": "Traverse the list and remove all nodes where val == target, updating pointers accordingly.",
                                            "question": "How would you modify this to remove all occurrences of a specific value instead of a position?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletetheelementwithvaluex",
                                "problem_name": "Delete the element with value X",
                                "problem_slug": "delete-the-element-with-value-x",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Johnson & Johnson",
                                        "Unity Technologies",
                                        "Roblox",
                                        "Riot Games",
                                        "Zomato",
                                        "Swiggy",
                                        "Bloomberg",
                                        "Reddit",
                                        "McKinsey & Company",
                                        "DoorDash",
                                        "Seagate Technology",
                                        "Texas Instruments",
                                        "Qualcomm",
                                        "Western Digital",
                                        "PwC",
                                        "Salesforce",
                                        "Dropbox",
                                        "OYO Rooms",
                                        "Cerner",
                                        "Walmart",
                                        "Robinhood",
                                        "Electronic Arts",
                                        "Pinterest",
                                        "Goldman Sachs",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head is None), return None as there is no node to delete. If the value X is present in the head node, update the head pointer to head.next to remove the head node. Traverse the list starting from the head, keeping track of the previous node"
                                        },
                                        {
                                            "hint": "Use a pointer to traverse the list starting from the head. Maintain a reference to the current node and the previous node during traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the head contains X, update the head pointer to head.next to remove the head node.",
                                            "question": "How do you handle deleting the head node?"
                                        },
                                        {
                                            "answer": "Yes, but the problem specifies deleting only the first occurrence of X. The rest of the list remains unchanged.",
                                            "question": "Can the value X appear multiple times in the list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of stopping after deleting the first occurrence, continue traversing the list and update pointers to remove all nodes containing X.",
                                            "question": "What if you need to delete all occurrences of X?"
                                        },
                                        {
                                            "answer": "For a circular linked list, ensure that the tail nodes next pointer is updated appropriately if the deleted node is the head or the node with value X.",
                                            "question": "How would you handle circular linked lists?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertionattheheadofll",
                                "problem_name": "Insertion at the head of LL",
                                "problem_slug": "insertion-at-the-head-of-ll",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "DoorDash",
                                        "Oracle",
                                        "Twilio",
                                        "Seagate Technology",
                                        "Shopify",
                                        "Cerner",
                                        "Qualcomm",
                                        "Teladoc Health",
                                        "Riot Games",
                                        "Roche",
                                        "Databricks",
                                        "JPMorgan Chase",
                                        "Johnson & Johnson",
                                        "MongoDB",
                                        "Goldman Sachs",
                                        "Flipkart",
                                        "Siemens Healthineers",
                                        "Byju's",
                                        "Docker",
                                        "Rakuten",
                                        "HashiCorp",
                                        "Chewy",
                                        "ARM",
                                        "Zynga",
                                        "Optum",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Create a new node with value X. Set the next pointer of the new node to the current head."
                                        },
                                        {
                                            "hint": "Update the head pointer to point to the new node, making it the first node of the list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Inserting at the head does not require traversal or reference to other nodes, making it simpler and faster than inserting at other positions.",
                                            "question": "What is the difference between inserting at the head and at other positions?"
                                        },
                                        {
                                            "answer": "By setting the next pointer of the new node to the current head, all subsequent nodes remain linked to the list.",
                                            "question": "How do you ensure the rest of the list remains intact?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For a circular linked list:\nSet the next pointer of the new node to the current head.\nTraverse the list to find the tail node and update its next pointer to the new node.\nUpdate the head pointer to the new node.",
                                            "question": "How would you handle a circular linked list?"
                                        },
                                        {
                                            "answer": "Inserting at the head is inherently efficient in linked lists due to O(1) complexity. However, maintaining a reference to the head ensures optimal performance during repeated insertions.",
                                            "question": "What if you frequently need to insert at the head?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertionatthetailofll",
                                "problem_name": "Insertion at the tail of LL",
                                "problem_slug": "insertion-at-the-tail-of-ll",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Square",
                                        "Teladoc Health",
                                        "Flipkart",
                                        "Pinterest",
                                        "Texas Instruments",
                                        "Nutanix",
                                        "Robinhood",
                                        "Western Digital",
                                        "Medtronic",
                                        "Siemens Healthineers",
                                        "Roche",
                                        "Bloomberg",
                                        "KPMG",
                                        "OYO Rooms",
                                        "Twilio",
                                        "Target",
                                        "Mastercard",
                                        "DoorDash",
                                        "Deloitte",
                                        "Epic Games",
                                        "Databricks",
                                        "Walmart",
                                        "PwC",
                                        "Uber",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Create a new node with value X and set its next pointer to None. If the list is empty (head is None), the new node becomes the head of the list. Otherwise, traverse the list to reach the current tail (node whose next pointer is None)."
                                        },
                                        {
                                            "hint": "Use a pointer to traverse the list starting from the head. Stop when the pointer reaches the tail node (where next is None). Update the next pointer of the tail node to point to the new node."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Inserting at the tail requires traversal to the end of the list (unless the tail is tracked separately), while inserting at other positions might require locating a specific index or node.",
                                            "question": "What is the difference between inserting at the tail and other positions?"
                                        },
                                        {
                                            "answer": "By traversing the list until the tail (node with next = None) is found and updating its next pointer to point to the new node.",
                                            "question": "How do you ensure the new node is added at the correct position?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a direct reference to the tail node, allowing O(1) insertion without requiring traversal.",
                                            "question": "What if you frequently need to insert at the tail?"
                                        },
                                        {
                                            "answer": "Traverse the list to find the correct position based on \nXs value, and insert the new node at that position.",
                                            "question": "What if the list needs to remain sorted after insertion?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertionatthekthposition",
                                "problem_name": "Insertion at the Kth position of LL",
                                "problem_slug": "insertion-at-the-kth-position-of-ll",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "Splunk",
                                        "Instacart",
                                        "NVIDIA",
                                        "Robinhood",
                                        "Twilio",
                                        "Roblox",
                                        "Etsy",
                                        "Docker",
                                        "Wayfair",
                                        "AMD",
                                        "McKinsey & Company",
                                        "Philips Healthcare",
                                        "HashiCorp",
                                        "Chewy",
                                        "Pinterest",
                                        "MongoDB",
                                        "Flipkart",
                                        "Ubisoft",
                                        "Western Digital",
                                        "Bungie",
                                        "Riot Games",
                                        "Goldman Sachs",
                                        "Lyft",
                                        "eBay",
                                        "Stripe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Traverse the list to find the (K1)-th node (the node just before the desired position). Create a new node with value X."
                                        },
                                        {
                                            "hint": "Use a pointer to traverse the list, keeping track of the current position. Stop when you reach the (K1)-th node or when the list ends."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Append the new node at the tail. Traverse to the end of the list and update the last nodes next pointer to point to the new node.",
                                            "question": "What if K is greater than the length of the list + 1?"
                                        },
                                        {
                                            "answer": "By carefully updating the next pointers of the surrounding nodes during insertion, you maintain the integrity of the linked list.",
                                            "question": "How do you ensure the list structure remains intact?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For circular linked lists:\nTraverse the list to the (K1)-th node. Insert the new node and update pointers to maintain the circular structure.",
                                            "question": "How would you handle circular linked lists?"
                                        },
                                        {
                                            "answer": "If the list is sorted, traverse the list to find the correct position based on Xs value and insert the new node there.",
                                            "question": "What if the list is sorted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertionbeforethevaluex",
                                "problem_name": "Insertion before the value X in LL",
                                "problem_slug": "insertion-before-the-value-x-in-ll",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "JPMorgan Chase",
                                        "HCL Technologies",
                                        "Visa",
                                        "DoorDash",
                                        "Cerner",
                                        "MongoDB",
                                        "OYO Rooms",
                                        "Zomato",
                                        "Pinterest",
                                        "GE Healthcare",
                                        "Ubisoft",
                                        "Square",
                                        "Epic Games",
                                        "Mastercard",
                                        "Bain & Company",
                                        "Byju's",
                                        "Western Digital",
                                        "Optum",
                                        "PayPal",
                                        "Broadcom",
                                        "Micron Technology",
                                        "Seagate Technology",
                                        "Unity Technologies",
                                        "Swiggy",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Traverse the list from the head to locate the first node with value X."
                                        },
                                        {
                                            "hint": "If X is found at the head, the task becomes straightforward, create a new node and make it the new head. For all other positions, keep track of the node preceding X during traversal, as this is where the insertion will occur."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "When the first node has the value X, the new node should become the new head. Instead of handling this separately in the traversal logic, treat it as a special initialization case before the traversal begins.",
                                            "question": "How do you efficiently handle inserting before the head when X matches the head node's value?"
                                        },
                                        {
                                            "answer": "In this case, the function should simply return the list unchanged. This ensures youre not making invalid modifications or accidentally breaking the list structure.",
                                            "question": "What happens when X is not found in the list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This requires a two-pass traversal of the list. In the first pass, find the last occurrence of X. In the second pass, insert the new node before that occurrence.",
                                            "question": "How would you handle a scenario where X is guaranteed to appear multiple times, and you want to insert only before the last occurrence of X?"
                                        },
                                        {
                                            "answer": "Maintaining a hash map of value-to-node mappings can speed up the search process, reducing traversal time.",
                                            "question": "What optimizations can you apply if you frequently insert before a specific value like X?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_fundamentals(doublyll)",
                        "subcategory_name": "Fundamentals (Doubly LL)",
                        "subcategory_slug": "fundamentals-doubly-ll",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(doublyll)_introductiontodoublyll",
                                "problem_name": "Introduction to Doubly LL",
                                "problem_slug": "introduction-to-doubly-ll",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Lyft",
                                        "Pinterest",
                                        "Cloudflare",
                                        "Bloomberg",
                                        "Medtronic",
                                        "Nutanix",
                                        "Dropbox",
                                        "Electronic Arts",
                                        "Roblox",
                                        "AMD",
                                        "Alibaba",
                                        "Qualcomm",
                                        "Texas Instruments",
                                        "Ernst & Young",
                                        "Broadcom",
                                        "Bungie",
                                        "Boston Consulting Group",
                                        "Western Digital",
                                        "Red Hat",
                                        "eBay",
                                        "Flipkart",
                                        "Target",
                                        "Unity Technologies",
                                        "Salesforce",
                                        "HashiCorp",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(doublyll)_deletionindoublyll",
                                "problem_name": "Deletion in Doubly LL",
                                "problem_slug": "deletion-in-doubly-ll",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Salesforce",
                                        "HashiCorp",
                                        "eBay",
                                        "Seagate Technology",
                                        "Wayfair",
                                        "GE Healthcare",
                                        "Optum",
                                        "Riot Games",
                                        "Bloomberg",
                                        "Swiggy",
                                        "Activision Blizzard",
                                        "Dropbox",
                                        "Rakuten",
                                        "Splunk",
                                        "Roblox",
                                        "Databricks",
                                        "Stripe",
                                        "MongoDB",
                                        "Electronic Arts",
                                        "Snowflake",
                                        "Intel",
                                        "Nutanix",
                                        "Johnson & Johnson",
                                        "HCL Technologies",
                                        "Byju's",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "linked-list_linked-list_fundamentals(doublyll)_insertionindll",
                                "problem_name": "Insertion in DLL",
                                "problem_slug": "insertion-in-dll",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Texas Instruments",
                                        "Shopify",
                                        "HCL Technologies",
                                        "Wayfair",
                                        "Salesforce",
                                        "Freshworks",
                                        "Nutanix",
                                        "Rakuten",
                                        "Bungie",
                                        "Reddit",
                                        "Pinterest",
                                        "Twilio",
                                        "Goldman Sachs",
                                        "Zynga",
                                        "IBM",
                                        "Optum",
                                        "Broadcom",
                                        "Alibaba",
                                        "Dropbox",
                                        "DoorDash",
                                        "Byju's",
                                        "Roche",
                                        "Instacart",
                                        "Bain & Company",
                                        "Docker",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_convertarraytodll",
                                "problem_name": "Convert Array to DLL",
                                "problem_slug": "convert-array-to-dll",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Ernst & Young",
                                        "Zynga",
                                        "Epic Systems",
                                        "Qualcomm",
                                        "Medtronic",
                                        "HCL Technologies",
                                        "Flipkart",
                                        "Deloitte",
                                        "Oracle",
                                        "Intel",
                                        "Snowflake",
                                        "Teladoc Health",
                                        "Splunk",
                                        "Cloudflare",
                                        "GE Healthcare",
                                        "Broadcom",
                                        "Bungie",
                                        "Bloomberg",
                                        "Stripe",
                                        "Twilio",
                                        "Visa",
                                        "Morgan Stanley",
                                        "ARM",
                                        "eBay",
                                        "MongoDB",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Create a Node structure containing val, next, and prev pointers. Initialize the head with the first element of nums[]."
                                        },
                                        {
                                            "hint": "Iterate through nums[], creating new nodes, linking them bidirectionally (prev and next). Return the head of the doubly linked list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Maintain head and tail pointers for easy insertions.",
                                            "question": "How do we handle inserting new elements into the DLL?"
                                        },
                                        {
                                            "answer": "A DLL allows both forward and backward traversal, making insertions and deletions easier.",
                                            "question": "Why use a doubly linked list instead of a singly linked list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Insert each element in sorted order using insertion sort logic (O(n)) or build and sort (O(n log n)).",
                                            "question": "How would you modify this to construct a sorted DLL instead of inserting in array order?"
                                        },
                                        {
                                            "answer": "Instead of setting tail.next = None, set it to head and update head.prev = tail.",
                                            "question": "How would you modify the function to create a circular DLL?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deleteheadofdll",
                                "problem_name": "Delete head of DLL",
                                "problem_slug": "delete-head-of-dll",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Ernst & Young",
                                        "Activision Blizzard",
                                        "American Express",
                                        "PayPal",
                                        "Red Hat",
                                        "McKinsey & Company",
                                        "Boston Consulting Group",
                                        "Swiggy",
                                        "Epic Games",
                                        "Shopify",
                                        "MongoDB",
                                        "Roblox",
                                        "Flipkart",
                                        "Splunk",
                                        "Oracle",
                                        "Zoho",
                                        "Ubisoft",
                                        "Visa",
                                        "DoorDash",
                                        "Reddit",
                                        "Medtronic",
                                        "Seagate Technology",
                                        "Wayfair",
                                        "Goldman Sachs",
                                        "Lyft",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head == None), return None. If there is only one node, remove it by returning None."
                                        },
                                        {
                                            "hint": "Update head to point to the next node (head.next). If the new head exists, set its prev = None to break the link. Return the updated head."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In languages with garbage collection (Python, Java), the old head is automatically garbage collected.\nIn C/C++, explicitly deallocate (delete head).",
                                            "question": "Does this operation free memory automatically?"
                                        },
                                        {
                                            "answer": "No, removing the tail requires updating the previous nodes next to None`.",
                                            "question": "Can we use the same logic for removing the tail node?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store the removed node in a temporary variable before modifying pointers.",
                                            "question": "How would you modify this to return the deleted node instead of just updating the list?"
                                        },
                                        {
                                            "answer": "Update the tails next pointer to point to the new head.",
                                            "question": "What if the list was circular instead of linear?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletetailofdll",
                                "problem_name": "Delete Tail of DLL",
                                "problem_slug": "delete-tail-of-dll",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "OYO Rooms",
                                        "McKinsey & Company",
                                        "Snowflake",
                                        "Ubisoft",
                                        "Morgan Stanley",
                                        "HCL Technologies",
                                        "Freshworks",
                                        "ARM",
                                        "Flipkart",
                                        "Visa",
                                        "Bain & Company",
                                        "Deloitte",
                                        "Siemens Healthineers",
                                        "Rockstar Games",
                                        "Reddit",
                                        "Airbnb",
                                        "Zomato",
                                        "Dropbox",
                                        "KPMG",
                                        "Shopify",
                                        "Seagate Technology",
                                        "Bungie",
                                        "Zoho",
                                        "Splunk",
                                        "Philips Healthcare",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head is None), return None immediately, as there is nothing to delete. If the list contains only one node (head.next is None), deleting the tail means returning an empty list (None)."
                                        },
                                        {
                                            "hint": "Use a pointer to traverse the list starting from the head. Stop when the pointer reaches the second-to-last node, i.e., when the next pointer of the current node points to the tail (node where next is None)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Traverse the list using a pointer until the current nodes next pointer points to the tail (node where next is None).",
                                            "question": "How do you identify the second-to-last node?"
                                        },
                                        {
                                            "answer": "Maintain a reference to the tail and second-to-last node during insertions and deletions. This avoids traversal for tail deletion but requires additional bookkeeping.",
                                            "question": "How would you efficiently delete the tail in a frequently accessed list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For a circular linked list, traverse the list to identify the tail (node whose next pointer points to the head). Update the second-to-last nodes next pointer to point to the head, maintaining the circular structure.",
                                            "question": "What if the list is circular?"
                                        },
                                        {
                                            "answer": "Maintain a reference to the tail and second-to-last node during insertions and deletions. This avoids traversal for tail deletion but requires additional bookkeeping.",
                                            "question": "How would you efficiently delete the tail in a frequently accessed list?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_deletekthelementofdll",
                                "problem_name": "Delete Kth Element of DLL",
                                "problem_slug": "delete-kth-element-of-dll",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Docker",
                                        "Square",
                                        "Bain & Company",
                                        "Activision Blizzard",
                                        "Zoho",
                                        "Airbnb",
                                        "Optum",
                                        "Rakuten",
                                        "Goldman Sachs",
                                        "Medtronic",
                                        "NVIDIA",
                                        "Western Digital",
                                        "Epic Systems",
                                        "Teladoc Health",
                                        "Red Hat",
                                        "Oracle",
                                        "Walmart",
                                        "Boston Consulting Group",
                                        "OYO Rooms",
                                        "Zomato",
                                        "Wayfair",
                                        "Roblox",
                                        "PwC",
                                        "Stripe",
                                        "Target",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If k=1: Update the head pointer to head.next to remove the head node. For k>1: Traverse the list to find the (k1)-th node (node preceding the target node)."
                                        },
                                        {
                                            "hint": "Use a pointer to traverse the list and keep a count of the current position. Stop when the pointer reaches the (k1)-th node, i.e., just before the node to be deleted."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "During traversal, check if the k-th node exists. If the traversal ends before reaching k, return the list unchanged.",
                                            "question": "What if k is greater than the length of the list?"
                                        },
                                        {
                                            "answer": "Traverse to the second-to-last node and set its next pointer to None.",
                                            "question": "How do you handle k-th node deletion when k is the last node?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a count of the total number of nodes to verify ks validity before traversing. Alternatively, maintain a pointer to the k-th node during updates.",
                                            "question": "How would you efficiently find and delete the k-th node in a frequently accessed list?"
                                        },
                                        {
                                            "answer": "Traverse the list until the node with the specific value is found, and update the preceding nodes next pointer to skip the target node.",
                                            "question": "How would you adapt this approach for deleting a node with a specific value instead of the k-th node?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_removinggivennodeindll",
                                "problem_name": "Removing given node in DLL",
                                "problem_slug": "removing-given-node-in-dll",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Databricks",
                                        "Western Digital",
                                        "Epic Systems",
                                        "Byju's",
                                        "Bloomberg",
                                        "PwC",
                                        "Unity Technologies",
                                        "Mastercard",
                                        "Medtronic",
                                        "Airbnb",
                                        "Electronic Arts",
                                        "Epic Games",
                                        "eBay",
                                        "Riot Games",
                                        "Bungie",
                                        "Johnson & Johnson",
                                        "Rakuten",
                                        "Goldman Sachs",
                                        "Teladoc Health",
                                        "Swiggy",
                                        "Twilio",
                                        "Deloitte",
                                        "Bain & Company",
                                        "Roche",
                                        "Philips Healthcare",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Update the previous nodes next pointer to skip the given node. If the given node has a next node, update the next nodes prev pointer to skip the given node."
                                        },
                                        {
                                            "hint": "If the given node is the tail (next == None), simply update prev.next = None. Ensure all pointers are updated correctly to avoid memory leaks or dangling references."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Without the head, we cannot traverse backward or forward for extra checks; we must rely only on the given nodes prev and next pointers.",
                                            "question": "How does this differ from deleting a node when the head is available?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Update the previous nodes next and next nodes prev, ensuring circularity is maintained.",
                                            "question": "How would you modify this for a circular doubly linked list?"
                                        },
                                        {
                                            "answer": "Deletion remains O(1), but ensuring sorting requires extra insert operations elsewhere.",
                                            "question": "What if the given node was part of a sorted doubly linked list?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertnodebeforeheadindll",
                                "problem_name": "Insert node before head in DLL",
                                "problem_slug": "insert-node-before-head-in-dll",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Goldman Sachs",
                                        "Electronic Arts",
                                        "Riot Games",
                                        "eBay",
                                        "Dropbox",
                                        "KPMG",
                                        "Reddit",
                                        "Lyft",
                                        "HCL Technologies",
                                        "Zynga",
                                        "Roche",
                                        "Walmart",
                                        "Red Hat",
                                        "Cerner",
                                        "Siemens Healthineers",
                                        "Target",
                                        "Snowflake",
                                        "PwC",
                                        "Ubisoft",
                                        "Morgan Stanley",
                                        "Rakuten",
                                        "Activision Blizzard",
                                        "PayPal",
                                        "Bungie",
                                        "Broadcom",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Create a new node with value X. Set the new nodes next pointer to the current head. Update the heads prev pointer to point to the new node"
                                        },
                                        {
                                            "hint": "Update head = new_node to reflect the new head. "
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, by adjusting prev and next pointers accordingly.",
                                            "question": "Can we modify this to insert before any node in the list?"
                                        },
                                        {
                                            "answer": "To maintain backward linkage, ensuring bidirectional traversal remains intact.",
                                            "question": "Why do we update prev of the current head?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Update the new nodes prev to the tail and tails next to the new head.",
                                            "question": " How would you modify this for a circular doubly linked list?"
                                        },
                                        {
                                            "answer": "Use locking mechanisms to prevent simultaneous modification issues.",
                                            "question": "How can we make this thread-safe in concurrent environments?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertnodebeforetailindll",
                                "problem_name": "Insert node before tail in DLL",
                                "problem_slug": "insert-node-before-tail-in-dll",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "DoorDash",
                                        "Flipkart",
                                        "Activision Blizzard",
                                        "Mastercard",
                                        "Broadcom",
                                        "Texas Instruments",
                                        "Bungie",
                                        "GE Healthcare",
                                        "Docker",
                                        "Zynga",
                                        "Qualcomm",
                                        "Alibaba",
                                        "Red Hat",
                                        "Instacart",
                                        "Intel",
                                        "Roche",
                                        "NVIDIA",
                                        "Twilio",
                                        "Robinhood",
                                        "Morgan Stanley",
                                        "AMD",
                                        "Electronic Arts",
                                        "Airbnb",
                                        "Byju's",
                                        "Oracle",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head = NULL), insert X as the only node. If the list has only one node, insert X before the existing node (making X the new head). If the list has at least two nodes, traverse to tails previous node and insert X before the tail."
                                        },
                                        {
                                            "hint": "Traverse to the second-last node. Insert X by adjusting prev and next pointers.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "No, a singly linked list does not support backward traversal efficiently, making it harder to insert before the tail without full traversal.",
                                            "question": "Can this problem be solved using a singly linked list?"
                                        },
                                        {
                                            "answer": "The problem explicitly asks to insert before the last node, so tails previous node is used.",
                                            "question": "Why do we need to insert before the tail, not after it?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Simply append the new node after the last node and update tail.",
                                            "question": "How would you modify the solution if you were allowed to insert after the tail instead?"
                                        },
                                        {
                                            "answer": "Arbitrary insertions require finding the correct position, leading to O(n) traversal.",
                                            "question": "How does this compare to inserting at arbitrary positions?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertnodebefore(kthnode)indll",
                                "problem_name": "Insert node before (kth node) in DLL",
                                "problem_slug": "insert-node-before-kth-node-in-dll",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "Splunk",
                                        "Zoho",
                                        "Intel",
                                        "JPMorgan Chase",
                                        "Philips Healthcare",
                                        "Etsy",
                                        "Square",
                                        "Shopify",
                                        "Visa",
                                        "Mastercard",
                                        "Instacart",
                                        "Medtronic",
                                        "HashiCorp",
                                        "Electronic Arts",
                                        "PayPal",
                                        "Uber",
                                        "Deloitte",
                                        "NVIDIA",
                                        "Robinhood",
                                        "Roblox",
                                        "Target",
                                        "Boston Consulting Group",
                                        "Johnson & Johnson",
                                        "Rakuten",
                                        "Siemens Healthineers",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "If the list is empty (head = NULL), insert X as the only node. If K = 1, insert X before the first node, making it the new head. If K is greater than the number of nodes, insert at the end."
                                        },
                                        {
                                            "hint": "Use a pointer to move K-1 steps to locate the (K-1)th node. If K exceeds the length, insert at the end. Update prev and next pointers of adjacent nodes."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Insert X as the only node, making it the new head.",
                                            "question": "What happens if the list is empty (head = NULL)?"
                                        },
                                        {
                                            "answer": "Yes! If K exceeds the number of nodes, append X at the tail.",
                                            "question": "Can we insert at the end if K > length of list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Finding Kth node remains O(K), but insertion is harder since theres no prev pointer.",
                                            "question": "How would this approach change if the list were a singly linked list?"
                                        },
                                        {
                                            "answer": "Convert K into a 1-based position from the end using count - |K|.",
                                            "question": "What if K was given as a negative index (e.g., -1 for inserting before the last node)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basiclinkedlist_insertbeforegivennodeindll",
                                "problem_name": "Insert before given node in DLL",
                                "problem_slug": "insert-before-given-node-in-dll",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "Zomato",
                                        "Deloitte",
                                        "OYO Rooms",
                                        "DoorDash",
                                        "Pinterest",
                                        "Epic Systems",
                                        "Electronic Arts",
                                        "Walmart",
                                        "Goldman Sachs",
                                        "Target",
                                        "Bain & Company",
                                        "Airbnb",
                                        "Johnson & Johnson",
                                        "Robinhood",
                                        "Intel",
                                        "HashiCorp",
                                        "Dropbox",
                                        "Instacart",
                                        "Swiggy",
                                        "Rakuten",
                                        "Chewy",
                                        "IBM",
                                        "Boston Consulting Group",
                                        "Unity Technologies",
                                        "Ubisoft",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Create a new node with value X. Find the previous node (prev_node) of given_node using given_node->prev."
                                        },
                                        {
                                            "hint": "Update the pointers: prev_node->next = new_node new_node->prev = prev_node new_node->next = given_node given_node->prev = new_node"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Unlike singly linked lists (O(n) for backward traversal), DLLs allow direct access to prev, making insertion constant time.",
                                            "question": "Why does this approach work in O(1)?"
                                        },
                                        {
                                            "answer": "Since we are given a node inside the list, and the node before it is guaranteed to exist, we dont need the head.",
                                            "question": "Why do we NOT need access to the head?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "O(n) complexity instead of O(1), since we must traverse from head to find prev_node.",
                                            "question": "How would this change if the list was a singly linked list (SLL)?"
                                        },
                                        {
                                            "answer": "Update given_node->next instead of prev.",
                                            "question": "How can we modify this to insert X after given_node instead?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_logicbuilding",
                        "subcategory_name": "Logic Building",
                        "subcategory_slug": "logic-building",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_logicbuilding_addtwonumbersinll",
                                "problem_name": "Add two numbers in LL",
                                "problem_slug": "add-two-numbers-in-ll",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Siemens Healthineers",
                                        "MongoDB",
                                        "Qualcomm",
                                        "Cloudflare",
                                        "Square",
                                        "Chewy",
                                        "KPMG",
                                        "Walmart",
                                        "Bungie",
                                        "Visa",
                                        "Wayfair",
                                        "Ernst & Young",
                                        "Flipkart",
                                        "GE Healthcare",
                                        "Splunk",
                                        "Freshworks",
                                        "Morgan Stanley",
                                        "Snowflake",
                                        "Nutanix",
                                        "Shopify",
                                        "Seagate Technology",
                                        "Alibaba",
                                        "McKinsey & Company",
                                        "Databricks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem has a practical real-world application in the development of large integer arithmetic operations, such as those required in cryptography, data encryption, and secure communications. In these fields, numbers used are often so large that they cannot be held in a single computer word, leading to the use of linked lists to store each digit. The ability to add (and by extension, subtract, multiply and divide) such numbers is a foundational requirement. Cryptographic algorithms like RSA, which form the backbone of secure internet transactions, rely heavily on this concept.",
                                    "hints": [
                                        {
                                            "hint": "Initialize variables carry = 0 for tracking carry-over from previous sum. dummy_head to store the result list. current pointer for traversal."
                                        },
                                        {
                                            "hint": "Compute sum = l1.val + l2.val + carry. Extract new_digit = sum % 10, and update carry = sum // 10. Create a new node with new_digit and attach it to the result list. Move l1 and l2 to their next nodes if they exist."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The digits are already in reverse order, so addition naturally starts from the least significant digit (1s place).",
                                            "question": "Why can we process digits directly without reversing the lists?"
                                        },
                                        {
                                            "answer": "Maintain a carry variable to track carry-over from the previous sum.\nIf carry > 0 after processing all nodes, add a new node with value carry.",
                                            "question": "How do we handle carry propagation?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Reverse both lists first, then apply the same approach.\nAlternatively, use recursion with backtracking.",
                                            "question": "How would this approach change if the digits were stored in forward order instead?"
                                        },
                                        {
                                            "answer": "Yes, implement borrow handling instead of carry propagation.",
                                            "question": "Can we modify this to support subtraction instead of addition?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_logicbuilding_segregateoddandevennodesinll",
                                "problem_name": "Segregate odd and even nodes in LL",
                                "problem_slug": "segregate-odd-and-even-nodes-in-ll",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Swiggy",
                                        "Western Digital",
                                        "Lyft",
                                        "HashiCorp",
                                        "Byju's",
                                        "Ernst & Young",
                                        "Zynga",
                                        "PayPal",
                                        "Medtronic",
                                        "Philips Healthcare",
                                        "Optum",
                                        "JPMorgan Chase",
                                        "Oracle",
                                        "Reddit",
                                        "NVIDIA",
                                        "OYO Rooms",
                                        "Teladoc Health",
                                        "Epic Games",
                                        "Square",
                                        "Cloudflare",
                                        "DoorDash",
                                        "Morgan Stanley",
                                        "Roblox",
                                        "ARM",
                                        "Rockstar Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem statement exemplifies the concept of list reordering, which is essential in many real-world applications. For instance, music streaming apps like Spotify or Pandora use similar algorithms to organize queues or playlists. If you ever wanted to change the order of your playlist, where odd numbered songs are grouped at the start followed by the even numbered ones, while keeping the order of the songs in each group the same, a method like this would come in handy. Additionally, such reordering tasks are also common in sorting and optimizing search results in a multitude of software applications.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would require scanning the list, separating odd/even indices into two lists, and merging them back. However, this results in O(n) space, which is inefficient."
                                        },
                                        {
                                            "hint": "Maintain Two Pointers, odd_head for odd-indexed nodes. even_head for even-indexed nodes. odd pointer moves by odd.next = even.next. even pointer moves by even.next = odd.next. Merge Both Groups, Once traversal ends, link the last odd node to even_head."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "This preserves the original order inside each group.",
                                            "question": "Why do we need two separate lists for odd and even nodes?"
                                        },
                                        {
                                            "answer": "Parallel Computing: Scheduling tasks at alternate intervals.\nData Processing: Separating odd/even indexed elements efficiently.",
                                            "question": "How does this relate to real-world applications?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Simply swap the starting points, i.e., even_head first.",
                                            "question": "How would this change if we grouped even indices first instead of odd?"
                                        },
                                        {
                                            "answer": "Yes! Use k pointers and merge at the end.",
                                            "question": "Can we modify this to work for k-grouping instead of just odd/even?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_logicbuilding_sortallof0's1'sand2's",
                                "problem_name": "Sort a LL of 0's 1's and 2's",
                                "problem_slug": "sort-a-ll-of-0's-1's-and-2's",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Target",
                                        "Bungie",
                                        "Zoho",
                                        "Snowflake",
                                        "Alibaba",
                                        "Oracle",
                                        "Uber",
                                        "Rockstar Games",
                                        "Activision Blizzard",
                                        "Swiggy",
                                        "Splunk",
                                        "Bain & Company",
                                        "eBay",
                                        "Siemens Healthineers",
                                        "Salesforce",
                                        "Seagate Technology",
                                        "Reddit",
                                        "Chewy",
                                        "Pinterest",
                                        "American Express",
                                        "Visa",
                                        "Ubisoft",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Roblox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Use three dummy pointers (zero_head, one_head, two_head) to track separate linked lists for 0s, 1s, and 2s."
                                        },
                                        {
                                            "hint": "Traverse the original list and distribute nodes into the corresponding lists. Merge the three lists by updating links: Connect the 0s list  1s list  2s list Ensure the tail of the last list points to NULL."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Modifying links directly while traversing can lead to broken links or require multiple scans.\nUsing three separate lists ensures stable sorting without losing track of nodes.",
                                            "question": "Why do we need three separate dummy lists instead of modifying the original list?"
                                        },
                                        {
                                            "answer": "The algorithm processes the list normally, but no rearrangement is needed since pointers remain unchanged.",
                                            "question": "What happens if the input list already has sorted 0s, 1s, and 2s?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use bucket sort logic but with hash maps to store frequency counts.\nInstead of three pointers, use multiple dummy lists for each unique value.",
                                            "question": "How can this be extended to handle a linked list with arbitrary numbers instead of just 0, 1, and 2?"
                                        },
                                        {
                                            "answer": "Yes, generalize it by:\nCreating k+1 linked lists.\nDistributing nodes into respective buckets.\nMerging all buckets into a single list.",
                                            "question": "Can this be modified to sort linked lists containing values from 0 to k?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_logicbuilding_removenthnodefromthebackofthell",
                                "problem_name": "Remove Nth node from the back of the LL",
                                "problem_slug": "remove-nth-node-from-the-back-of-the-ll",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "Byju's",
                                        "Electronic Arts",
                                        "Instacart",
                                        "Rockstar Games",
                                        "Walmart",
                                        "IBM",
                                        "Oracle",
                                        "Docker",
                                        "Ubisoft",
                                        "PayPal",
                                        "Airbnb",
                                        "Activision Blizzard",
                                        "Siemens Healthineers",
                                        "Micron Technology",
                                        "Qualcomm",
                                        "Dropbox",
                                        "KPMG",
                                        "Morgan Stanley",
                                        "Bloomberg",
                                        "HCL Technologies",
                                        "Teladoc Health",
                                        "Stripe",
                                        "Epic Systems",
                                        "Reddit",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach involves:  Finding the length of the linked list (O(n)). Removing the (length - n + 1)th node from the start (O(n))."
                                        },
                                        {
                                            "hint": "Use two pointers: fast and slow. Move fast n steps ahead. Move slow and fast together until fast reaches the end. slow will now be just before the node to remove. Adjust pointers to delete the nth node from the end."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "To handle edge cases where the first node needs to be removed (n = length of list).\nWithout a dummy node, removing the first node requires a separate condition.",
                                            "question": "Why do we use a dummy node?"
                                        },
                                        {
                                            "answer": "This ensures that when fast reaches the end, slow will be exactly before the node to remove.",
                                            "question": "Why do we move fast pointer n steps ahead first?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The algorithm remains the same, but pointer updates would also need to update prev pointers.",
                                            "question": " How would this approach change if the linked list were doubly linked?"
                                        },
                                        {
                                            "answer": "Yes, using batch processing where the fast pointer moves in parallel for multiple lists.",
                                            "question": "Can this be extended to remove multiple nth nodes from different lists efficiently?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_logicbuilding_reverseall",
                                "problem_name": "Reverse a LL",
                                "problem_slug": "reverse-a-ll",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Robinhood",
                                        "Bungie",
                                        "Philips Healthcare",
                                        "Rockstar Games",
                                        "PayPal",
                                        "Mastercard",
                                        "JPMorgan Chase",
                                        "Bain & Company",
                                        "Teladoc Health",
                                        "Roche",
                                        "Broadcom",
                                        "IBM",
                                        "Target",
                                        "AMD",
                                        "Cloudflare",
                                        "Reddit",
                                        "Stripe",
                                        "McKinsey & Company",
                                        "Walmart",
                                        "Epic Systems",
                                        "Zomato",
                                        "DoorDash",
                                        "OYO Rooms",
                                        "Ubisoft",
                                        "Airbnb",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve: Storing nodes in an array. Reconstructing the linked list from the array in reverse order. Drawback: Uses O(n) extra space, violating the in-place constraint."
                                        },
                                        {
                                            "hint": "Use three pointers: prev, current, and next: Initialize prev = NULL, current = head. Iterate through the list, reversing links (current.next = prev). Move prev and current forward. When current becomes NULL, prev points to the new head."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Prev stores the reversed portion,\nCurrent processes the current node,\nNext saves the next node before changing the link.",
                                            "question": "Why do we need three pointers?"
                                        },
                                        {
                                            "answer": "Iterative (O(n) time, O(1) space)  Best for large lists.\nRecursive (O(n) time, O(n) space)  Uses call stack, making it less efficient for deep recursion.",
                                            "question": "How does this compare to using recursion?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Modify the algorithm to:\nTraverse to m.\nReverse only the sublist.\nReconnect it to the rest of the list.",
                                            "question": "Can we reverse only a portion of the linked list (e.g., positions m to n)?"
                                        },
                                        {
                                            "answer": "Swap next and prev pointers for each node.",
                                            "question": "How does this approach change for a doubly linked list?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_faqs(medium)",
                        "subcategory_name": "FAQs (Medium)",
                        "subcategory_slug": "faqs--medium",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_addonetoanumberrepresentedbyll",
                                "problem_name": "Add one to a number represented by LL",
                                "problem_slug": "add-one-to-a-number-represented-by-ll",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "Teladoc Health",
                                        "PwC",
                                        "GE Healthcare",
                                        "JPMorgan Chase",
                                        "Goldman Sachs",
                                        "Shopify",
                                        "OYO Rooms",
                                        "DoorDash",
                                        "Siemens Healthineers",
                                        "Activision Blizzard",
                                        "HashiCorp",
                                        "Zynga",
                                        "Dropbox",
                                        "Rockstar Games",
                                        "Intel",
                                        "Airbnb",
                                        "Splunk",
                                        "Alibaba",
                                        "ARM",
                                        "Cloudflare",
                                        "Freshworks",
                                        "Micron Technology",
                                        "Boston Consulting Group",
                                        "Roblox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem exercises the fundamental concept of linked list manipulation which finds real-world application in modern software systems. For instance, web browsers' history function is implemented via a doubly linked list, each node representing a visited webpage. When a user clicks on a link, a node is added to the list. When they click 'back' or 'forward', the browser traverses the list to the previous or next node, respectively. Thus, being able to manipulate linked lists, like the problem describes, is crucial in creating effective navigation functionality in web browsers.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach involves Converting the linked list to an integer (O(n)). Adding 1, then reconstructing the linked list (O(n)). Drawback: Uses extra memory (O(n)) for number conversion."
                                        },
                                        {
                                            "hint": "Reverse the linked list (O(n)) to make the least significant digit the head. Perform normal addition with carry (O(n)). Reverse the linked list back (O(n)) to restore order."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The easiest place to add 1 is at the least significant digit, which is at the end of the list.\nReversing the list makes addition simpler (just like manual addition from right to left).",
                                            "question": "Why do we reverse the list first?"
                                        },
                                        {
                                            "answer": "Yes, using recursion (O(n) space) to reach the last node first.\nHowever, recursion consumes stack space, making it less efficient than an iterative solution.",
                                            "question": "Can this be solved without reversing the list?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Push all values into a stack (O(n) space), then pop and add 1.",
                                            "question": "Can this problem be solved using a stack instead of reversing?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_checkifllispalindromeornot",
                                "problem_name": "Check if LL is palindrome or not",
                                "problem_slug": "check-if-ll-is-palindrome-or-not",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Intel",
                                        "Seagate Technology",
                                        "Bloomberg",
                                        "Cloudflare",
                                        "Johnson & Johnson",
                                        "Teladoc Health",
                                        "Micron Technology",
                                        "Lyft",
                                        "Activision Blizzard",
                                        "Shopify",
                                        "Freshworks",
                                        "MongoDB",
                                        "Alibaba",
                                        "Oracle",
                                        "DoorDash",
                                        "Boston Consulting Group",
                                        "PayPal",
                                        "Robinhood",
                                        "Morgan Stanley",
                                        "Roche",
                                        "Optum",
                                        "Snowflake",
                                        "Zynga",
                                        "Etsy",
                                        "PwC",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Linked list operations like this are used in many software applications that require dynamic memory management. In particular, the concept of checking if a linked list is a palindrome has a fun association with text processing software. For example, in apps that check if a string of text is a palindrome (a word, phrase, or sequence that reads the same backwards as forwards, like \"madam\" or \"12321\"), a linked list can be utilized to store characters or digits in sequence and then used to validate the palindrome property. This type of string validation is practical in areas such as DNA sequencing where bioinformatics software often needs to check palindromic sequences. In more general terms, this problem signifies the usefulness and versatility of linked lists in managing and manipulating data.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve:  Storing all the digits in an array (O(n) space). Checking if the array is a palindrome (O(n) time). Drawback: Uses O(n) extra space, violating in-place constraints."
                                        },
                                        {
                                            "hint": "To check for a palindrome in O(n) time and O(1) space, we use the slow and fast pointer technique:  Find the middle of the list using two pointers (slow and fast). Reverse the second half of the linked list. Compare the first half with the reversed second half."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "We only need to check the latter half against the first half.\nThis keeps the process in-place (O(1) space).",
                                            "question": "Why do we reverse only the second half instead of the full list?"
                                        },
                                        {
                                            "answer": "In interview settings, modifying input structure might be disallowed.\nIf restoration isnt required, skip this step.",
                                            "question": "Why do we restore the list after checking?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Find the midpoint using slow-fast pointers, then break the cycle temporarily.",
                                            "question": "What if the list was circular?"
                                        },
                                        {
                                            "answer": "Yes, but recursion uses O(n) stack space, making it less efficient.",
                                            "question": "Can this be solved recursively?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_findtheintersectionpointofyll",
                                "problem_name": "Find the intersection point of Y LL",
                                "problem_slug": "find-the-intersection-point-of-y-ll",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Pinterest",
                                        "PayPal",
                                        "ARM",
                                        "Bain & Company",
                                        "Western Digital",
                                        "Texas Instruments",
                                        "Bloomberg",
                                        "Walmart",
                                        "Unity Technologies",
                                        "Morgan Stanley",
                                        "OYO Rooms",
                                        "Riot Games",
                                        "Splunk",
                                        "Bungie",
                                        "MongoDB",
                                        "Optum",
                                        "Alibaba",
                                        "Intel",
                                        "HCL Technologies",
                                        "Rakuten",
                                        "Cloudflare",
                                        "Dropbox",
                                        "Airbnb",
                                        "Wayfair",
                                        "Roche",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, commonly known as the \"Linked List Intersection\" problem, serves as a fundamental concept in various real-world scenarios in the software industry. For instance, Git, a widely used version control system, utilizes this concept to identify the \"merge base\" of two branches - the point where the branches diverged. Finding this merge base is necessary for Git to efficiently and accurately merge the changes from two branches. To find the merge base, Git internally represents the commits as a linked list, with each node pointing to its parent commit(s), and essentially solves the Linked List Intersection problem.",
                                    "hints": [
                                        {
                                            "hint": "Pointer A starts at headA, and Pointer B starts at headB. When Pointer A reaches the end of list A, move it to headB. When Pointer B reaches the end of list B, move it to headA."
                                        },
                                        {
                                            "hint": "If the lists intersect, the pointers will meet at the intersection. If they dont, both will reach NULL at the same time."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By switching at the end, both pointers traverse the same total distance.\nThis guarantees that they meet at the intersection node if one exists.",
                                            "question": "Why does switching pointers ensure they meet at the intersection?"
                                        },
                                        {
                                            "answer": "No, since we assume lists do not contain cycles.\nFor cycles, Floyds Cycle Detection (Tortoise and Hare Algorithm) is required.",
                                            "question": "Can this approach be used if the lists have cycles?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "We could append one list to the other, making intersection detection simpler.",
                                            "question": "What if we could modify the lists?"
                                        },
                                        {
                                            "answer": "The problem assumes one intersection, but multiple intersections require extra tracking.",
                                            "question": "How can this be extended to detect multiple intersections?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_detectaloopinll",
                                "problem_name": "Detect a loop in LL",
                                "problem_slug": "detect-a-loop-in-ll",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Cloudflare",
                                        "Western Digital",
                                        "Wayfair",
                                        "Salesforce",
                                        "Lyft",
                                        "Ubisoft",
                                        "Airbnb",
                                        "Target",
                                        "Johnson & Johnson",
                                        "Ernst & Young",
                                        "Medtronic",
                                        "Morgan Stanley",
                                        "HCL Technologies",
                                        "Epic Systems",
                                        "Broadcom",
                                        "Twilio",
                                        "Roblox",
                                        "Intel",
                                        "Walmart",
                                        "Zoho",
                                        "Rakuten",
                                        "eBay",
                                        "McKinsey & Company",
                                        "Riot Games",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would use a hash set (O(n) space) to track visited nodes and detect a loop."
                                        },
                                        {
                                            "hint": "The Floyds Tortoise and Hare Algorithm uses:  A slow pointer (slow)  moves one step at a time. A fast pointer (fast)  moves two steps at a time."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The fast pointer moves twice as fast, so: If slow moves x steps, fast moves 2x steps. This guarantees that fast will eventually lap slow inside the cycle.",
                                            "question": "Why does the fast pointer eventually catch up if a cycle exists? "
                                        },
                                        {
                                            "answer": "Yes! After detecting the cycle, reset slow to head and move both slow and fast one step at a time. The node where they meet again is the cycles start node.",
                                            "question": "Can we detect where the cycle begins (pos)? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use two-pointer reset technique: After detection, reset slow to head and move both pointers one step at a time. The first meeting point is the start of the cycle.",
                                            "question": " How would you modify this to return the node where the cycle begins? "
                                        },
                                        {
                                            "answer": "After finding the cycle start node, traverse the cycle to find the last node (tail). Set tail.next = NULL to break the cycle.",
                                            "question": "What if we wanted to remove the cycle instead of just detecting it? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_findthestartingpointinll",
                                "problem_name": "Find the starting point in LL",
                                "problem_slug": "find-the-starting-point-in-ll",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "Red Hat",
                                        "Reddit",
                                        "Epic Systems",
                                        "Instacart",
                                        "Zoho",
                                        "Ernst & Young",
                                        "MongoDB",
                                        "Square",
                                        "NVIDIA",
                                        "Robinhood",
                                        "OYO Rooms",
                                        "Rockstar Games",
                                        "Zynga",
                                        "Cloudflare",
                                        "Salesforce",
                                        "Airbnb",
                                        "Roblox",
                                        "Databricks",
                                        "Boston Consulting Group",
                                        "Cerner",
                                        "Oracle",
                                        "Visa",
                                        "Bain & Company",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One real-world application of this problem is in detecting memory leaks in computer software. Memory leaks occur when a computer program incorrectly manages memory allocations, leading to a decrease in available memory and causing the system to slow down or crash. By using a linked list and understanding where a 'loop' or cycle starts, programmers can trace back and identify where memory is not being freed properly, leading to efficient bug fixing and enhanced software performance.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach uses a HashSet (O(n) space) to track visited nodes. However, a more efficient O(1) space solution exists using Floyds Cycle Detection Algorithm."
                                        },
                                        {
                                            "hint": "Use Two Pointers (slow and fast) to detect a cycle. If they meet inside the cycle, reset slow to head and move both pointers one step at a time. The meeting point is the cycles start node."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "When slow and fast meet inside the cycle, the distance from head to cycle start (X) is equal to the distance from meeting point to X. Moving both pointers one step at a time guarantees they meet exactly at the cycles start node.",
                                            "question": "Why does resetting slow to head work? "
                                        },
                                        {
                                            "answer": " It modifies pointers without extra memory (unlike the O(n) HashSet method).",
                                            "question": "Why does this approach use O(1) space?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "HashSet (O(n) space) stores visited nodes but doesnt modify pointers. Floyds Algorithm (O(1) space) is more memory-efficient",
                                            "question": "How does this compare to the HashSet approach? "
                                        },
                                        {
                                            "answer": "Find the cycles start node. Traverse to the last node inside the cycle. Set last_node.next = NULL to remove the cycle.",
                                            "question": "How would you modify the list to remove the cycle? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "find_middle_of_linked_list",
                                "problem_name": "Find Middle of Linked List",
                                "problem_slug": "find-middle-of-linked-list",
                                "problem_rank": 5,
                                "misc": null,
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_lengthofloopinll",
                                "problem_name": "Length of loop in LL",
                                "problem_slug": "length-of-loop-in-ll",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Etsy",
                                        "Broadcom",
                                        "DoorDash",
                                        "Dropbox",
                                        "Boston Consulting Group",
                                        "Databricks",
                                        "Epic Games",
                                        "Qualcomm",
                                        "Zomato",
                                        "Wayfair",
                                        "eBay",
                                        "Cerner",
                                        "Micron Technology",
                                        "Rockstar Games",
                                        "Activision Blizzard",
                                        "Zynga",
                                        "KPMG",
                                        "Oracle",
                                        "Riot Games",
                                        "Bloomberg",
                                        "AMD",
                                        "Western Digital",
                                        "ARM",
                                        "GE Healthcare",
                                        "Flipkart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem underpins many real-world applications particularly in system software and web development fields. It is commonly used in debugging or troubleshooting memory leaks and infinite loops. For example, in garbage collection frameworks used in languages like Java and .NET, understanding the cycle detection in linked lists is crucial to manage memory efficiently and ensure that objects involved in a cycle are not prematurely deallocated. Additionally, in web crawling or network routing algorithms, it's important to prevent infinite loops by understanding and identifying cycles within networks.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach uses a HashSet (O(n) space) to track visited nodes. However, a more efficient O(1) space solution exists using Floyds Cycle Detection Algorithm."
                                        },
                                        {
                                            "hint": "Use Two Pointers (slow and fast) to detect a cycle. If they meet inside the cycle, initialize a counter and traverse the loop to count its length."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Once they meet inside the cycle, slow traverses the full cycle back to fast, counting the number of steps.",
                                            "question": "Why does moving slow again count the loop length? "
                                        },
                                        {
                                            "answer": "Since fast moves twice as fast, it catches up with slow inside the cycle.",
                                            "question": "Why does slow always meet fast inside the loop? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": " Yes, but recursion adds O(n) stack space, making it less efficient.",
                                            "question": "Can we solve this problem using recursion?"
                                        },
                                        {
                                            "answer": "A singly linked list cannot have multiple loops since each node has only one next pointer.",
                                            "question": "What if the list had multiple loops? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(medium)_deletethemiddlenodeinll",
                                "problem_name": "Delete the middle node in LL",
                                "problem_slug": "delete-the-middle-node-in-ll",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Johnson & Johnson",
                                        "Electronic Arts",
                                        "Instacart",
                                        "JPMorgan Chase",
                                        "IBM",
                                        "Etsy",
                                        "Bungie",
                                        "Reddit",
                                        "HCL Technologies",
                                        "Square",
                                        "Alibaba",
                                        "Dropbox",
                                        "Snowflake",
                                        "Ubisoft",
                                        "PayPal",
                                        "ARM",
                                        "Western Digital",
                                        "Stripe",
                                        "Rakuten",
                                        "Rockstar Games",
                                        "Teladoc Health",
                                        "Cerner",
                                        "Optum",
                                        "Uber",
                                        "Pinterest",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concept of this problem can be found in applications such as music streaming apps like Spotify or Apple Music, where a linked list data structure can be used to organise songs in a playlist. Performing operations such as deleting a song, or in this case a \"middle node,\" is a common task in managing these playlists.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would:  Find the length n of the list (O(n)). Traverse again to the (n/2)th node and delete it (O(n)). Drawback: Requires two passes (O(n) time)."
                                        },
                                        {
                                            "hint": "To delete the middle node in a single pass:  Use two pointers (slow and fast). Move slow one step at a time and fast two steps at a time. When fast reaches the end, slow will be at the middle node. Delete the middle node by skipping it."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since fast moves twice as fast as slow, slow will reach the middle when fast reaches the end.",
                                            "question": "Why does the two-pointer approach work? "
                                        },
                                        {
                                            "answer": "prev tracks the node before slow, allowing us to delete slow efficiently.",
                                            "question": " Why do we need the prev pointer? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Use the same approach, but move slow k-1 steps.",
                                            "question": "Can this be modified to delete the k-th node instead of the middle node? "
                                        },
                                        {
                                            "answer": "The logic remains the same, but deletion is easier using prev.",
                                            "question": "How does this approach change for a doubly linked list? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_faqs(hard)",
                        "subcategory_name": "FAQs (Hard)",
                        "subcategory_slug": "faqs--hard",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_reversellingroupofgivensizek",
                                "problem_name": "Reverse LL in group of given size K",
                                "problem_slug": "reverse-ll-in-group-of-given-size-k",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Ernst & Young",
                                        "Rakuten",
                                        "Morgan Stanley",
                                        "McKinsey & Company",
                                        "Epic Games",
                                        "Riot Games",
                                        "Chewy",
                                        "Flipkart",
                                        "Qualcomm",
                                        "Visa",
                                        "Robinhood",
                                        "Deloitte",
                                        "HCL Technologies",
                                        "NVIDIA",
                                        "Databricks",
                                        "Cloudflare",
                                        "Roblox",
                                        "eBay",
                                        "Airbnb",
                                        "Splunk",
                                        "Pinterest",
                                        "Seagate Technology",
                                        "Target",
                                        "Bungie",
                                        "Activision Blizzard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This particular programming problem simulates situations in data manipulation where batch processing is required. It's a common task in industries like finance or telecommunication where massive amount of data are handled and operations need to be done in chunks or groups to optimize overall performance. It's also crucial in building features such as 'Undo' in various software like text editors or graphic design tools, where actions are reversed in certain groups, making it very relevant real-world application, indeed.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve:  Extracting all nodes into an array (O(n) space). Reversing every k-sized subarray. Rebuilding the list (O(n) time)."
                                        },
                                        {
                                            "hint": "Traverse the list to find k-sized groups. Reverse each k-group iteratively. Maintain pointers to link reversed groups correctly. If a remaining group has fewer than k nodes, keep it as is."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The last remaining nodes (less than k) are not reversed.",
                                            "question": "What happens if n is not a multiple of k? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Introduce a flip flag: Reverse when flip = true Skip when flip = false.",
                                            "question": " What if we needed to reverse only alternate k-groups? "
                                        },
                                        {
                                            "answer": "Recursive method (O(n) space) adds function calls. Iterative (O(1) space) is preferred for large inputs.",
                                            "question": " How does this compare to recursive reversal? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_rotateall",
                                "problem_name": "Rotate a LL",
                                "problem_slug": "rotate-a-ll",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "HCL Technologies",
                                        "American Express",
                                        "Medtronic",
                                        "Pinterest",
                                        "Databricks",
                                        "Activision Blizzard",
                                        "Micron Technology",
                                        "Qualcomm",
                                        "HashiCorp",
                                        "DoorDash",
                                        "Johnson & Johnson",
                                        "Docker",
                                        "Salesforce",
                                        "GE Healthcare",
                                        "Bloomberg",
                                        "MongoDB",
                                        "Target",
                                        "Roche",
                                        "Square",
                                        "McKinsey & Company",
                                        "JPMorgan Chase",
                                        "Mastercard",
                                        "Cloudflare",
                                        "Boston Consulting Group",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One practical application of this programming problem in the real world can be found in the development of audio streaming applications. Developers often implement a form of linked list to manage the queue of songs. When a user decides to skip a certain number of songs, a function similar to rotating a linked list by 'k' places can be used. This underlying concept helps to efficiently manage the play order without needing to rearrange or create new lists.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would:  Perform k shifts one by one, moving the last node to the front (O(k * n) time). Use extra space (O(n)) by converting the list to an array, shifting elements, and reconstructing the list."
                                        },
                                        {
                                            "hint": "Find the Length of the List (O(n))  Determine n (number of nodes) to optimize shifts (k = k % n). Locate the New Tail (O(n))  The new tail is at (n - k)th node. The new head is at (n - k + 1)th node. Modify Links (O(1))  Set new_tail.next = NULL to break the list. Connect the old tail to the old head."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If k > n, shifting n times results in the same list. Example: For n = 5, k = 7, shifting 7 times is the same as shifting 2 times (7 % 5 = 2).",
                                            "question": "Why do we compute k % n instead of just shifting k times? "
                                        },
                                        {
                                            "answer": "Because shifting k places pushes the last k nodes to the front. Example: [1,2,3,4,5], shifting k=2 results in [4,5,1,2,3].",
                                            "question": "Why is the (n - k)th node the new tail? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of n - k, shift the list from the k-th node.",
                                            "question": "What if we needed to shift left instead of right? "
                                        },
                                        {
                                            "answer": "Convert k to positive modulo (k = (k + n) % n).",
                                            "question": "What if k is negative (shifting left instead of right)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_mergesortedlists",
                                "problem_name": "Merge two Sorted Lists",
                                "problem_slug": "merge-sorted-lists-",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Johnson & Johnson",
                                        "IBM",
                                        "Salesforce",
                                        "Walmart",
                                        "NVIDIA",
                                        "Cloudflare",
                                        "Morgan Stanley",
                                        "Robinhood",
                                        "GE Healthcare",
                                        "Alibaba",
                                        "KPMG",
                                        "Epic Systems",
                                        "Databricks",
                                        "Bain & Company",
                                        "Zoho",
                                        "Chewy",
                                        "HCL Technologies",
                                        "Swiggy",
                                        "Intel",
                                        "Activision Blizzard",
                                        "Zynga",
                                        "OYO Rooms",
                                        "Philips Healthcare",
                                        "Epic Games",
                                        "Oracle",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The problem of merging two sorted linked lists, as stated above, is a heart of many applications that deal with sorted data. For example, in GitHub, when two developers work on the same code base (their own linked lists of code), and after they have made their changes, GitHub has to 'merge' the two versions into one sorted list (code base) while keeping the modifications from both developers intact. This problem simulates that scenario. Such algorithms also underpin 'merge sort', a commonly used sorting algorithm in computer programming. Similarly, database management systems often use such concepts when merging data coming from multiple sources.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would: Extract all nodes into an array (O(n + m) space). Sort the array (O((n + m) log(n + m)) time). Reconstruct the linked list (O(n + m) time)."
                                        },
                                        {
                                            "hint": "Use two pointers (p1 for list1 and p2 for list2). Compare nodes and attach the smaller one to the result list. Advance the pointer of the list from which the node was taken. Once one list is exhausted, attach the remaining nodes from the other list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It simplifies handling edge cases (e.g., when the first node should come from list2 instead of list1).",
                                            "question": " Why do we use a dummy head node? "
                                        },
                                        {
                                            "answer": "Use Min-Heap (O(k log n)) for merging k lists.",
                                            "question": "What if we had more than two lists to merge? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Find the tail and properly link the merged list back to it.",
                                            "question": "How would this approach change for circular linked lists? "
                                        },
                                        {
                                            "answer": "Use the same approach but compare in reverse (> instead of <).",
                                            "question": "What if we needed to merge lists in descending order? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_flatteningofll",
                                "problem_name": "Flattening of LL",
                                "problem_slug": "flattening-of-ll",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Western Digital",
                                        "Riot Games",
                                        "Alibaba",
                                        "Optum",
                                        "Unity Technologies",
                                        "Bloomberg",
                                        "KPMG",
                                        "PwC",
                                        "Morgan Stanley",
                                        "HCL Technologies",
                                        "DoorDash",
                                        "Siemens Healthineers",
                                        "IBM",
                                        "Airbnb",
                                        "Robinhood",
                                        "Walmart",
                                        "Docker",
                                        "Broadcom",
                                        "Intel",
                                        "Roche",
                                        "Goldman Sachs",
                                        "Rockstar Games",
                                        "Zoho",
                                        "Snowflake",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One of the real-world applications of this problem is seen in the representation and manipulation of complex hierarchical structures, such as the Document Object Model (DOM) in web development. The DOM is essentially a tree-like structure where each HTML element is a node with potential child and sibling nodes. The concept of flattening a nested structure is commonly used in DOM manipulation for a variety of reasons, including improving the performance of traversing the structure or simplifying the complexity when applying certain operations. The same principle can be applied to linked lists structures that are used for storing and organizing data in sophisticated applications.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would:  Extract all nodes into an array (O(n) space). Sort the array (O(N log N) time). Reconstruct the list using the child pointer."
                                        },
                                        {
                                            "hint": "Since each child list is already sorted, we can efficiently merge them using:  Priority Queue / Min-Heap (O(N log k)) Iterative Merging (Similar to Merge k Sorted Lists in Linked Lists) (O(N log k)) Divide and Conquer (Merging Pairs of Lists Efficiently) (O(N log k))"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting all nodes (O(N log N)) would require extracting them into an array, violating in-place constraints. Min-Heap only maintains k elements at a time, making it more memory efficient (O(k) space).",
                                            "question": " Why do we use a Min-Heap instead of sorting all nodes? "
                                        },
                                        {
                                            "answer": "Each child list is already sorted, and we need to merge them efficiently.",
                                            "question": "Why is this problem similar to merging k sorted lists? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Use Divide & Conquer (Recursive Pairwise Merging): Merge two lists at a time until all lists are merged. This reduces extra space usage but keeps the same O(N log k) complexity.",
                                            "question": "Can we implement this without a heap (O(N log k)) and still be efficient? "
                                        },
                                        {
                                            "answer": "Detect cycles using Floyds Cycle Detection (O(n)), then break them before merging.",
                                            "question": "How would this approach change if we had cycles in the child lists? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_sortll",
                                "problem_name": "Sort LL",
                                "problem_slug": "sort-ll",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "MongoDB",
                                        "Optum",
                                        "Mastercard",
                                        "PwC",
                                        "Docker",
                                        "Reddit",
                                        "Epic Systems",
                                        "Etsy",
                                        "Siemens Healthineers",
                                        "Broadcom",
                                        "Flipkart",
                                        "GE Healthcare",
                                        "HashiCorp",
                                        "OYO Rooms",
                                        "Byju's",
                                        "Bungie",
                                        "American Express",
                                        "Alibaba",
                                        "eBay",
                                        "Philips Healthcare",
                                        "McKinsey & Company",
                                        "Micron Technology",
                                        "Seagate Technology",
                                        "AMD",
                                        "ARM",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: Sorting a list is one of the most common operations in software development. In real-world applications, the concept of sorting a linked list in a non-decreasing order is extensively used in contact lists apps. For instance, when you look up your contacts in any messenger app or social media platform, names are typically displayed in alphabetically sorted order, which is a non-decreasing order. Behind the scenes, this concept is implemented in their softwares architecture for managing and displaying contacts!",
                                    "hints": [
                                        {
                                            "hint": "Before merging, we check each child linked list for cycles using Floyds Cycle Detection Algorithm. Find the Start of the Cycle and Break the Cycle. "
                                        },
                                        {
                                            "hint": "Use a Min-Heap (O(N log k)) or Divide & Conquer (O(N log k)) to merge the sorted lists. Return the flattened sorted list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If a cycle exists, the merging process enters an infinite loop, preventing termination.",
                                            "question": "Why do we need to check for cycles before merging? "
                                        },
                                        {
                                            "answer": "No, because merging assumes that lists are finite. If cycles exist, merging would never terminate.",
                                            "question": "Can we remove cycles after merging instead? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The same Floyds Cycle Detection Algorithm can be applied after merging to check for cycles.",
                                            "question": "What if a cycle exists in the final merged list instead of the child lists? "
                                        },
                                        {
                                            "answer": " Yes, by maintaining visited node references (O(n) space), but Floyds Algorithm is preferred for O(1) space.",
                                            "question": " Can we optimize cycle detection further?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(hard)_cloneallwithrandomandnextpointer",
                                "problem_name": "Clone a LL with random and next pointer",
                                "problem_slug": "clone-a-ll-with-random-and-next-pointer",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Teladoc Health",
                                        "Databricks",
                                        "GE Healthcare",
                                        "Zoho",
                                        "Docker",
                                        "Reddit",
                                        "Robinhood",
                                        "Stripe",
                                        "ARM",
                                        "Morgan Stanley",
                                        "Bain & Company",
                                        "Zomato",
                                        "Unity Technologies",
                                        "Etsy",
                                        "eBay",
                                        "Dropbox",
                                        "IBM",
                                        "Cerner",
                                        "Epic Games",
                                        "Airbnb",
                                        "Nutanix",
                                        "Shopify",
                                        "PwC",
                                        "Johnson & Johnson",
                                        "Instacart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve: Creating a copy of each node (O(n) space). Using a HashMap (O(n) space) to store old node  new node mapping. Fixing the random pointers in a second pass (O(n))."
                                        },
                                        {
                                            "hint": "To achieve O(n) time and O(1) space, use:  Interleaving Technique: Clone nodes in-place without extra space. Restoring the random pointers using the interleaved structure. Separating the new list from the old one"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It allows direct access to the cloned node for updating random pointers. Eliminates the need for a hashmap (O(n) space).",
                                            "question": "Why do we interleave the cloned nodes? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! The random pointers are assigned correctly before separation.",
                                            "question": "Can this approach handle circular linked lists? "
                                        },
                                        {
                                            "answer": "Yes, instead of inserting clones, store metadata directly inside nodes.",
                                            "question": "Can we modify the list to store metadata instead of interleaving? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_faqs(dll)",
                        "subcategory_name": "FAQS (DLL)",
                        "subcategory_slug": "faqs--dll",
                        "subcategory_rank": 6,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "linked-list_linked-list_faqs(dll)_deletealloccurrencesofakeyindll",
                                "problem_name": "Delete all occurrences of a key in DLL",
                                "problem_slug": "delete-all-occurrences-of-a-key-in-dll",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Salesforce",
                                        "ARM",
                                        "Shopify",
                                        "Seagate Technology",
                                        "Uber",
                                        "JPMorgan Chase",
                                        "Reddit",
                                        "Western Digital",
                                        "Mastercard",
                                        "DoorDash",
                                        "Twilio",
                                        "Wayfair",
                                        "MongoDB",
                                        "eBay",
                                        "HCL Technologies",
                                        "Zoho",
                                        "Robinhood",
                                        "Medtronic",
                                        "Zomato",
                                        "Swiggy",
                                        "Texas Instruments",
                                        "Databricks",
                                        "McKinsey & Company",
                                        "PwC",
                                        "Cerner",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One real-world application of this problem can be seen in web browsers. Each tab in a web browser can be thought of as a node in a doubly linked list, with the previous and next tabs being the 'previous' and 'next' nodes. When a user closes a tab (equivalent to deleting a node), the browser re-links the adjacent tabs (similar to updating the 'previous' and 'next' pointers in the node deletion operation). This scenario underscores the importance of algorithms for maintaining and manipulating doubly linked lists in software applications.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve:  Creating a new list while copying only non-target nodes. Reconstructing the DLL (O(n) space)."
                                        },
                                        {
                                            "hint": "Traverse the list (O(n)), deleting nodes in-place. Handle three cases efficiently: Head node contains target  Update head. Middle nodes contain target  Update prev.next and next.prev. Tail node contains target  Update prev.next = NULL."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Move head = head.next and set head.prev = NULL.",
                                            "question": "How do we update head if the first node is deleted? "
                                        },
                                        {
                                            "answer": "DLL deletion is easier, since prev pointers eliminate the need for traversal.",
                                            "question": "How does this compare to deleting from a singly linked list? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Break the loop after deleting the first match.",
                                            "question": "How would you modify this to delete only the first occurrence of target? "
                                        },
                                        {
                                            "answer": " Replace if current.val == target with if current.val > target.",
                                            "question": "What if we needed to delete nodes greater than target instead?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "linked-list_linked-list_faqs(dll)_removeduplicatedfromsorteddll",
                                "problem_name": "Remove duplicated from sorted DLL",
                                "problem_slug": "remove-duplicated-from-sorted-dll",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Deloitte",
                                        "ARM",
                                        "KPMG",
                                        "Reddit",
                                        "Splunk",
                                        "Seagate Technology",
                                        "Stripe",
                                        "McKinsey & Company",
                                        "Roche",
                                        "Ubisoft",
                                        "Rakuten",
                                        "Salesforce",
                                        "Rockstar Games",
                                        "Texas Instruments",
                                        "Bain & Company",
                                        "Qualcomm",
                                        "HashiCorp",
                                        "Pinterest",
                                        "Intel",
                                        "Epic Games",
                                        "Micron Technology",
                                        "Morgan Stanley",
                                        "Byju's",
                                        "GE Healthcare",
                                        "MongoDB",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "A fun fact related to this problem is that the underlying concept of removing duplicate entries from a data structure is used across a wide variety of software applications. For instance, in database systems, it is critical to avoid redundancy. Techniques similar to the one in this problem are used to keep databases clean and efficient. Additionally, in applications that rely on user inputs, removing duplicates is a common task. This can include systems such as online voting platforms where each user is only allowed to vote once or email systems which prevent sending duplicate emails to the same recipient. Understanding and efficiently coding for these scenarios is a fundamental skill in software development.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve:  Using a HashMap (O(n) space) to track occurrences. Reconstructing the DLL without duplicates."
                                        },
                                        {
                                            "hint": "Since the list is already sorted, duplicates will always be adjacent.  Traverse the list (O(n)), removing all occurrences of duplicate values in one pass. Use a dummy node (O(1) space) to handle head modifications cleanly."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorted DLL (O(n))  Duplicates are adjacent, allowing linear time removal. Unsorted DLL (O(n^2))  Requires a hashmap (O(n) space) or nested traversal (O(n^2) time).",
                                            "question": "How does this compare to removing duplicates from an unsorted DLL? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of removing all duplicates, retain only the first.",
                                            "question": "What if we needed to keep one occurrence of each duplicate? "
                                        },
                                        {
                                            "answer": "The logic remains the same, but we lose prev access, requiring additional traversal.",
                                            "question": "How would this work in a singly linked list? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "linked-list_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 7,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "remove_bad_elements_in_linked_list",
                                "problem_name": "Remove bad elements in Linked List",
                                "problem_slug": "remove-bad-elements-in-linked-list",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "segregate_nodes_into_3_parts_in_ll",
                                "problem_name": "Segregate Nodes into 3 parts in LL",
                                "problem_slug": "segregate-nodes-into-3-parts-in-ll",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "NA",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "partition_linked_list",
                                "problem_name": "Special Linked List",
                                "problem_slug": "special-linked-list",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "bitmanipulation",
                "category_name": "Bit Manipulation",
                "category_slug": "bit-manipulation",
                "category_rank": 7,
                "subcategories": [
                    {
                        "subcategory_id": "bitmanipulation_theory",
                        "subcategory_name": "Theory",
                        "subcategory_slug": "theory",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_theory_introductiontobitsandtricks",
                                "problem_name": "Introduction to Bits and Tricks",
                                "problem_slug": "introduction-to-bits-and-tricks",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Epic Games",
                                        "Snowflake",
                                        "Rockstar Games",
                                        "Shopify",
                                        "PwC",
                                        "Zomato",
                                        "Bain & Company",
                                        "NVIDIA",
                                        "eBay",
                                        "Epic Systems",
                                        "Deloitte",
                                        "Dropbox",
                                        "DoorDash",
                                        "Western Digital",
                                        "Philips Healthcare",
                                        "Broadcom",
                                        "Optum",
                                        "Morgan Stanley",
                                        "Roblox",
                                        "Ubisoft",
                                        "JPMorgan Chase",
                                        "Red Hat",
                                        "Flipkart",
                                        "GE Healthcare",
                                        "Byju's",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "bitmanipulation_problems",
                        "subcategory_name": "Problems",
                        "subcategory_slug": "problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_minimumbitflipstoconvertnumber",
                                "problem_name": "Minimum Bit Flips to Convert Number",
                                "problem_slug": "minimum-bit-flips-to-convert-number",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Ernst & Young",
                                        "Flipkart",
                                        "American Express",
                                        "Byju's",
                                        "Morgan Stanley",
                                        "Walmart",
                                        "Airbnb",
                                        "Optum",
                                        "Databricks",
                                        "Swiggy",
                                        "Roche",
                                        "DoorDash",
                                        "IBM",
                                        "HCL Technologies",
                                        "Stripe",
                                        "NVIDIA",
                                        "Johnson & Johnson",
                                        "Zomato",
                                        "ARM",
                                        "McKinsey & Company",
                                        "Twilio",
                                        "Boston Consulting Group",
                                        "MongoDB",
                                        "Electronic Arts",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept underlying this problem is used extensively in error detection and correction during data transmission in networks. The technique, known as Hamming distance, measures the number of bit flips required to convert one binary string into another - in other words, it helps to understand how similar (or dissimilar) two pieces of data are. In real-world applications, such as in telecommunications or computer science, it assists in detecting and correcting errors that might occur due to noise or disruption. Principal applications can be found in information theory, and particularly in coding theory.",
                                    "hints": [
                                        {
                                            "hint": "To convert start to goal, XOR the two integers. The result of XOR will have 1s at all the bit positions where start and goal differ. "
                                        },
                                        {
                                            "hint": "\"Count the number of 1s in the XOR result. Each 1 corresponds to a bit that needs to be flipped to convert start into goal. This count gives the minimum number of bit flips required. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "XOR is used because it directly identifies the bits that differ between two numbers. A 1 in the XOR result means the corresponding bit in start and goal is different.",
                                            "question": "What is the purpose of XOR in this problem?"
                                        },
                                        {
                                            "answer": "No, only the count of differing bits matters. The problem doesnt require reordering bits, just flipping them where they differ.",
                                            "question": "Does the position of bits affect the solution?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "XOR is a powerful tool for detecting differences between two binary numbers. It has applications in checksum calculations, encryption, and toggling bits efficiently.",
                                            "question": "What is the significance of XOR in bit manipulation tasks?"
                                        },
                                        {
                                            "answer": "You can loop through the binary representation of the XOR result and note the indices of 1s. Each 1 corresponds to a flipped bit position.",
                                            "question": "How would you extend this to find the positions of the flipped bits?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_singlenumber-i",
                                "problem_name": "Single Number - I",
                                "problem_slug": "single-number---i",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Byju's",
                                        "Optum",
                                        "Roblox",
                                        "Instacart",
                                        "Wayfair",
                                        "Zoho",
                                        "Roche",
                                        "Philips Healthcare",
                                        "Teladoc Health",
                                        "HCL Technologies",
                                        "Visa",
                                        "Texas Instruments",
                                        "Activision Blizzard",
                                        "IBM",
                                        "Freshworks",
                                        "GE Healthcare",
                                        "OYO Rooms",
                                        "Intel",
                                        "Rakuten",
                                        "Cerner",
                                        "Twilio",
                                        "Zynga",
                                        "Cloudflare",
                                        "Docker",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a simplified version of the one faced by data scientists and software engineers while working with big data. It's common in data analysis to encounter datasets where most entities are duplicates and a single unique item must be found. Efficiently solving this problem is an important aspect of tasks like data deduplication, where you want to find and remove duplicate data in databases to improve data quality, or anomaly detection, where the aim is to find data points that are different from the majority to identify potential issues or insights. It is certainly a fundamental concept in the world of big data handling and manipulation.",
                                    "hints": [
                                        {
                                            "hint": "When you XOR all the numbers in the array, the duplicate numbers cancel out, leaving only the unique number."
                                        },
                                        {
                                            "hint": "Traverse the array and XOR all the elements together. At the end of the traversal, the result will be the number that appears only once because the XOR of duplicates will be zero."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, you can use a hash map to count the frequency of each number and return the one with a count of 1. However, this approach uses O(n) time but also requires O(n) space.",
                                            "question": "Can I solve this without using XOR?"
                                        },
                                        {
                                            "answer": "XOR cancels out duplicate numbers because aa=0. When all numbers in the array are XORed, only the unique number remains, as 0uniquenumber=uniquenumber.",
                                            "question": "Why does XOR work for this problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "XOR alone wouldnt work. Instead, you could use bitwise counting to count the occurrences of each bit across all numbers and find the unique number that appears k times.",
                                            "question": "How would you extend this problem if the unique number appears k times instead of 1?"
                                        },
                                        {
                                            "answer": "XOR all elements to get ab (the XOR of the two unique numbers). Then, isolate a differing bit and use it to partition the numbers into two groups, each containing one unique number.",
                                            "question": "How would you modify the solution if there were exactly two unique numbers?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_singlenumber-ii",
                                "problem_name": "Single Number - II",
                                "problem_slug": "single-number---ii",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Airbnb",
                                        "Stripe",
                                        "Electronic Arts",
                                        "Optum",
                                        "Docker",
                                        "Western Digital",
                                        "Medtronic",
                                        "Epic Games",
                                        "Zomato",
                                        "Dropbox",
                                        "Cerner",
                                        "eBay",
                                        "Deloitte",
                                        "Nutanix",
                                        "Micron Technology",
                                        "Square",
                                        "Bungie",
                                        "Byju's",
                                        "ARM",
                                        "Wayfair",
                                        "Instacart",
                                        "Databricks",
                                        "Roblox",
                                        "JPMorgan Chase",
                                        "KPMG",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem finds real-world applications in data analytics and cybersecurity. Companies often maintain log files for user activities for analysis. Most users will repeat certain activities multiple times, but some unusual activities (like a potential security breach) might only appear once. An algorithm that can efficiently identify these one-time events can alarm security systems about potential threats, triggering necessary preventive actions.",
                                    "hints": [
                                        {
                                            "hint": "For each bit position (0 to 31), traverse the array and count how many numbers have that bit set to 1. Use the modulo operation (count % 3) to identify whether the unique number has that bit set."
                                        },
                                        {
                                            "hint": "After computing the bit values for all positions, combine them to form the unique number. Ensure you handle negative numbers correctly by checking the most significant bit."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "XOR works for cases where every number appears twice except one. However, when numbers appear thrice, XOR fails because it doesnt account for the triplet elimination logic. Instead, bitwise counting ensures the triplet property is respected.",
                                            "question": "Why can't XOR alone solve this problem?"
                                        },
                                        {
                                            "answer": "For any bit position, the contribution of numbers appearing thrice sums to a multiple of 3. The unique number's contribution remains after applying modulo 3, isolating its bit value.",
                                            "question": "How does modulo 3 eliminate numbers that appear thrice?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the approach to count bit frequencies and use modulo k instead of 3 to identify the unique number's bits.",
                                            "question": "How would you extend this to handle numbers appearing k-times except one?"
                                        },
                                        {
                                            "answer": "The current approach wouldnt work. For m unique numbers, youd need to modify the solution to find all such numbers, possibly using a hash set or other data structures.",
                                            "question": "What if multiple numbers appear only once instead of one?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_singlenumber-iii",
                                "problem_name": "Single Number - III",
                                "problem_slug": "single-number---iii",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Seagate Technology",
                                        "Zoho",
                                        "Qualcomm",
                                        "Byju's",
                                        "Micron Technology",
                                        "Roche",
                                        "Walmart",
                                        "HCL Technologies",
                                        "Databricks",
                                        "Bloomberg",
                                        "Shopify",
                                        "Airbnb",
                                        "MongoDB",
                                        "JPMorgan Chase",
                                        "Twilio",
                                        "Freshworks",
                                        "Square",
                                        "OYO Rooms",
                                        "Boston Consulting Group",
                                        "Dropbox",
                                        "Morgan Stanley",
                                        "KPMG",
                                        "Visa",
                                        "Lyft",
                                        "NVIDIA",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem, where you need to find single or unique entities in a large dataset, is related to data analytics and digital forensics. In data analytics, unique entities are of interest because they can indicate anomalies or specific trends. For example, in network traffic analysis, if all IP addresses are supposed to appear twice (incoming and outgoing traffic), but two appear only once, this could signify potential security issues. In digital forensics, finding unique entities can help identify suspicious activities. Particularly, this type of problem can be solved using XOR operation in bit manipulation, a valuable technique in many areas of software, including cryptography and error detection/correction codes.",
                                    "hints": [
                                        {
                                            "hint": "The XOR result, xy, will have at least one bit set to 1. This bit represents a position where x and y differ. Isolate this bit by using diff=xor_result&xor_result, which gives the rightmost set bit."
                                        },
                                        {
                                            "hint": "Partition the array into two groups based on whether the numbers have the differentiating bit set (1) or unset (0). One group will contain x, and the other will contain y. XOR the elements in each group to isolate x and y."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "XOR cancels out all duplicate numbers, leaving only the XOR of the two unique numbers. This property allows you to isolate x and y efficiently.",
                                            "question": "Why does XOR help in finding the two unique numbers?"
                                        },
                                        {
                                            "answer": "The rightmost set bit in xy indicates a position where x and y differ. Partitioning the array based on this bit ensures that x and y fall into different groups.",
                                            "question": "How does the rightmost set bit help in partitioning the array?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "XOR alone wouldnt suffice. You could use a hash map to count frequencies or more advanced algorithms like bitwise counting to isolate k unique numbers.",
                                            "question": "How would you modify the solution if there were k unique numbers instead of 2?"
                                        },
                                        {
                                            "answer": "A brute-force approach (e.g., checking the frequency of each number) takes O(n^2) time. The XOR-based solution is much more efficient at O(n), especially for large datasets.",
                                            "question": "How does the performance compare to a brute-force approach?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_dividetwonumberswithoutmultiplicationanddivision",
                                "problem_name": "Divide two numbers without multiplication and division",
                                "problem_slug": "divide-two-numbers-without-multiplication-and-division",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Seagate Technology",
                                        "Qualcomm",
                                        "Optum",
                                        "Activision Blizzard",
                                        "Dropbox",
                                        "Medtronic",
                                        "Swiggy",
                                        "Philips Healthcare",
                                        "GE Healthcare",
                                        "Instacart",
                                        "Databricks",
                                        "Epic Games",
                                        "Shopify",
                                        "PwC",
                                        "Bloomberg",
                                        "Nutanix",
                                        "McKinsey & Company",
                                        "Etsy",
                                        "Wayfair",
                                        "HashiCorp",
                                        "Zynga",
                                        "Salesforce",
                                        "Deloitte",
                                        "Bain & Company",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of this problem can be encountered when you are working with systems that handle very large numbers, or when you are working with systems where the traditional division operation is either extremely costly in terms of performance or unavailable for certain data types. For example, Big Data processing libraries such as Apache Hadoop and Apache Spark handle terabytes of data where conventional division may lead to precision errors or performance bottlenecks. In such cases, using alternatives like bit manipulation  which is the deep-rooted concept in this problem  can help optimize performance. Similarly, cryptographic algorithms and low-level hardware programming often require such unconventional methods to carry out basic operations.",
                                    "hints": [
                                        {
                                            "hint": "Instead of repeatedly subtracting the divisor, double its value using bitwise left shifts (divisor << k). Determine the largest multiple of the divisor that can be subtracted from the dividend without making it negative. Subtract this value and repeat until the remainder is less than the divisor."
                                        },
                                        {
                                            "hint": "Determine the sign of the result by checking if the dividend and divisor have the same sign. Use sign = 1 if they do, otherwise sign = -1. Convert both numbers to their absolute values for computation."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "After computing the quotient using bitwise operations, compute the remainder as remainder=dividend(quotientdivisor).",
                                            "question": "How would you extend this for modular division?"
                                        },
                                        {
                                            "answer": "This solution works only for integers. For floating-point division, a completely different approach involving approximation or precision handling (e.g., Newton-Raphson method) would be required.",
                                            "question": "How would you handle floating-point division?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, you can use repeated subtraction. However, its inefficient for large values of the dividend and divisor. Bitwise shifting significantly improves performance.",
                                            "question": "Can this be done without bitwise operations?"
                                        },
                                        {
                                            "answer": "Division by zero is undefined. The function should raise an exception or return an error for this invalid input.",
                                            "question": "What happens if the divisor is 0?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_powerset-dup",
                                "problem_name": "Power Set Bit Manipulation",
                                "problem_slug": "power-set-bit-manipulation",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Riot Games",
                                        "Airbnb",
                                        "Oracle",
                                        "Docker",
                                        "Intel",
                                        "Qualcomm",
                                        "Medtronic",
                                        "Instacart",
                                        "eBay",
                                        "Morgan Stanley",
                                        "Epic Games",
                                        "HashiCorp",
                                        "Lyft",
                                        "PwC",
                                        "NVIDIA",
                                        "Flipkart",
                                        "Rakuten",
                                        "Roblox",
                                        "Zoho",
                                        "Teladoc Health",
                                        "Dropbox",
                                        "Splunk",
                                        "Walmart",
                                        "Salesforce",
                                        "DoorDash",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of generating all possible subsets of a set (also known as power set) is commonly used in various realms of software development, particularly in machine learning. For example, in feature selection for a machine learning model, it's crucial to explore different combinations of features (subsets) to see which ones contribute the most to the predictive model's accuracy. This is essentially generating the power set of features. Similarly, it is used in big data analytics, search engines, and data mining for various computation-related tasks involving sets of data.",
                                    "hints": [
                                        {
                                            "hint": "\"Use a recursive function that explores two choices at each step: (a) Include the current element in the subset. (b) Exclude the current element.\""
                                        },
                                        {
                                            "hint": "\"Represent each subset as a bitmask of length n, where each bit indicates whether an element is included (1) or excluded (0). Iterate through all numbers from 0 to 2^n1. For each number, use its binary representation to construct the corresponding subset.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Each element in the array has two choices: it can either be included in or excluded from a subset. For n elements, this results in 2^n combinations.",
                                            "question": "Why does the power set contain 2^n subsets?"
                                        },
                                        {
                                            "answer": "Subsets can be sorted by size or lexicographically after generation by applying a sorting function, though the problem doesn't explicitly require this.",
                                            "question": "Can subsets be generated in sorted order?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Sort the input array first. During recursion or bitmasking, skip duplicate elements by ensuring the same subset isn't constructed multiple times.",
                                            "question": "How would you extend this problem if duplicates were allowed in the input array?"
                                        },
                                        {
                                            "answer": "Modify the recursive function or bitmask approach to track the size of the current subset. Only include subsets of size k in the result.",
                                            "question": "How would you generate subsets of a specific size k?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "bitmanipulation_bitmanipulation_problems_xorofnumbersinagivenrange",
                                "problem_name": "XOR of numbers in a given range",
                                "problem_slug": "xor-of-numbers-in-a-given-range",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "GE Healthcare",
                                        "McKinsey & Company",
                                        "IBM",
                                        "Oracle",
                                        "Flipkart",
                                        "HashiCorp",
                                        "DoorDash",
                                        "Philips Healthcare",
                                        "Square",
                                        "KPMG",
                                        "Intel",
                                        "Bain & Company",
                                        "Electronic Arts",
                                        "Broadcom",
                                        "Optum",
                                        "Twilio",
                                        "Byju's",
                                        "MongoDB",
                                        "Cloudflare",
                                        "Nutanix",
                                        "Salesforce",
                                        "Instacart",
                                        "Lyft",
                                        "Stripe",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem underlines the XOR bitwise operation widely used in cryptography and communication protocols. A real-world application of XOR is the network checksum algorithms in TCP/IP to check the integrity of data. XOR is also used in error detection and correction codes used in data storage and transmission. This is particularly useful as XOR operation produces a unique output for a unique input, enabling quick detection and correction of errors.",
                                    "hints": [
                                        {
                                            "hint": "The XOR of numbers from L to R can be computed using the cumulative XOR from 0 to R and 0 to L1. This is because XOR(LtoR)=XOR(0toR)XOR(0toL1)."
                                        },
                                        {
                                            "hint": "Compute XOR(LtoR) as f(R)f(L-1), where f(N) is the XOR of numbers from 0 to N based on the modulo 4 pattern."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The XOR pattern for numbers from 0 to N repeats every 4 numbers because of the binary properties of XOR and the carry propagation in binary addition.",
                                            "question": "How does the modulo 4 pattern arise?"
                                        },
                                        {
                                            "answer": "XOR has the property that aa=0 and a0=a. This allows numbers outside the range L to R to cancel out when computing XOR(0toR)XOR(0toL1).",
                                            "question": "Why does XOR work for ranges?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For multiple ranges, precompute the cumulative XOR for all numbers up to the maximum R across all ranges. Then, use the same logic (f(R)f(L-1)) for each range in O(1) time.",
                                            "question": "How would you extend this to compute XOR for multiple ranges?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "bitmanipulation_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 3,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "count_set_cost",
                                "problem_name": "Count Set Cost",
                                "problem_slug": "count-set-cost",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "twin_numbers",
                                "problem_name": "Twin Numbers",
                                "problem_slug": "twin-numbers",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "odd_subsets",
                                "problem_name": "Odd Subsets",
                                "problem_slug": "odd-subsets",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "greedyalgorithms",
                "category_name": "Greedy Algorithms",
                "category_slug": "greedy-algorithms",
                "category_rank": 8,
                "subcategories": [
                    {
                        "subcategory_id": "greedyalgorithms_easy/medium",
                        "subcategory_name": "Easy",
                        "subcategory_slug": "easy",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_easy/medium_assigncookies",
                                "problem_name": "Assign Cookies",
                                "problem_slug": "assign-cookies",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "McKinsey & Company",
                                        "Rakuten",
                                        "Roche",
                                        "Seagate Technology",
                                        "Zoho",
                                        "Flipkart",
                                        "Robinhood",
                                        "Deloitte",
                                        "JPMorgan Chase",
                                        "Oracle",
                                        "Siemens Healthineers",
                                        "Riot Games",
                                        "PwC",
                                        "AMD",
                                        "Wayfair",
                                        "Broadcom",
                                        "Unity Technologies",
                                        "Zynga",
                                        "Visa",
                                        "ARM",
                                        "Freshworks",
                                        "Cloudflare",
                                        "Texas Instruments",
                                        "Shopify",
                                        "Ernst & Young",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This concept is commonly applied in resource allocation in software development where tasks (students) require certain resources (cookies) to function properly. For instance, in Operating Systems, process scheduling algorithms use similar logic to allocate CPU cycles (cookies) to different processes (students) based on their requirements. Task scheduling in Big Data frameworks like Hadoop or Spark also use similar concepts to distribute computational resources such as memory and CPU. Also, in cloud computing, virtual machines or containers (like in Docker) can be considered as students, and the resources (CPU, memory, etc.) are the cookies. The scheduler needs to distribute these resources efficiently among the containers or VMs to ensure optimal usage of resources.",
                                    "hints": [
                                        {
                                            "hint": "Use one pointer to traverse the Student array and another to traverse the Cookie array. If the current cookie satisfies the current student (i.e., Cookie[j] >= Student[i]), assign the cookie to the student and move both pointers forward."
                                        },
                                        {
                                            "hint": "The goal is to assign the smallest cookie possible to each student that can satisfy their requirement. This greedy approach minimizes wasted resources and ensures that more students can be assigned cookies."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures that the smallest available cookie is assigned to the student with the smallest requirement. This maximizes the remaining larger cookies for students with higher requirements.",
                                            "question": "Why is sorting necessary?"
                                        },
                                        {
                                            "answer": "The extra cookies will remain unused since the goal is to maximize the number of students who receive cookies, not the usage of cookies.",
                                            "question": "What if there are more cookies than students?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This problem focuses on maximizing satisfied students, not minimizing unused cookies. To minimize unused cookies, additional logic may be required to assign larger cookies efficiently, but this might reduce the number of satisfied students.",
                                            "question": "What if you need to minimize the number of unused cookies?"
                                        },
                                        {
                                            "answer": "Modify the logic to track shared cookies. For example, divide the cookie size among eligible students and adjust the student requirements accordingly.",
                                            "question": "What if some students can share a cookie?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_easy/medium_lemonadechange",
                                "problem_name": "Lemonade Change",
                                "problem_slug": "lemonade-change",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Freshworks",
                                        "HashiCorp",
                                        "Red Hat",
                                        "Unity Technologies",
                                        "Airbnb",
                                        "Optum",
                                        "Medtronic",
                                        "Databricks",
                                        "AMD",
                                        "Rakuten",
                                        "Twilio",
                                        "Dropbox",
                                        "HCL Technologies",
                                        "PayPal",
                                        "PwC",
                                        "McKinsey & Company",
                                        "OYO Rooms",
                                        "Roblox",
                                        "Activision Blizzard",
                                        "Alibaba",
                                        "Intel",
                                        "Stripe",
                                        "American Express",
                                        "Wayfair",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem can be viewed as a real-time inventory management problem, which is a core part of many business softwares and frameworks. In use cases like retail or restaurant management software, constantly tracking the availability of change or specific denominations of currency is critical to smooth transactions. Understanding how to effectively solve this problem can make automatic payment and billing systems more accurate, improving overall customer experience.",
                                    "hints": [
                                        {
                                            "hint": "Use variables to keep track of the count of $5 and $10 bills. Since $20 bills cannot be used as change directly, their count is irrelevant for making change."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If there are no $5 bills and a customer pays with a $10 or $20 bill, return false immediately since change cannot be provided.",
                                            "question": "What if there are no $5 bills in the array?"
                                        },
                                        {
                                            "answer": "The algorithm handles each transaction independently. If enough $10 and $5 bills are available for each $20 transaction, it proceeds. Otherwise, it terminates when change can't be given.",
                                            "question": "What if there are multiple $20 bills in a row?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend the tracking system to handle these denominations and implement rules to prioritize their usage for making change.",
                                            "question": "What happens if customers are allowed to pay with other denominations (e.g., $2, $50)?"
                                        },
                                        {
                                            "answer": "Add the initial counts of $5 and $10 bills to the respective variables at the beginning of the simulation.",
                                            "question": "How would you modify the solution if the booth starts with some initial change?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_easy/medium_jumpgame-i",
                                "problem_name": "Jump Game - I",
                                "problem_slug": "jump-game---i",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Mastercard",
                                        "Electronic Arts",
                                        "Byju's",
                                        "DoorDash",
                                        "Cloudflare",
                                        "HashiCorp",
                                        "Goldman Sachs",
                                        "Zynga",
                                        "Etsy",
                                        "IBM",
                                        "Optum",
                                        "PwC",
                                        "Epic Systems",
                                        "Splunk",
                                        "MongoDB",
                                        "Pinterest",
                                        "Boston Consulting Group",
                                        "Broadcom",
                                        "Zomato",
                                        "Riot Games",
                                        "HCL Technologies",
                                        "Seagate Technology",
                                        "Salesforce",
                                        "Stripe",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem's underlying concept is applied in routing and networking protocols. For example, the Internet Protocol (IP) uses routing algorithms based on the shortest path, which is similar conceptually to the array jump problem. These protocols need to calculate the shortest or most efficient route for data packets to reach their destination, making sure data can indeed jump from one node to another until it reaches its final destination, or return 'false' if it cannot. The problem's notion is also central in video game development. For instance, in pathfinding logic for non-playable characters, algorithms evaluate if a character can move from one point to another by 'jumping' through specified navigation points, much like jumping through indices of an array.",
                                    "hints": [
                                        {
                                            "hint": "Maintain a variable farthest to keep track of the farthest index you can reach as you iterate through the array. For each position i, calculate the maximum reach using farthest=max(farthest,i+nums[i]). If farthest ever becomes greater than or equal to the last index, return true."
                                        },
                                        {
                                            "hint": "If at any index i, the farthest reachable position is less than i, it means you cannot proceed further, and reaching the last index is impossible. Exit early and return false."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Large jump lengths dont impact the algorithm because it only cares about the maximum reachable index at each step, not the specific jump sizes.",
                                            "question": "What happens if the array contains very large jump lengths?"
                                        },
                                        {
                                            "answer": "The problem assumes the array contains only non-negative integers. Negative or non-integer values would require additional validation and adjustments to the logic.",
                                            "question": "What if the array contains negative or non-integer values?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend the greedy approach by tracking the end of the current jump range and counting the number of jumps. Increment the jump count whenever the current index exceeds the range of the current jump.",
                                            "question": "What if you need to find the minimum number of jumps to reach the last index?"
                                        },
                                        {
                                            "answer": "Modify the greedy solution to store the path by keeping track of the index from which each jump was made. Backtrack from the last index to reconstruct the path.",
                                            "question": "What if you want to return the indices of the path taken?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "greedyalgorithms_schedulingandintervalproblems",
                        "subcategory_name": "Scheduling and Interval Problems",
                        "subcategory_slug": "scheduling-and-interval-problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_shortestjobfirst",
                                "problem_name": "Shortest Job First",
                                "problem_slug": "shortest-job-first",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "MongoDB",
                                        "Riot Games",
                                        "Ernst & Young",
                                        "Teladoc Health",
                                        "Unity Technologies",
                                        "NVIDIA",
                                        "Twilio",
                                        "Instacart",
                                        "Electronic Arts",
                                        "HashiCorp",
                                        "Walmart",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Visa",
                                        "Roche",
                                        "Zomato",
                                        "DoorDash",
                                        "PwC",
                                        "Swiggy",
                                        "Flipkart",
                                        "Intel",
                                        "PayPal",
                                        "Salesforce",
                                        "AMD",
                                        "Ubisoft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The Shortest Job First (SJF) or Shortest Job Next (SJN) scheduling policy used in this problem is often utilized by operating systems to manage the execution of processes in real-world applications. This strategy improves process throughput and utilization of CPU, making it suitable for time-sharing systems where efficiency is critical. So next time you're working on your PC or using a mobile app, you can imagine a miniature 'queue' of processes, waiting to be handled based on their required computing time!",
                                    "hints": [
                                        {
                                            "hint": "First, sort the burst times in ascending order. For each process, the waiting time is the sum of the burst times of all previous processes."
                                        },
                                        {
                                            "hint": "\"Sum all the waiting times and divide by the total number of processes (n). Use the floor function to return the closest whole number less than or equal to the result. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures shorter processes finish earlier, reducing the waiting time for longer processes that follow. This is the essence of the SJF policy.",
                                            "question": "Why does sorting the burst times minimize the waiting time?"
                                        },
                                        {
                                            "answer": "This question focuses on non-preemptive SJF, where all processes are assumed to arrive at time 0. For preemptive SJF (also known as Shortest Remaining Time First), arrival times are considered.",
                                            "question": "Does SJF consider arrival times of processes?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Sort processes by arrival time first. For each time unit, select the process with the shortest burst time among those that have arrived but havent been executed.",
                                            "question": "How would you extend this to include arrival times?"
                                        },
                                        {
                                            "answer": "SJF may lead to starvation for processes with long burst times if shorter jobs keep arriving. It also assumes knowledge of burst times in advance, which may not always be possible.",
                                            "question": "What are the limitations of SJF?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_jobsequencingproblem",
                                "problem_name": "Job sequencing Problem",
                                "problem_slug": "job-sequencing-problem",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Micron Technology",
                                        "Roblox",
                                        "Bloomberg",
                                        "Instacart",
                                        "Morgan Stanley",
                                        "Square",
                                        "Alibaba",
                                        "Airbnb",
                                        "AMD",
                                        "Roche",
                                        "PayPal",
                                        "Siemens Healthineers",
                                        "Western Digital",
                                        "Robinhood",
                                        "Seagate Technology",
                                        "McKinsey & Company",
                                        "Johnson & Johnson",
                                        "eBay",
                                        "GE Healthcare",
                                        "Deloitte",
                                        "Goldman Sachs",
                                        "Zomato",
                                        "Freshworks",
                                        "Riot Games",
                                        "Unity Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is commonly encountered in project management and scheduling software applications. For instance, software that manages tasks and deadlines in industries such as manufacturing, supply chain, or software development often needs to optimise schedules based on profit and deadlines. This involves choosing an order to execute jobs in a way that maximises profit while respecting deadlines  a real-world application of the job scheduling problem.",
                                    "hints": [
                                        {
                                            "hint": "Maintain a timeline (e.g., a list of size equal to the maximum deadline) to keep track of which time slots are occupied. For each job, attempt to schedule it at the latest available time slot before its deadline. If no such slot exists, skip the job."
                                        },
                                        {
                                            "hint": "Keep a count of the number of successfully scheduled jobs. Add the profit of each scheduled job to the total profit. At the end, return the number of jobs and the maximum profit."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting by profit ensures that jobs with the highest reward are scheduled first, maximizing the total profit. A greedy approach works here because each job takes exactly 1 unit of time.",
                                            "question": "Why sort jobs by profit?"
                                        },
                                        {
                                            "answer": "Jobs with deadlines exceeding the maximum number of jobs can still be scheduled, as long as a free slot exists before their deadline. Deadlines beyond the timeline size dont affect scheduling logic.",
                                            "question": "What if a job's deadline is greater than the number of jobs?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Overlapping deadlines are automatically handled by the greedy approach. Jobs are scheduled into the latest available slot before their respective deadlines.",
                                            "question": "How would you handle overlapping deadlines?"
                                        },
                                        {
                                            "answer": "For jobs with varying durations, modify the timeline to account for the job's duration. Ensure that consecutive slots are available before scheduling a job.",
                                            "question": "How would you handle jobs that take more than 1 unit of time?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_nmeetingsinoneroom",
                                "problem_name": "N meetings in one room",
                                "problem_slug": "n-meetings-in-one-room",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "IBM",
                                        "Seagate Technology",
                                        "Airbnb",
                                        "Philips Healthcare",
                                        "HCL Technologies",
                                        "ARM",
                                        "Flipkart",
                                        "Epic Systems",
                                        "Bain & Company",
                                        "Mastercard",
                                        "Swiggy",
                                        "Optum",
                                        "Roblox",
                                        "Unity Technologies",
                                        "JPMorgan Chase",
                                        "Rakuten",
                                        "KPMG",
                                        "Siemens Healthineers",
                                        "Epic Games",
                                        "Oracle",
                                        "Lyft",
                                        "Zomato",
                                        "Bungie",
                                        "Zynga",
                                        "McKinsey & Company",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem, in its essence, is an instance of interval scheduling, which is a classic topic in optimization and used widely across real-world applications. Calendar apps like Google Calendar and Outlook use this principle to optimize meeting schedules. The algorithms behind ride-sharing apps like Uber and Lyft or food delivery services like Grubhub and DoorDash, which need to accommodate multiple delivery or pick-up requests within specific time windows, also leverage this concept. In the realm of cloud computing, similar algorithms are used for optimizing usage of computing resources based on their start and end usage times.",
                                    "hints": [
                                        {
                                            "hint": "Sort the meetings by their end time in ascending order. If two meetings have the same end time, sort by their start time."
                                        },
                                        {
                                            "hint": "Start with the earliest possible meeting. For each subsequent meeting, check if its start time is greater than or equal to the end time of the previously selected meeting."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting by end time ensures that meetings that finish earlier are prioritized. This allows more meetings to be accommodated since the room is freed up sooner.",
                                            "question": "Why sort by end time?"
                                        },
                                        {
                                            "answer": "If all meetings overlap, only one meeting (the one with the earliest end time) can be scheduled.",
                                            "question": "What if all meetings overlap?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If multiple rooms are available, the problem becomes a meeting room allocation problem, which can be solved using a min-heap to track the end times of ongoing meetings.",
                                            "question": "What if there are multiple meeting rooms?"
                                        },
                                        {
                                            "answer": "This is a specific case of interval scheduling maximization, where the goal is to select the maximum number of non-overlapping intervals from a set of intervals.\n",
                                            "question": "What is the difference between this and the interval scheduling maximization problem?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_non-overlappingintervals",
                                "problem_name": "Non-overlapping Intervals",
                                "problem_slug": "non-overlapping-intervals",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Rockstar Games",
                                        "NVIDIA",
                                        "Seagate Technology",
                                        "Docker",
                                        "Goldman Sachs",
                                        "Freshworks",
                                        "Salesforce",
                                        "American Express",
                                        "Red Hat",
                                        "Bungie",
                                        "Morgan Stanley",
                                        "Nutanix",
                                        "Swiggy",
                                        "Texas Instruments",
                                        "Teladoc Health",
                                        "Walmart",
                                        "Zynga",
                                        "Ubisoft",
                                        "Mastercard",
                                        "Bloomberg",
                                        "Stripe",
                                        "Reddit",
                                        "Zomato",
                                        "Deloitte",
                                        "McKinsey & Company",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem scenario and its underlying concept is widely used in the area of resource scheduling in the software industry. For instance, in cloud computing, there can be multiple requests for a resource within overlapping intervals. Solving a problem like this could determine the minimum number of requests to be canceled, moved or rescheduled to ensure that resource allocation does not overlap, thereby optimizing resource utilization. Another popular use case is in the organization of tasks or events in calendar apps where the goal is minimizing event overlap to free up time slots.",
                                    "hints": [
                                        {
                                            "hint": "Sort the intervals based on their end values in ascending order. If two intervals have the same end, sort by their start. After sorting, initialize a variable to keep track of the end time of the last selected interval."
                                        },
                                        {
                                            "hint": "Traverse the intervals. If the start time of the current interval is greater than or equal to the end time of the last selected interval, keep the current interval and update the end time. If the intervals overlap (i.e., the start time is less than the current end time), increment the count of intervals to be removed."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting by end time ensures that you select the interval that leaves the most space for subsequent intervals, maximizing the number of non-overlapping intervals that can be included.",
                                            "question": "Why sort by end time instead of start time?"
                                        },
                                        {
                                            "answer": "If two intervals share the same end time, their order doesnt matter because overlapping will still be avoided by comparing the start times.",
                                            "question": "What if two intervals have the same end time?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For dynamic scenarios, such as adding or removing intervals, consider using a balanced binary search tree or interval tree to efficiently manage overlapping intervals.",
                                            "question": "How would you handle dynamic updates to the intervals?"
                                        },
                                        {
                                            "answer": "Modify the algorithm to calculate and minimize the sum of overlapping durations rather than the count of intervals removed.",
                                            "question": "What if you wanted to minimize the total \"overlap time\" instead of removing intervals?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_insertinterval",
                                "problem_name": "Insert Interval",
                                "problem_slug": "insert-interval",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Alibaba",
                                        "Roblox",
                                        "American Express",
                                        "Riot Games",
                                        "Airbnb",
                                        "McKinsey & Company",
                                        "Bungie",
                                        "AMD",
                                        "Philips Healthcare",
                                        "Activision Blizzard",
                                        "Snowflake",
                                        "Mastercard",
                                        "Target",
                                        "eBay",
                                        "Lyft",
                                        "Oracle",
                                        "Intel",
                                        "Bloomberg",
                                        "Cloudflare",
                                        "Bain & Company",
                                        "Swiggy",
                                        "NVIDIA",
                                        "Deloitte",
                                        "Splunk",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of programming problem is used in various time scheduling applications, as seen in Google Calendar or Outlook, to prevent overlapping events and maintain them in sorted order. For instance, when a user wants to insert a new calendar event, the system will check if the time overlaps with other events, then if doesn't, the system inserts the event while preserving chronological order. So, such algorithms are essential to ensure effective time management in calendar-based applications.",
                                    "hints": [
                                        {
                                            "hint": "Since the input intervals are already sorted and non-overlapping, iterate through the intervals one by one. Compare the newInterval with each interval."
                                        },
                                        {
                                            "hint": "Update the start of newInterval to the minimum of its current start and the start of the overlapping interval. Update the end of newInterval to the maximum of its current end and the end of the overlapping interval. Skip the intervals that are merged into newInterval."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If newInterval is completely disjoint from all intervals, insert it at the correct position based on its start value while maintaining sorted order.",
                                            "question": "What if newInterval does not overlap with any interval?"
                                        },
                                        {
                                            "answer": "If newInterval ends before the first interval starts or starts after the last interval ends, add it directly to the beginning or the end of the result.",
                                            "question": "What if newInterval is entirely outside the bounds of Intervals?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of merging overlapping intervals, collect all intervals that overlap with newInterval into a separate result list and return them.",
                                            "question": "How would you modify the solution to return overlapping intervals instead of inserting the new interval?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_schedulingandintervalproblems_minimumnumberofplatformsrequiredforarailway",
                                "problem_name": "Minimum number of platforms required for a railway",
                                "problem_slug": "minimum-number-of-platforms-required-for-a-railway",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Medtronic",
                                        "GE Healthcare",
                                        "HCL Technologies",
                                        "Zynga",
                                        "Reddit",
                                        "Electronic Arts",
                                        "Rakuten",
                                        "Byju's",
                                        "Airbnb",
                                        "Broadcom",
                                        "Ernst & Young",
                                        "Square",
                                        "Qualcomm",
                                        "Flipkart",
                                        "Rockstar Games",
                                        "Twilio",
                                        "Seagate Technology",
                                        "Micron Technology",
                                        "Stripe",
                                        "Alibaba",
                                        "Johnson & Johnson",
                                        "Dropbox",
                                        "American Express",
                                        "Salesforce",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem uses the algorithm concept of scheduling and resource allocation, which is broadly used in operating system design and database management system to handle multiple processes concurrently. A practical application can be seen in air traffic control systems, where allocating runway and airspace to numerous incoming and outgoing flights in an efficient manner becomes crucial. Similarly, it is used in reservation systems of hotels or even in meeting room booking systems in multi-national companies to maximize utilization and prevent overlapping bookings.",
                                    "hints": [
                                        {
                                            "hint": "Create two separate arrays: one for arrival times and one for departure times. Sort both arrays independently."
                                        },
                                        {
                                            "hint": "Use two pointers. One pointer for arrival times and another for departure times. Traverse the arrays. If a train arrives before the previous train departs, increment the platform count."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If multiple trains arrive at the same time, the platform count increases for each train. Similarly, if multiple trains depart at the same time, the platform count decreases for each departure.",
                                            "question": "What happens if multiple trains arrive or depart at the same time?"
                                        },
                                        {
                                            "answer": "Sorting ensures that trains are processed in chronological order, allowing you to simulate the actual sequence of events and efficiently manage platforms.",
                                            "question": "Why sort both arrival and departure arrays?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend the logic by incorporating the date into the arrival and departure times. Treat the combined date and time as a single timestamp for sorting and processing.",
                                            "question": "What if trains arrive and depart across multiple days?"
                                        },
                                        {
                                            "answer": "Standardize the time format before processing. For example, convert all times to 24-hour format or total minutes since midnight.",
                                            "question": "How would you handle cases where arrival and departure times are given in different formats?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "greedyalgorithms_hard",
                        "subcategory_name": "Hard",
                        "subcategory_slug": "hard",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_hard_validparanthesischecker",
                                "problem_name": "Valid Paranthesis Checker",
                                "problem_slug": "valid-paranthesis-checker",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "Electronic Arts",
                                        "Boston Consulting Group",
                                        "Zomato",
                                        "Oracle",
                                        "PayPal",
                                        "Johnson & Johnson",
                                        "Philips Healthcare",
                                        "MongoDB",
                                        "HCL Technologies",
                                        "OYO Rooms",
                                        "HashiCorp",
                                        "Optum",
                                        "GE Healthcare",
                                        "Dropbox",
                                        "Bloomberg",
                                        "Micron Technology",
                                        "Target",
                                        "KPMG",
                                        "Epic Games",
                                        "Robinhood",
                                        "Activision Blizzard",
                                        "NVIDIA",
                                        "Etsy",
                                        "Morgan Stanley",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Use two counters, low and high. low represents the minimum number of unmatched left parentheses. high represents the maximum possible unmatched left parentheses."
                                        },
                                        {
                                            "hint": "Ensure that low never drops below 0 during traversal, as that would mean unmatched ) exists. At the end of traversal, check if low == 0, meaning all parentheses can be matched."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "low assumes the * acts as a right parenthesis ) or empty string \"\", minimizing unmatched left parentheses.\nhigh assumes the * acts as a left parenthesis (, maximizing unmatched left parentheses. Together, they ensure all possible interpretations of * are covered.",
                                            "question": "How does low and high handle the flexibility of *?"
                                        },
                                        {
                                            "answer": "If the string contains only *, it is always valid since all * can be treated as empty strings.",
                                            "question": "What if the string contains no ( or )?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the logic to handle new constraints. For example, if * could represent multiple parentheses, you might need a more complex simulation or stack-based approach.",
                                            "question": "What if * had additional roles or constraints?"
                                        },
                                        {
                                            "answer": "A stack-based approach keeps track of potential matches directly but is less space-efficient (O(n)). The two-counter method is more efficient (O(1) space) and simpler for this problem.",
                                            "question": "How does this approach compare to using a stack?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "greedyalgorithms_greedyalgorithms_hard_candy",
                                "problem_name": "Candy",
                                "problem_slug": "candy",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Docker",
                                        "McKinsey & Company",
                                        "DoorDash",
                                        "Target",
                                        "Zoho",
                                        "Twilio",
                                        "Stripe",
                                        "Morgan Stanley",
                                        "Bloomberg",
                                        "GE Healthcare",
                                        "Ubisoft",
                                        "Uber",
                                        "Walmart",
                                        "Philips Healthcare",
                                        "ARM",
                                        "Salesforce",
                                        "Zomato",
                                        "Chewy",
                                        "Bain & Company",
                                        "Pinterest",
                                        "Medtronic",
                                        "Etsy",
                                        "NVIDIA",
                                        "Bungie",
                                        "Cloudflare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem models situations involving resource allocation, fairness, and data comparison in real-world applications, such as employee incentives, traffic shaping in network engineering, and grading systems in education platforms. For example, in a rating-based rewards system in HR software, a similar algorithm could be used to decide how much bonus to give to each employee based on their performance ratings, ensuring everyone gets a bonus and those with higher ratings get more.",
                                    "hints": [
                                        {
                                            "hint": "Start by giving each child one candy to satisfy the first condition (at least one candy per child). Adjust the candy counts during the two passes to ensure the second condition is met."
                                        },
                                        {
                                            "hint": "After both passes, the candy count for each child will reflect the minimum candies needed to satisfy the conditions. Sum these values to get the total number of candies required."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If two kids have the same rating, they dont need more candies than each other. Both can have the same number of candies, and no extra adjustments are needed.",
                                            "question": "What happens if multiple kids have the same rating?"
                                        },
                                        {
                                            "answer": "If all kids have the same rating, give each child exactly one candy. The total number of candies needed will be equal to the number of children.",
                                            "question": "What if all kids have the same rating?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The ratings do not directly affect the time or space complexity, as the algorithm only compares relative values and doesnt perform any operations based on the magnitude of the ratings.",
                                            "question": "What if the ratings are very large?"
                                        },
                                        {
                                            "answer": "Combine the current solution with a dynamic programming or optimization approach to satisfy additional constraints like budgets or candy limits.",
                                            "question": "How would you handle cases where multiple constraints are applied (e.g., candies must also be within a budget)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "greedyalgorithms_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 4,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "maximum_xor_length",
                                "problem_name": "Maximum XOR Length",
                                "problem_slug": "maximum-xor-length",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "un_palindromic_strings",
                                "problem_name": "Un Palindromic Strings",
                                "problem_slug": "un-palindromic-strings",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "maximum_sum",
                                "problem_name": "Maximum sum",
                                "problem_slug": "maximum-sum",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "slidingwindow/2pointer",
                "category_name": "Sliding Window / 2 Pointer",
                "category_slug": "sliding-window-and-2-pointer",
                "category_rank": 9,
                "subcategories": [
                    {
                        "subcategory_id": "slidingwindow/2pointer_patternandtemplate",
                        "subcategory_name": "Pattern and Template",
                        "subcategory_slug": "pattern-and-template",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_patternandtemplate_theory",
                                "problem_name": "Theory",
                                "problem_slug": "theory",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "slidingwindow/2pointer_constantwindow",
                        "subcategory_name": "Constant Window",
                        "subcategory_slug": "constant-window",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_constantwindow_maximumpointsyoucanobtainfromcards",
                                "problem_name": "Maximum Points You Can Obtain from Cards",
                                "problem_slug": "maximum-points-you-can-obtain-from-cards-",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Salesforce",
                                        "Byju's",
                                        "Dropbox",
                                        "JPMorgan Chase",
                                        "Rakuten",
                                        "HashiCorp",
                                        "NVIDIA",
                                        "Target",
                                        "Walmart",
                                        "OYO Rooms",
                                        "Databricks",
                                        "Alibaba",
                                        "Swiggy",
                                        "MongoDB",
                                        "Cloudflare",
                                        "Deloitte",
                                        "Visa",
                                        "Docker",
                                        "Boston Consulting Group",
                                        "Lyft",
                                        "Morgan Stanley",
                                        "Zoho",
                                        "Micron Technology",
                                        "Mastercard",
                                        "Instacart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem concept is utilized in many areas such as Game Development. In games like Hearthstone or Clash Royale, optimal strategies can be modeled using similar logic, where players have to choose cards with the most scores from a given set given constraints. The algorithm used to solve this problem can be used to build the AI for such competitive card games. So, next time you play a card game, remember that you may be battling against a software program that uses this concept to decide its moves!",
                                    "hints": [
                                        {
                                            "hint": "\"Compute the prefix sum for the first k cards from the beginning of the array. Compute the suffix sum for the last k cards from the end of the array. Combine these sums for all possible combinations (e.g., take i cards from the beginning and ki cards from the end).\""
                                        },
                                        {
                                            "hint": "Start with k cards from the beginning as the initial score. Gradually replace one card from the beginning with one card from the end, updating the score dynamically to find the maximum."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The sliding window ensures that each combination of i cards from the front and ki cards from the back is considered without recomputing sums from scratch, reducing the time complexity.",
                                            "question": "Why is the sliding window approach optimal?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For non-consecutive cards, the problem becomes a combinatorial selection problem, requiring dynamic programming or backtracking to explore all possible subsets of size k.",
                                            "question": "How would you modify this to allow choosing non-consecutive cards?"
                                        },
                                        {
                                            "answer": "Modify the algorithm to account for alternating turns by simulating the selection process for both players, optimizing for one while considering the opponents moves.",
                                            "question": "How would you handle multiple players selecting cards alternately?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "slidingwindow/2pointer_longestandsmallestwindowproblems",
                        "subcategory_name": "Longest and Smallest Window Problems",
                        "subcategory_slug": "longest-and-smallest-window-problems",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_longestsubstringwithoutrepeatingcharacters",
                                "problem_name": "Longest Substring Without Repeating Characters",
                                "problem_slug": "longest-substring-without-repeating-characters",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Dropbox",
                                        "Shopify",
                                        "Snowflake",
                                        "Johnson & Johnson",
                                        "Wayfair",
                                        "Micron Technology",
                                        "Ubisoft",
                                        "Bungie",
                                        "Rakuten",
                                        "Swiggy",
                                        "NVIDIA",
                                        "Roblox",
                                        "Unity Technologies",
                                        "Stripe",
                                        "Chewy",
                                        "Target",
                                        "Rockstar Games",
                                        "Bloomberg",
                                        "McKinsey & Company",
                                        "Zoho",
                                        "Twilio",
                                        "HCL Technologies",
                                        "PayPal",
                                        "ARM",
                                        "Qualcomm",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem statement is a fundamental concept of string parsing used in many applications, such as web browsers and text editors. Specifically, it is used in web security. For example, in JWT (JSON Web Tokens) used for securely transmitting information between parties as a JSON object, there is a need to detect duplication or repetition in the token string. This technique is also used for creating unique user session IDs and securing password hashes by detecting repeating character sequences. On a lighter side, in gaming, this algorithm can help design games with code-breaking themes, where players need to identify non-repeating sequences.",
                                    "hints": [
                                        {
                                            "hint": "Use a hash map (or set) to store the characters currently in the window. For each character, If it's not in the hash map, add it to the window and update the maximum length. If it's already in the hash map, move the left pointer forward until the duplicate is removed."
                                        },
                                        {
                                            "hint": "After processing each character, compute the length of the current window as rightleft+1. Keep track of the maximum length encountered during the traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Spaces and special characters are treated like any other character. They can be part of the substring as long as they are not repeated.",
                                            "question": "What happens if the string contains spaces or special characters?"
                                        },
                                        {
                                            "answer": "The sliding window ensures that the algorithm processes each character exactly once, avoiding redundant computations and maintaining a time complexity of O(n).",
                                            "question": "Why use the sliding window approach?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Convert the string to lowercase (or uppercase) before processing to ensure consistency when checking for duplicates.",
                                            "question": "How would you handle a case-insensitive string?"
                                        },
                                        {
                                            "answer": "Track the starting and ending indices of the longest substring during the traversal. Use these indices to extract the substring after completing the algorithm.\n",
                                            "question": "What if you needed to return the substring itself instead of its length?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_maxconsecutiveonesiii",
                                "problem_name": " Max Consecutive Ones III",
                                "problem_slug": "max-consecutive-ones-iii",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "American Express",
                                        "HCL Technologies",
                                        "JPMorgan Chase",
                                        "Target",
                                        "Zoho",
                                        "Etsy",
                                        "Walmart",
                                        "eBay",
                                        "Zomato",
                                        "Red Hat",
                                        "Unity Technologies",
                                        "NVIDIA",
                                        "Splunk",
                                        "Morgan Stanley",
                                        "Lyft",
                                        "ARM",
                                        "Byju's",
                                        "Reddit",
                                        "Goldman Sachs",
                                        "Epic Games",
                                        "Instacart",
                                        "KPMG",
                                        "IBM",
                                        "Chewy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This programming problem is a pragmatic application of the \"sliding window\" concept used in fields like video streaming and networking protocols. By controlling the number of bits that can be flipped in a buffer (representing data or packets), developers can optimize data loss or error handling. Algorithms like these help smooth your Netflix binges, ensuring your video doesn't stutter even if some data packets arrive out of order or get lost!",
                                    "hints": [
                                        {
                                            "hint": "\"Use a sliding window to maintain a range of elements where at most k 0s are flipped into 1s. Keep a counter for the number of 0s in the current window. When the counter exceeds k, move the left pointer forward while decrementing the count of 0s if the leftmost element is 0.\""
                                        },
                                        {
                                            "hint": "\"At each step, calculate the length of the current valid window as rightleft+1. Update the maximum length whenever a larger valid window is found. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the array contains no 0s, the entire array is already the longest subarray of consecutive 1s. The output will be n, where n is the length of the array.",
                                            "question": "What happens if nums contains no 0s?"
                                        },
                                        {
                                            "answer": "Yes, in this case, all 0s can be flipped, and the result will be the length of the entire array, as all elements can become 1.",
                                            "question": "Can k be greater than the number of 0s in the array?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track the start and end indices of the current window whenever a new maximum length is found. Return these indices along with the length.",
                                            "question": "How would you modify the solution to return the indices of the longest subarray?"
                                        },
                                        {
                                            "answer": "Extend the logic to handle both flipping operations by maintaining separate counters for flipped 1s and 0s. Adjust the sliding window to ensure both constraints are satisfied.",
                                            "question": "How would the problem change if flipping 1s into 0s were also allowed?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_fruitintobaskets",
                                "problem_name": " Fruit Into Baskets",
                                "problem_slug": "fruit-into-baskets",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Morgan Stanley",
                                        "Swiggy",
                                        "AMD",
                                        "PayPal",
                                        "Intel",
                                        "Bungie",
                                        "OYO Rooms",
                                        "Broadcom",
                                        "Lyft",
                                        "Seagate Technology",
                                        "Docker",
                                        "PwC",
                                        "Epic Systems",
                                        "Optum",
                                        "Alibaba",
                                        "Zynga",
                                        "Philips Healthcare",
                                        "Roche",
                                        "Instacart",
                                        "Etsy",
                                        "MongoDB",
                                        "GE Healthcare",
                                        "Oracle",
                                        "HashiCorp",
                                        "Deloitte",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a real-world application of the sliding window algorithm in software development. The sliding window concept is widely used in various programming scenarios like real-time data streaming where the algorithm helps in managing the flow of information. It's also critical in developing systems that handle network traffic management, or even simpler applications such as text editing software for tasks like \"find and replace\" where the problem domain is huge, but the task can be minimized to a \"window\" of text.",
                                    "hints": [
                                        {
                                            "hint": "Use a sliding window approach. Expand the window to include fruits from the current tree while ensuring the window contains fruits from no more than two different types. If the window contains more than two types, shrink it from the left until it satisfies the two-basket rule."
                                        },
                                        {
                                            "hint": "Use a hash map to keep track of the count of each fruit type in the current window. The hash map ensures you can quickly add or remove fruit types as the window expands or shrinks."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the array contains fewer than three types, the entire array is valid, and the result is the length of the array.",
                                            "question": "What if there are fewer than three types of fruit?"
                                        },
                                        {
                                            "answer": "The hash map tracks the count of each fruit type in the current window. When a fruit type is removed (due to shrinking the window), its count is decremented, and it is removed from the hash map if the count reaches zero.",
                                            "question": "How is the hash map used to manage the sliding window?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Generalize the sliding window approach to handle k baskets by ensuring the hash map contains at most k fruit types at any time. The rest of the logic remains the same.\n",
                                            "question": "How would you modify the solution if the number of baskets increased?"
                                        },
                                        {
                                            "answer": "Along with tracking the maximum size, store the indices of the start and end of the window whenever the maximum is updated. Return these indices.",
                                            "question": "What if you wanted to return the range of trees contributing to the maximum fruits?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_longestsubstringwithatmostkdistinctcharacters",
                                "problem_name": "Longest Substring With At Most K Distinct Characters",
                                "problem_slug": "longest-substring-with-at-most-k-distinct-characters",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Cloudflare",
                                        "Bungie",
                                        "Nutanix",
                                        "Roche",
                                        "Ernst & Young",
                                        "AMD",
                                        "Boston Consulting Group",
                                        "Riot Games",
                                        "Morgan Stanley",
                                        "Etsy",
                                        "Red Hat",
                                        "Visa",
                                        "Uber",
                                        "IBM",
                                        "Oracle",
                                        "Johnson & Johnson",
                                        "Micron Technology",
                                        "JPMorgan Chase",
                                        "GE Healthcare",
                                        "Salesforce",
                                        "Chewy",
                                        "MongoDB",
                                        "Alibaba",
                                        "Goldman Sachs",
                                        "Reddit",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The core concept of this problem is used in text and data analysis software. For example, in social media applications, analyzing the length of the longest substring with at most k distinct characters could help detect, track, or summarize major trends/topic, spam posts or even potential security breaches. Similarly, in bioinformatics, this idea could be applicable in DNA sequencing, where the longest substring of a DNA fragment with distinct kinds of nucleotides is important.",
                                    "hints": [
                                        {
                                            "hint": "Use a sliding window approach to find the longest substring with at most k distinct characters."
                                        },
                                        {
                                            "hint": "\"Use a hash map to store the frequency of each character in the current window. Keep track of the maximum length encountered during the traversal. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the string contains fewer than k distinct characters, the entire string is the longest substring. The result is the length of the string.",
                                            "question": "What if the string contains fewer than k distinct characters?"
                                        },
                                        {
                                            "answer": "The sliding window ensures that each character is processed at most twice (once when added and once when removed), resulting in an efficient O(n) solution.",
                                            "question": "Why use a sliding window approach?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Dynamically adjust the value of k as you process the string by recalculating the valid window boundaries whenever k changes.",
                                            "question": "How would you modify the solution to handle dynamic k values during traversal?"
                                        },
                                        {
                                            "answer": "Spaces and special characters are treated like any other character and can be part of the substring if their inclusion satisfies the k-distinct condition.",
                                            "question": "What if the input string contains spaces or special characters?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_longestrepeatingcharacterreplacement",
                                "problem_name": "Longest Repeating Character Replacement",
                                "problem_slug": "longest-repeating-character-replacement",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Western Digital",
                                        "Pinterest",
                                        "Target",
                                        "Epic Systems",
                                        "Freshworks",
                                        "Texas Instruments",
                                        "Square",
                                        "Byju's",
                                        "Databricks",
                                        "PayPal",
                                        "Cloudflare",
                                        "Boston Consulting Group",
                                        "Zoho",
                                        "Splunk",
                                        "Shopify",
                                        "Riot Games",
                                        "Oracle",
                                        "PwC",
                                        "Micron Technology",
                                        "Roche",
                                        "NVIDIA",
                                        "Flipkart",
                                        "Philips Healthcare",
                                        "Uber",
                                        "HashiCorp",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is highly relevant in search engine algorithms, particularly those dealing with text analysis and processing. The ability to manipulate and understand strings to achieve certain conditions is central to many features, such as autocomplete functions, spell checkers, and text-based recommendation algorithms. For example, Google's Search engine may use similar principles to understand and autocorrect your typos to give you accurate search results.",
                                    "hints": [
                                        {
                                            "hint": "Use a sliding window to find the longest substring where at most k characters are replaced to make all characters in the substring the same. "
                                        },
                                        {
                                            "hint": "Calculate the number of replacements needed to make all characters in the window the same as window_sizemax_freq."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The replacement count for a window is the total number of characters in the window minus the frequency of the most common character. This represents the number of characters that need to be changed.",
                                            "question": "How is the replacement count calculated?"
                                        },
                                        {
                                            "answer": "If all characters are identical, the entire string is valid without any replacements. The output is the length of the string.",
                                            "question": "What happens if all characters in the string are the same?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Adjust the frequency map to account for 52 characters (26 lowercase + 26 uppercase), or normalize the case before processing.",
                                            "question": "How would you handle lowercase letters or a mix of uppercase and lowercase?"
                                        },
                                        {
                                            "answer": "Track the start and end indices of the window whenever a new maximum length is found. Use these indices to extract the substring after completing the algorithm.",
                                            "question": "What if you wanted to return the actual substring instead of its length?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_longestandsmallestwindowproblems_minimumwindowsubstring",
                                "problem_name": "Minimum Window Substring",
                                "problem_slug": "minimum-window-substring-",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "Lyft",
                                        "Texas Instruments",
                                        "IBM",
                                        "Unity Technologies",
                                        "JPMorgan Chase",
                                        "Salesforce",
                                        "Cloudflare",
                                        "Swiggy",
                                        "ARM",
                                        "MongoDB",
                                        "Boston Consulting Group",
                                        "Morgan Stanley",
                                        "American Express",
                                        "KPMG",
                                        "Bungie",
                                        "Epic Systems",
                                        "Philips Healthcare",
                                        "Instacart",
                                        "PayPal",
                                        "Reddit",
                                        "Bain & Company",
                                        "Medtronic",
                                        "Splunk",
                                        "Rakuten",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, often referred to as the Minimum Window Substring problem, is frequently used in text processing applications to find the shortest relevant context for a set of keywords. For instance, in search engines, this concept can be adapted to extract the smallest snippet of text that contains all the search terms inputted by a user. Similarly, in Natural Language Processing (NLP), variations of this problem are used for tasks like entity recognition and sentiment analysis where relevant information needs to be extracted from larger blocks of text.",
                                    "hints": [
                                        {
                                            "hint": "Use a sliding window with two pointers (left and right) to find the smallest substring in s that contains all characters in t."
                                        },
                                        {
                                            "hint": "Create a frequency map for characters in t. Use another map to track the characters in the current window of s."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If any character in t is not present in s, its impossible to form a valid substring. The algorithm will return an empty string.",
                                            "question": "What happens if t contains characters not in s?"
                                        },
                                        {
                                            "answer": "The algorithm is designed to return the smallest valid window. If multiple windows have the same size, the first one encountered during traversal is returned.",
                                            "question": "What if multiple valid windows exist?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track the indices of the smallest valid window during the traversal. Return these indices instead of slicing the substring.",
                                            "question": "What if you wanted to return the start and end indices instead of the substring?"
                                        },
                                        {
                                            "answer": "If t is case-sensitive, the algorithm works as expected. If case insensitivity is required, normalize both s and t (e.g., convert to lowercase) before processing.",
                                            "question": "What happens if s contains mixed case letters?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "slidingwindow/2pointer_countingsubarrayspattern",
                        "subcategory_name": "Counting Subarrays / Substrings Problems",
                        "subcategory_slug": "counting-subarrays-and-substrings-problems",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_countingsubarrayspattern_numberofsubstringscontainingallthreecharacters",
                                "problem_name": "Number of Substrings Containing All Three Characters",
                                "problem_slug": "number-of-substrings-containing-all-three-characters",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Micron Technology",
                                        "ARM",
                                        "Optum",
                                        "Ernst & Young",
                                        "Western Digital",
                                        "Flipkart",
                                        "Ubisoft",
                                        "Salesforce",
                                        "Roche",
                                        "Dropbox",
                                        "Epic Games",
                                        "Goldman Sachs",
                                        "Epic Systems",
                                        "Zomato",
                                        "Philips Healthcare",
                                        "McKinsey & Company",
                                        "Splunk",
                                        "Intel",
                                        "Cloudflare",
                                        "Snowflake",
                                        "Roblox",
                                        "NVIDIA",
                                        "Instacart",
                                        "eBay",
                                        "Activision Blizzard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is closely related to the concept of string manipulation and substring search operations, which are fundamental to many real-world applications. For instance, web browsers use similar algorithms to perform quick text search functionality. Furthermore, text editors, word processors, and Integrated Development Environments (IDE's) often have 'Find' or 'Search' features that essentially solve this problem, scanning through the text to find sequences that match the user's input. Counting occurrences can also be relevant in text analysis or processing tasks in natural language understanding, where we might need to quantify the instances of a certain word or character sequence in a document.",
                                    "hints": [
                                        {
                                            "hint": "Use a sliding window to determine all substrings that contain at least one occurrence of the characters 'a', 'b', and 'c'. "
                                        },
                                        {
                                            "hint": "Maintain a frequency map (or array of size 3, one for each of 'a', 'b', and 'c') to track the count of each character in the current window."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Once a window satisfies the condition, shrinking it ensures you explore the smallest valid substrings while maintaining all necessary characters. This reduces redundant checks.",
                                            "question": "Why does shrinking the window work?"
                                        },
                                        {
                                            "answer": "The algorithm efficiently calculates valid substrings without enumerating all possible substrings. It dynamically counts substrings for each valid window, avoiding unnecessary computations.",
                                            "question": "What happens if characters appear in large consecutive blocks (e.g., \"aaaabbbbcccc\")?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For more characters, increase the size of the frequency map and apply the same sliding window logic. The algorithm's efficiency remains linear, as the fixed size of the map ensures constant-time updates.",
                                            "question": "How would you extend this to handle more characters?"
                                        },
                                        {
                                            "answer": "Modify the frequency map check to ensure each character has exactly one count in the current window before counting substrings.\n",
                                            "question": "What if the problem asks for exactly one occurrence of each character in the substring?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_countingsubarrayspattern_binarysubarrayswithsum",
                                "problem_name": "Binary Subarrays With Sum",
                                "problem_slug": "binary-subarrays-with-sum",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Stripe",
                                        "Nutanix",
                                        "Lyft",
                                        "Chewy",
                                        "Red Hat",
                                        "Roblox",
                                        "OYO Rooms",
                                        "Flipkart",
                                        "Siemens Healthineers",
                                        "Cerner",
                                        "Splunk",
                                        "Morgan Stanley",
                                        "Shopify",
                                        "Robinhood",
                                        "ARM",
                                        "Bain & Company",
                                        "Zoho",
                                        "AMD",
                                        "Deloitte",
                                        "McKinsey & Company",
                                        "HCL Technologies",
                                        "Databricks",
                                        "Target",
                                        "JPMorgan Chase",
                                        "Epic Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem utilizes the concept of subarray sum computations, which are widely used in real-world applications such as image processing, where contiguous blocks of pixels need to be processed or manipulated. The concept is also used in data analysis applications where sequential data chunks need to be analyzed for a specified sum, like in financial software for calculating running totals in account statements. As an example, it is used in the implementation of features like \"balance within last X transactions\".",
                                    "hints": [
                                        {
                                            "hint": "Use a prefix sum to keep track of the cumulative sum up to each index. Store the count of each prefix sum in a hash map to efficiently determine how many subarrays with a sum equal to the goal exist."
                                        },
                                        {
                                            "hint": "For a subarray sum to equal the goal, the relationship current_sumgoal=prefix_sum must hold. Use the hash map to check how many times prefix_sum has occurred so far. Add that count to the result."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The hash map allows O(1) time complexity for lookups and updates, enabling an efficient O(n) solution for this problem.",
                                            "question": "Why use a hash map for prefix sums?"
                                        },
                                        {
                                            "answer": "Subarrays consisting entirely of zeros can satisfy the condition. Use the prefix sum logic to count the number of such subarrays efficiently.",
                                            "question": "What if all elements are zero and the goal is zero?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the algorithm to use cumulative counts and ranges to count subarrays where the sum is less than the goal, potentially requiring a nested loop or Fenwick tree.",
                                            "question": "What if the problem asked for the count of subarrays where the sum is less than the goal?"
                                        },
                                        {
                                            "answer": "Extend the hash map to track counts for multiple goals simultaneously or process each goal separately, depending on constraints.",
                                            "question": "How would you handle the case of multiple goals (e.g., a list of goals)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "slidingwindow/2pointer_slidingwindow/2pointer_countingsubarrayspattern_countnumberofnicesubarrays",
                                "problem_name": "Count number of Nice subarrays",
                                "problem_slug": "count-number-of-nice-subarrays",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Activision Blizzard",
                                        "Riot Games",
                                        "Boston Consulting Group",
                                        "Oracle",
                                        "McKinsey & Company",
                                        "Epic Games",
                                        "Deloitte",
                                        "IBM",
                                        "Wayfair",
                                        "GE Healthcare",
                                        "Teladoc Health",
                                        "Johnson & Johnson",
                                        "Broadcom",
                                        "AMD",
                                        "Square",
                                        "Salesforce",
                                        "ARM",
                                        "Micron Technology",
                                        "Ubisoft",
                                        "Unity Technologies",
                                        "Target",
                                        "DoorDash",
                                        "Reddit",
                                        "Chewy",
                                        "HCL Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This kind of problem is commonly seen in data analysis or data science domains where there is a need to analyze subarrays or sub-data-frames for given conditions. A real-world application might be the analysis of user behavior patterns in tech companies, such as Netflix or YouTube, where they need to identify consecutive streams (i.e., subarrays) with some specific characteristics (in the problem, it's 'k odd numbers'). The retrieved results from this analysis can help to personalize content for users, improving user engagement with the platform.",
                                    "hints": [
                                        {
                                            "hint": "Identify the positions of odd numbers in the array. Each \"nice\" subarray must contain exactly k odd numbers. Use a prefix sum or sliding window approach to count subarrays with exactly k odd numbers."
                                        },
                                        {
                                            "hint": "Maintain two pointers (left and right) to define the current subarray. Expand the window by moving the right pointer until the subarray contains k odd numbers. Once the subarray contains k odd numbers, count all valid subarrays starting from the left pointer."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The sliding window approach dynamically adjusts the subarray boundaries to count all valid subarrays efficiently without recalculating overlapping subarrays.",
                                            "question": "How does the sliding window approach handle overlapping subarrays?"
                                        },
                                        {
                                            "answer": "The prefix sum allows you to count subarrays with a specific number of odd numbers efficiently by checking for specific differences in cumulative sums.",
                                            "question": "Why use prefix sums for this problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend the prefix sum or sliding window logic to handle each k value separately or track counts dynamically using an advanced data structure like a Fenwick tree.",
                                            "question": "How would you modify the solution to handle multiple values of k?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "slidingwindow/2pointer_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 5,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "max_odd_numbers_in_k_window",
                                "problem_name": "Max Odd Numbers in K Window",
                                "problem_slug": "max-odd-numbers-in-k-window",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "maximum_length_good_subarray",
                                "problem_name": "Maximum Good Subarray Length",
                                "problem_slug": "maximum-length-good-subarray",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "number_of_subarray_with_or_less_than_k",
                                "problem_name": "Number of Subarrays with Or less than K",
                                "problem_slug": "number-of-subarray-with-or-less-than-k",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "stack/queues",
                "category_name": "Stack / Queues",
                "category_slug": "stack-and-queues",
                "category_rank": 10,
                "subcategories": [
                    {
                        "subcategory_id": "stack/queues_implementation",
                        "subcategory_name": "Implementation",
                        "subcategory_slug": "implementation",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "stack/queues_stack/queues_implementation_implementationusingdifferentds",
                                "problem_name": "Implementation using different DS",
                                "problem_slug": "implementation-using-different-ds",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementstackusingarrays",
                                "problem_name": "Implement Stack using Arrays",
                                "problem_slug": "implement-stack-using-arrays",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Epic Games",
                                        "AMD",
                                        "Target",
                                        "MongoDB",
                                        "Activision Blizzard",
                                        "PayPal",
                                        "Goldman Sachs",
                                        "Airbnb",
                                        "Roblox",
                                        "Teladoc Health",
                                        "Siemens Healthineers",
                                        "Byju's",
                                        "Salesforce",
                                        "Alibaba",
                                        "American Express",
                                        "ARM",
                                        "Freshworks",
                                        "Red Hat",
                                        "Broadcom",
                                        "Rockstar Games",
                                        "Intel",
                                        "Docker",
                                        "Twilio",
                                        "Seagate Technology",
                                        "Unity Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "The concept of Last-In-First-Out (LIFO) stacks is widely used in real-world scenarios such as managing function calls in programming languages. Each time a function is called, the system 'pushes' contexts onto a call stack. When the function is done, the system 'pops' the context off of the stack and restore the state before the call. This call stack is fundamental to enabling function calls and recursion in virtually all modern programming languages. Similarly, the 'undo' feature in many software applications (like text editors or graphic design tools) is often implemented using a stack.",
                                    "hints": [
                                        {
                                            "hint": "Calling pop() or top() on an empty stack should raise an appropriate exception."
                                        },
                                        {
                                            "hint": "Ensure isEmpty() accurately reflects whether the stack has elements."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "An IndexError will be raised. To handle this, explicitly check if the stack is empty before popping.",
                                            "question": "What happens if I call pop() on an empty stack? "
                                        },
                                        {
                                            "answer": "top() returns the last element without removing it. pop() removes and returns the last element.",
                                            "question": "What is the difference between top() and pop()? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a secondary minStack that tracks the minimum element at each push operation. When popping, also pop from minStack if the popped element was the minimum.",
                                            "question": "How would you implement a stack that supports retrieving the minimum element in constant time? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementqueueusingarrays",
                                "problem_name": "Implement Queue using Arrays",
                                "problem_slug": "implement-queue-using-arrays",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Nutanix",
                                        "Morgan Stanley",
                                        "Wayfair",
                                        "Pinterest",
                                        "PayPal",
                                        "Visa",
                                        "Medtronic",
                                        "HashiCorp",
                                        "Johnson & Johnson",
                                        "Snowflake",
                                        "Cloudflare",
                                        "Ernst & Young",
                                        "Siemens Healthineers",
                                        "Texas Instruments",
                                        "NVIDIA",
                                        "Riot Games",
                                        "Epic Systems",
                                        "American Express",
                                        "Chewy",
                                        "Robinhood",
                                        "Flipkart",
                                        "Bloomberg",
                                        "Rockstar Games",
                                        "Dropbox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Think of it as a line at a checkout counter where the first person in line gets served first."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A list provides simple enqueue and dequeue operations, but pop(0) is inefficient. A linked list avoids shifting elements, making dequeue operations O(1).",
                                            "question": "Why use a list instead of another data structure like a linked list? "
                                        },
                                        {
                                            "answer": "Yes, but a circular queue implementation would be needed to handle wrap-around conditions.",
                                            "question": "Can I use an array with a fixed size instead of a dynamic list? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain front and rear pointers to track the first and last elements. Use a Node class to store values and references to the next node.",
                                            "question": "How would you implement a queue using a linked list? "
                                        },
                                        {
                                            "answer": "Use a fixed-size array with two pointers (front and rear).",
                                            "question": "How would you implement a circular queue to optimize memory usage? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementstackusingqueue",
                                "problem_name": "Implement Stack using Queue",
                                "problem_slug": "implement-stack-using-queue",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Bungie",
                                        "Goldman Sachs",
                                        "Alibaba",
                                        "Instacart",
                                        "Robinhood",
                                        "Zoho",
                                        "Siemens Healthineers",
                                        "Mastercard",
                                        "Activision Blizzard",
                                        "Pinterest",
                                        "HCL Technologies",
                                        "Freshworks",
                                        "Bloomberg",
                                        "Roche",
                                        "ARM",
                                        "Reddit",
                                        "MongoDB",
                                        "Flipkart",
                                        "Qualcomm",
                                        "Square",
                                        "Western Digital",
                                        "Electronic Arts",
                                        "Johnson & Johnson",
                                        "Lyft",
                                        "Cloudflare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "To implement a stack using a single queue, we need to reverse the order of elements within the queue after each push() operation."
                                        },
                                        {
                                            "hint": "After inserting a new element, rotate the queue so that the newest element moves to the front."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A single queue is more space-efficient, but it requires additional rotations during push(). Two queues can also be used, but they require extra storage.",
                                            "question": "Why use a single queue instead of two queues? "
                                        },
                                        {
                                            "answer": "Since queues follow FIFO order, new elements normally go to the end. Rotating the queue moves the newest element to the front, simulating a stacks LIFO behavior.",
                                            "question": "Why rotate the queue after every push()? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "One approach is to enqueue elements into one queue and use the second queue to rearrange them when popping.",
                                            "question": "How would you implement a stack using two queues? "
                                        },
                                        {
                                            "answer": "Use two queues to optimize push() to O(1) while making pop() O(n).",
                                            "question": "How can you optimize the approach to make push() more efficient? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementqueueusingstack",
                                "problem_name": "Implement Queue using Stack",
                                "problem_slug": "implement-queue-using-stack",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Deloitte",
                                        "eBay",
                                        "Zoho",
                                        "Red Hat",
                                        "Mastercard",
                                        "DoorDash",
                                        "Roblox",
                                        "PayPal",
                                        "Oracle",
                                        "KPMG",
                                        "Dropbox",
                                        "Alibaba",
                                        "HCL Technologies",
                                        "Airbnb",
                                        "Texas Instruments",
                                        "Zomato",
                                        "Chewy",
                                        "IBM",
                                        "Twilio",
                                        "Bain & Company",
                                        "Siemens Healthineers",
                                        "Bungie",
                                        "Roche",
                                        "Splunk",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "To implement a queue using a single stack, we need to reverse the order when dequeuing elements."
                                        },
                                        {
                                            "hint": "\"Calling pop() or peek() on an empty queue should raise an appropriate exception. Ensure isEmpty() accurately reflects whether the queue has elements.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since a stack removes elements in LIFO order, recursion helps reach the first inserted element (bottom of the stack), retrieve it, and restore the order.",
                                            "question": "Why use recursion to implement pop() and peek()? "
                                        },
                                        {
                                            "answer": "Yes, using two stacks would allow pop() to be O(1) amortized, but this implementation requires only one stack.",
                                            "question": "Can we make pop() more efficient? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use one stack for enqueue (push()) and another for dequeue (pop() and peek()). When pop() is called, transfer elements from the push stack to the pop stack only if the pop stack is empty.",
                                            "question": "How would you optimize this solution using two stacks? "
                                        },
                                        {
                                            "answer": "Maintain a counter that updates when push() or pop() is called.",
                                            "question": "How would you modify this to return the size of the queue? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementstackusinglinkedlist",
                                "problem_name": "Implement stack using Linkedlist",
                                "problem_slug": "implement-stack-using-linkedlist",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Johnson & Johnson",
                                        "American Express",
                                        "Rockstar Games",
                                        "Swiggy",
                                        "Airbnb",
                                        "Ernst & Young",
                                        "Pinterest",
                                        "Splunk",
                                        "Bungie",
                                        "Intel",
                                        "Micron Technology",
                                        "KPMG",
                                        "Roblox",
                                        "Bloomberg",
                                        "Seagate Technology",
                                        "Byju's",
                                        "Flipkart",
                                        "PwC",
                                        "Wayfair",
                                        "PayPal",
                                        "Riot Games",
                                        "Texas Instruments",
                                        "Siemens Healthineers",
                                        "Nutanix",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"A brute-force approach would use: An array-based stack (O(1) time, O(n) space), but resizing operations make it inefficient.\""
                                        },
                                        {
                                            "hint": "\"Use a singly linked list where: Each node stores a value and a pointer to the next node. The top of the stack is represented by the head of the list.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A linked list does not require resizing like an array, making it more memory efficient when dealing with unknown sizes. Insertions and deletions at the head take O(1) time, while an array-based stack may require shifting elements when using a fixed-size array.",
                                            "question": "Why use a linked list instead of an array? "
                                        },
                                        {
                                            "answer": "A new node is created and inserted at the head of the linked list in O(1) time.",
                                            "question": "How does push() work in constant time? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A doubly linked list would allow push() and pop() in O(1) but consumes extra memory for storing the prev pointer.",
                                            "question": "What if we want a doubly linked list instead? "
                                        },
                                        {
                                            "answer": "Maintain a secondary stack that keeps track of the minimum value at each push operation.",
                                            "question": "How would you modify this implementation for a min-stack (stack that retrieves the minimum element in O(1))? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "extras_extras_basicstacks_implementqueueusinglinkedlist",
                                "problem_name": "Implement queue using Linkedlist",
                                "problem_slug": "implement-queue-using-linkedlist",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Chewy",
                                        "Dropbox",
                                        "Rakuten",
                                        "Medtronic",
                                        "Cloudflare",
                                        "Roblox",
                                        "Seagate Technology",
                                        "Boston Consulting Group",
                                        "Cerner",
                                        "Nutanix",
                                        "Wayfair",
                                        "Mastercard",
                                        "Target",
                                        "GE Healthcare",
                                        "Broadcom",
                                        "PayPal",
                                        "Teladoc Health",
                                        "Intel",
                                        "Ubisoft",
                                        "Airbnb",
                                        "Bungie",
                                        "ARM",
                                        "Johnson & Johnson",
                                        "HCL Technologies",
                                        "Electronic Arts",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Maintain two pointers: Front Pointer: Points to the first node, allowing quick removal. Rear Pointer: Points to the last node, allowing quick insertion. "
                                        },
                                        {
                                            "hint": "After the last element is dequeued, reset the rear pointer to None to avoid dangling references. When inserting the first element, both front and rear should point to it."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The function raises an IndexError, ensuring that the caller handles empty queue conditions",
                                            "question": "What happens if pop() is called on an empty queue? ."
                                        },
                                        {
                                            "answer": "Yes, since linked lists dynamically allocate memory, the queue can handle a large number of elements without resizing.",
                                            "question": "Can this implementation handle large numbers of elements? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a counter that updates when push() or pop() is called.",
                                            "question": "How would you modify this to return the size of the queue? "
                                        },
                                        {
                                            "answer": "Instead of setting rear.next = None, point it back to front, creating a circular structure.",
                                            "question": "How would you implement a circular queue using a linked list? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_implementation_balancedparanthesis",
                                "problem_name": "Balanced Paranthesis",
                                "problem_slug": "balanced-paranthesis",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Goldman Sachs",
                                        "Walmart",
                                        "Twilio",
                                        "Rockstar Games",
                                        "Red Hat",
                                        "Cerner",
                                        "Oracle",
                                        "PwC",
                                        "GE Healthcare",
                                        "Johnson & Johnson",
                                        "Docker",
                                        "Zomato",
                                        "Electronic Arts",
                                        "Western Digital",
                                        "HCL Technologies",
                                        "Siemens Healthineers",
                                        "Ubisoft",
                                        "ARM",
                                        "Micron Technology",
                                        "Uber",
                                        "Deloitte",
                                        "Broadcom",
                                        "Snowflake",
                                        "Stripe",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe",
                                        "TCS",
                                        "Cognizant",
                                        "Accenture",
                                        "Infosys",
                                        "Capgemini",
                                        "Wipro"
                                    ],
                                    "facts": "This problem is essential in software development, particularly in languages like Python, JavaScript, or C++ where brackets are used extensively to delimit blocks of code, arrays and objects. An imbalance in brackets can cause a program to fail, often leading to \"syntax error\" messages. This real-world application is not exclusive to coding; it's also vital in validation of data formats like JSON and XML, ensuring that they are well-structured and correctly nested.",
                                    "hints": [
                                        {
                                            "hint": "Use a stack to store opening brackets (, {, [."
                                        },
                                        {
                                            "hint": "When encountering a closing bracket ), }, ]. Check if the top of the stack is its corresponding opening bracket. If matched, pop the opening bracket. Otherwise, return false."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, valid strings can have nested and interleaved brackets, like {[()()]}. The stack ensures the correct closing order by matching the last opened bracket first.",
                                            "question": "Can there be interleaved brackets? "
                                        },
                                        {
                                            "answer": "If only brackets are allowed, ignore any additional characters in preprocessing. If mixed characters are allowed, the logic should be applied only to bracket characters.",
                                            "question": "What if the string contains non-bracket characters? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend the bracket pair mapping { \"(\": \")\", \"{\": \"}\", \"[\": \"]\", \"<\": \">\" } to include the new bracket type.",
                                            "question": "How would you modify this for different types of brackets (e.g., < and >)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "stack/queues_monotonicstack",
                        "subcategory_name": "Monotonic Stack",
                        "subcategory_slug": "monotonic-stack",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_nextgreaterelement",
                                "problem_name": "Next Greater Element",
                                "problem_slug": "next-greater-element",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Electronic Arts",
                                        "Wayfair",
                                        "Etsy",
                                        "Morgan Stanley",
                                        "Micron Technology",
                                        "Chewy",
                                        "KPMG",
                                        "Rakuten",
                                        "Teladoc Health",
                                        "Riot Games",
                                        "Texas Instruments",
                                        "OYO Rooms",
                                        "Robinhood",
                                        "Airbnb",
                                        "Twilio",
                                        "JPMorgan Chase",
                                        "Seagate Technology",
                                        "Freshworks",
                                        "Rockstar Games",
                                        "Snowflake",
                                        "Reddit",
                                        "Red Hat",
                                        "Databricks",
                                        "NVIDIA",
                                        "AMD",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is directly applicable in the field of data analysis or processing, where efficient computation and extraction of future values based on current values are required. Utilizing such algorithms can assist in identifying trends or making predictions in time series data. For instance, in financial technology applications, this problem can be used to detect the next high point of a given stock's price.",
                                    "hints": [
                                        {
                                            "hint": "A decreasing stack (monotonic decreasing order) helps efficiently track elements whose next greater element is yet to be found. Traverse the array from right to left"
                                        },
                                        {
                                            "hint": "Maintain a stack of elements, ensuring the top element is always greater than the current element."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The next greater element is always on the right, so processing elements in reverse order ensures we efficiently store and retrieve values.",
                                            "question": "Why traverse from right to left?"
                                        },
                                        {
                                            "answer": "A maximum suffix array only tracks the largest element to the right, while a stack efficiently finds the nearest greater element.",
                                            "question": "Why do we use a stack instead of keeping a maximum suffix array? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of maintaining a decreasing stack, use an increasing stack, so the top element is always the smallest encountered.",
                                            "question": "How can we modify this approach to find the Next Smaller Element (NSE)? "
                                        },
                                        {
                                            "answer": "Traverse the array twice while using the stack, simulating a circular array by considering elements from the start after the first pass.",
                                            "question": "How would you extend this problem to a circular array (where elements wrap around)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_nextgreaterelement-2",
                                "problem_name": "Next Greater Element - 2",
                                "problem_slug": "next-greater-element---2",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Micron Technology",
                                        "Freshworks",
                                        "Cerner",
                                        "Splunk",
                                        "Byju's",
                                        "Walmart",
                                        "Ubisoft",
                                        "Oracle",
                                        "MongoDB",
                                        "Reddit",
                                        "NVIDIA",
                                        "Pinterest",
                                        "Ernst & Young",
                                        "DoorDash",
                                        "HCL Technologies",
                                        "Epic Systems",
                                        "Stripe",
                                        "OYO Rooms",
                                        "KPMG",
                                        "Cloudflare",
                                        "Rakuten",
                                        "Western Digital",
                                        "Epic Games",
                                        "Bungie",
                                        "Flipkart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem reflects the concept of circular buffers which is prevalent in software development, specifically in systems programming. Circular buffers are frequently used in data communications to handle volatile data or in cases where data arrival and consumption does not occur at the same rate. They are also used in multimedia applications for stream buffering. As a specific example, Linux uses circular buffers in the kernel for storing log data. The idea of finding the 'next greater element' in a circular buffer might be useful in designing load balancing algorithms and optimizing data flows.",
                                    "hints": [
                                        {
                                            "hint": "Since the array is circular, we simulate two passes over the array by iterating twice (2n iterations). For every element."
                                        },
                                        {
                                            "hint": "For every element in the first pass, push it onto the stack, and during the second pass, process elements as if the array is extended. If an element finds a greater element in the first or second pass, update its NGE; otherwise, assign -1."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of using modulus arithmetic, simply traverse the array twice to simulate the circular nature. This avoids unnecessary complexity while keeping the solution efficient.",
                                            "question": "Why do we iterate twice instead of modifying indices? "
                                        },
                                        {
                                            "answer": "The stack stores only relevant elements whose NGE is yet to be found. When a greater element appears, we resolve all smaller elements in one go, avoiding redundant checks.",
                                            "question": "How does the stack help avoid unnecessary comparisons? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The problem reduces to the standard Next Greater Element problem using a single-pass stack approach.",
                                            "question": "How would this solution change if the array was not circular? "
                                        },
                                        {
                                            "answer": "Yes, by checking all elements ahead (including wrapping around) for each element, but that results in an inefficient O(n^2) complexity.",
                                            "question": "Can this be solved using a brute-force approach? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_asteroidcollision",
                                "problem_name": "Asteroid Collision",
                                "problem_slug": "asteroid-collision",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Dropbox",
                                        "Epic Systems",
                                        "Splunk",
                                        "IBM",
                                        "Reddit",
                                        "Visa",
                                        "Broadcom",
                                        "AMD",
                                        "Flipkart",
                                        "Pinterest",
                                        "ARM",
                                        "Zomato",
                                        "Zynga",
                                        "GE Healthcare",
                                        "Electronic Arts",
                                        "Robinhood",
                                        "Stripe",
                                        "Walmart",
                                        "Etsy",
                                        "Target",
                                        "Red Hat",
                                        "Intel",
                                        "Teladoc Health",
                                        "Johnson & Johnson",
                                        "Airbnb",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One real-world application of the \"asteroid collision\" problem is in video game development. This resembles concepts utilized in physics engines, which simulate and predict the interactions between objects in a game world, such as asteroids colliding and exploding in a space-themed game. If two in-game entities collide, their size (or health points), direction, and velocity are factors that decide the outcome - similar to the asteroid collision problem. Handling these interactions correctly is crucial in developing games with realistic and enjoyable gameplay mechanics.",
                                    "hints": [
                                        {
                                            "hint": "Iterate through the list, pushing positive asteroids onto a stack since they are moving right."
                                        },
                                        {
                                            "hint": "When encountering a negative asteroid, check against the stack. If the top of the stack is a positive asteroid, simulate a collision. If the negative asteroid survives, continue checking until it is either destroyed or pushed onto the stack. The stack maintains the final state of the surviving asteroids."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The smaller asteroid is removed from the stack, and the larger asteroid continues moving.",
                                            "question": "What happens when a larger asteroid collides with a smaller one? "
                                        },
                                        {
                                            "answer": "Yes, a large negative asteroid can destroy multiple right-moving asteroids before stopping.",
                                            "question": "Can a single asteroid survive after multiple collisions? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If asteroids bounced off instead of exploding, a queue might be more suitable for handling movement.",
                                            "question": "How would the problem change if asteroids could bounce instead of exploding? "
                                        },
                                        {
                                            "answer": "A priority queue or event-driven simulation would be needed to track asteroid movement and interactions in both directions.",
                                            "question": "How would you modify the solution for 2D space (instead of a single row)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_sumofsubarrayminimums",
                                "problem_name": "Sum of Subarray Minimums",
                                "problem_slug": "sum-of-subarray-minimums",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Micron Technology",
                                        "Alibaba",
                                        "Etsy",
                                        "Stripe",
                                        "Splunk",
                                        "Epic Systems",
                                        "Mastercard",
                                        "Rakuten",
                                        "Byju's",
                                        "Reddit",
                                        "Nutanix",
                                        "Texas Instruments",
                                        "Walmart",
                                        "Johnson & Johnson",
                                        "PwC",
                                        "Twilio",
                                        "Epic Games",
                                        "Roblox",
                                        "Boston Consulting Group",
                                        "Unity Technologies",
                                        "Ernst & Young",
                                        "Siemens Healthineers",
                                        "eBay",
                                        "Swiggy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem highlights and tests understanding in array manipulation and dynamic programming, which are essential concepts used in a variety of fields in the software industry. For instance, efficient array manipulation like calculating sums of subarrays can be found at the core of data processing libraries used in data analysis and machine learning, such as NumPy and Pandas in Python. Similarly, understanding of subarray computations is also useful in developing efficient algorithms in computer graphics for operations such as image cropping and rotation. This problem's requirement to return the answer modulus a large number is a common technique used when dealing with very large numbers to prevent arithmetic overflow, which is an essential consideration in fields ranging from cryptography to scientific computing.",
                                    "hints": [
                                        {
                                            "hint": "Instead of generating all subarrays, count how many times each element is the minimum in different subarrays. Use a monotonic increasing stack to determine for each element."
                                        },
                                        {
                                            "hint": "Traverse left to right using a monotonic increasing stack to compute L[i]. Traverse right to left using a monotonic increasing stack to compute R[i]."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It finds how many previous elements are greater than the current one, meaning arr[i] is the minimum for those subarrays.",
                                            "question": "How does the left boundary (L[i]) calculation work? "
                                        },
                                        {
                                            "answer": "Yes, but since we take modulo (10 + 7) at the end, the calculations remain valid.",
                                            "question": "Can negative numbers appear in the array? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of a monotonic increasing stack, use a monotonic decreasing stack.",
                                            "question": "How would the approach change for the sum of the maximum elements in each subarray? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_sumofsubarrayranges",
                                "problem_name": "Sum of Subarray Ranges",
                                "problem_slug": "sum-of-subarray-ranges",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Splunk",
                                        "Twilio",
                                        "Alibaba",
                                        "Optum",
                                        "Texas Instruments",
                                        "NVIDIA",
                                        "GE Healthcare",
                                        "Freshworks",
                                        "Deloitte",
                                        "Johnson & Johnson",
                                        "Zomato",
                                        "Roche",
                                        "Nutanix",
                                        "JPMorgan Chase",
                                        "OYO Rooms",
                                        "ARM",
                                        "PayPal",
                                        "HashiCorp",
                                        "Instacart",
                                        "Airbnb",
                                        "Intel",
                                        "Unity Technologies",
                                        "Teladoc Health",
                                        "Epic Systems",
                                        "Walmart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fact: The concept underlying this problem is extensively used in financial and data analysis software. In the finance industry, similar algorithms can be applied to analyze the volatility of stock prices over various sub periods. Likewise, in data analysis platforms, they can calculate metrics such as range of values over sliding windows. Calculating the range is a crucial part of identifying the spread of data which can provide insight into the level of variability or volatility within a dataset.",
                                    "hints": [
                                        {
                                            "hint": "Use two monotonic stacks. One to track next greater elements (for maximum contribution). Another to track next smaller elements (for minimum contribution)."
                                        },
                                        {
                                            "hint": "Compute Left bound and Right Bound. The result is the difference between sum of maximum - minimum contributions."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The stack keeps track of previously encountered elements and allows quick retrieval of how many subarrays an element influences.",
                                            "question": "How does the stack help compute min/max contributions? "
                                        },
                                        {
                                            "answer": "To efficiently count how many subarrays include an element as the max or min.",
                                            "question": "Why do we process both left and right boundaries? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, a similar monotonic stack technique can be used to count contributions efficiently.",
                                            "question": "Can this be extended to finding the sum of absolute differences of subarrays? "
                                        },
                                        {
                                            "answer": "Brute force takes O(n), while the stack-based approach reduces it to O(n).",
                                            "question": "How does this approach compare to brute-force solutions? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_monotonicstack_removekdigits",
                                "problem_name": "Remove K Digits",
                                "problem_slug": "remove-k-digits",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Bloomberg",
                                        "Salesforce",
                                        "Docker",
                                        "Pinterest",
                                        "KPMG",
                                        "Freshworks",
                                        "Rakuten",
                                        "Roche",
                                        "AMD",
                                        "Micron Technology",
                                        "Visa",
                                        "HCL Technologies",
                                        "ARM",
                                        "HashiCorp",
                                        "Walmart",
                                        "Byju's",
                                        "Red Hat",
                                        "Electronic Arts",
                                        "Cloudflare",
                                        "Ernst & Young",
                                        "Alibaba",
                                        "Airbnb",
                                        "Epic Systems",
                                        "Unity Technologies",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is very akin to the concept of data compression used in many software applications and it also has relevance in financial tech apps. For instance, some apps need to display a large numerical data to users in an abridged format due to screen size limitations. They may abbreviate the number by removing less significant digits, essentially solving a problem similar to the one described. Similarly, in algorithmic trading, removing less significant digits (or \"points\") from large financial data is a routine task.",
                                    "hints": [
                                        {
                                            "hint": "Use a monotonic increasing stack to maintain the digits that will form the final number."
                                        },
                                        {
                                            "hint": "While iterating through nums. If the current digit is smaller than the top of the stack, remove the top of the stack (if k > 0). Push the current digit onto the stack."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Convert the stack into a string and use .lstrip('0') to remove them. If the result is an empty string, return \"0\".",
                                            "question": "What happens if there are leading zeros in the final result? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A stack ensures efficient removal of large digits while maintaining order. A naive greedy approach might repeatedly scan the array, leading to O(nk) time complexity.",
                                            "question": "How does this compare to a greedy approach without a stack? "
                                        },
                                        {
                                            "answer": "Without order constraints, sorting could be applied, but that would change the problem scope.",
                                            "question": "How would this approach change if we were allowed to rearrange the digits? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "stack/queues_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_implementminstack",
                                "problem_name": "Implement Min Stack",
                                "problem_slug": "implement-min-stack",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Lyft",
                                        "HashiCorp",
                                        "Visa",
                                        "Uber",
                                        "JPMorgan Chase",
                                        "Robinhood",
                                        "Zoho",
                                        "Qualcomm",
                                        "Target",
                                        "OYO Rooms",
                                        "Stripe",
                                        "Johnson & Johnson",
                                        "eBay",
                                        "Siemens Healthineers",
                                        "Cloudflare",
                                        "Unity Technologies",
                                        "MongoDB",
                                        "Morgan Stanley",
                                        "Activision Blizzard",
                                        "Snowflake",
                                        "American Express",
                                        "Flipkart",
                                        "Shopify",
                                        "Roche",
                                        "Docker",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Designing a stack that supports operations like push, pop, top, and retrieving the minimum element in constant time is very relevant in real-world software development. One classic example is in the design of the \"Undo\" functionality in many software programs like text editors, image editing tools, or even web browsers. Each action is 'pushed' onto the stack, then 'popped' off when the user triggers the 'Undo' command. The 'top' operation can help show a preview of the action that will be undone next. The 'getMin' operation, though might not be directly applicable in this case, could still be used in related contexts, say, retrieving the minimal state or least resource-intensive action from a stack of operations. This problem is essentially about efficiently managing and accessing data, a central aspect of software development.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would store elements in a normal stack and find the minimum by scanning all elements on each getMin() call, resulting in O(n) worst-case time complexity."
                                        },
                                        {
                                            "hint": "Use a primary stack (stack) to store elements. Use a secondary stack (min_stack) to track the minimum value at each push. When pushing a new element, compare it with the current minimum. Push the smaller value onto min_stack. When popping, remove from both stacks."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If we only track a single min variable, we lose previous minimums after popping.",
                                            "question": "Why do we need a min_stack instead of tracking min normally? "
                                        },
                                        {
                                            "answer": "min_stack correctly keeps track of previous min values, even if duplicates exist.",
                                            "question": "What happens when multiple elements have the same minimum value? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a self-balancing BST (e.g., AVL tree) or a MinHeap.",
                                            "question": "What if we had to track the k-th minimum instead of just the min? "
                                        },
                                        {
                                            "answer": "MinHeap supports min tracking but is O(log n) for insert/remove, while this stack achieves O(1).",
                                            "question": "How does this compare to a priority queue for tracking the min? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_slidingwindowmaximum",
                                "problem_name": "Sliding Window Maximum",
                                "problem_slug": "sliding-window-maximum",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Qualcomm",
                                        "Activision Blizzard",
                                        "Ubisoft",
                                        "Bain & Company",
                                        "Twilio",
                                        "Reddit",
                                        "ARM",
                                        "Epic Systems",
                                        "Freshworks",
                                        "NVIDIA",
                                        "Docker",
                                        "Cloudflare",
                                        "McKinsey & Company",
                                        "Wayfair",
                                        "Optum",
                                        "Salesforce",
                                        "Visa",
                                        "Unity Technologies",
                                        "Philips Healthcare",
                                        "Instacart",
                                        "Intel",
                                        "Teladoc Health",
                                        "American Express",
                                        "Swiggy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "A real-world application of this programming problem can be found in financial sectors and data analytics. The concept of a \"sliding window\" is equivalent to moving averages or other rolling statistics used in stock market, commodity, and economic analysis, where the most recent 'k' data points are used to make forecasts. For instance, a 50-day or 200-day moving average (which are very common in stock market analysis) would be a \"sliding window\" of 50 or 200 data points, hence the maximum (highest) value within that window can be beneficial in predicting or setting stock sales thresholds.",
                                    "hints": [
                                        {
                                            "hint": "Deque-based solution is Maintain a monotonic decreasing deque (stores indices). The front of the deque always holds the max. Remove elements not within the current window. Remove smaller elements before inserting a new element."
                                        },
                                        {
                                            "hint": "Max Heap-based solution Maintain a Max Heap (priority queue) of size k. Extract max at each step, ensuring only valid elements remain."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The deque is monotonic decreasing, ensuring that each element is pushed only once and popped at most once, leading to an amortized O(n) complexity. Unlike brute force, we dont repeatedly scan the window.",
                                            "question": "Why does the deque approach work in O(n) time? "
                                        },
                                        {
                                            "answer": "Indices help track validity of elements. Since the window moves right, older indices outside the window must be removed, which is easier with indices.",
                                            "question": "Why do we store indices instead of values in the deque? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of maintaining a monotonic decreasing deque, maintain a monotonic increasing deque, ensuring the front always holds the minimum.",
                                            "question": "How would you modify the solution to find the minimum sliding window instead of the maximum? "
                                        },
                                        {
                                            "answer": "If the step size is m, process only every mth element, ensuring validity of deque indices while skipping unnecessary updates.",
                                            "question": "What if the sliding window moves by more than one step instead of 1? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_trappingrainwater",
                                "problem_name": "Trapping Rainwater",
                                "problem_slug": "trapping-rainwater",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "HCL Technologies",
                                        "Activision Blizzard",
                                        "Flipkart",
                                        "AMD",
                                        "JPMorgan Chase",
                                        "Twilio",
                                        "OYO Rooms",
                                        "Cloudflare",
                                        "Salesforce",
                                        "Qualcomm",
                                        "HashiCorp",
                                        "Snowflake",
                                        "Epic Games",
                                        "Target",
                                        "Bloomberg",
                                        "Shopify",
                                        "Nutanix",
                                        "NVIDIA",
                                        "Roche",
                                        "DoorDash",
                                        "Seagate Technology",
                                        "Rakuten",
                                        "Riot Games",
                                        "ARM",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, also known as the 'Trapping Rain Water' problem, is a prominent example of issues faced in space optimization. This kind of computational approach can be seen in real world applications like cache memory optimization in software applications, or file storage in hard disks where efficient use of space is required. Data scientists may also use the concept in analytics software, determining how best to utilize limited memory resources. Another practical use is in the gaming industry where such algorithms help in creating realistic water surface phenomena.",
                                    "hints": [
                                        {
                                            "hint": "Compute left_max[i]  Maximum height from the left up to index i. Compute right_max[i]  Maximum height from the right up to index i. Water trapped at index i is: max(0, min({left_max}[i], {right_max}[i]) - {height}[i])"
                                        },
                                        {
                                            "hint": "Use two pointers (left and right), tracking left_max and right_max. Always process the shorter side first, as it is the limiting factor for trapping water."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Water can only accumulate up to the shortest boundary. If one side is lower, water will overflow, so the shorter height limits trapping.",
                                            "question": "Why do we take the min(left_max, right_max) for water calculation? "
                                        },
                                        {
                                            "answer": "If strictly increasing, no water is trapped ([1,2,3,4]  0 water). If strictly decreasing, also no water is trapped ([4,3,2,1]  0 water). Water is only trapped in a valley shape.",
                                            "question": "What happens when height is strictly increasing or decreasing? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of just summing trapped water, store (index, water_amount) where water > 0.",
                                            "question": "How would you modify the solution to return the indices where water is trapped? "
                                        },
                                        {
                                            "answer": "Convert them to absolute depths before applying the same logic.",
                                            "question": "What if some height[i] values were negative (representing below sea level)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_largestrectangleinahistogram",
                                "problem_name": "Largest rectangle in a histogram",
                                "problem_slug": "largest-rectangle-in-a-histogram",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "OYO Rooms",
                                        "Cloudflare",
                                        "Texas Instruments",
                                        "Freshworks",
                                        "Rockstar Games",
                                        "Philips Healthcare",
                                        "Epic Systems",
                                        "Swiggy",
                                        "Byju's",
                                        "NVIDIA",
                                        "Mastercard",
                                        "Zomato",
                                        "Intel",
                                        "Shopify",
                                        "Western Digital",
                                        "HashiCorp",
                                        "McKinsey & Company",
                                        "Teladoc Health",
                                        "Rakuten",
                                        "IBM",
                                        "Optum",
                                        "Ernst & Young",
                                        "Salesforce",
                                        "PwC",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem and its underlying concept are integral to numerous real-world applications including image processing, where you might need to find the largest rectangle in a histogram to optimize cropping strategies. Additionally, such problems are used in statistical data analysis, allowing developers to identify the most significant data ranges in large datasets. Furthermore, it is also an underlying concept for allocation of screen space in some User Interface (UI) design algorithms for maintaining proper layout and to provide better visual aesthetics.",
                                    "hints": [
                                        {
                                            "hint": "Using Monotonic Stack, Use a monotonic increasing stack to efficiently find the next smaller element on the left and right for each bar. Compute width using nearest smaller elements and calculate the max area."
                                        },
                                        {
                                            "hint": "Using Divide and Conquer Find the smallest bar, use it as a partition, and recursively compute the max rectangle in left and right segments."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The width of the rectangle for a bar extends from the nearest smaller bar on the left to the nearest smaller bar on the right. Any bar taller than the current bar does not limit its width.",
                                            "question": "Why do we need the next smaller elements for computing width? "
                                        },
                                        {
                                            "answer": "The largest rectangle is the entire histogram (width = n, height = first bar).",
                                            "question": "What if all bars have the same height? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Convert each row into a histogram and apply this algorithm row-wise.",
                                            "question": "How would you extend this to a 2D matrix (maximal rectangle in a binary matrix)? "
                                        },
                                        {
                                            "answer": "Yes, maintain two max areas and track valid segments dynamically.",
                                            "question": "Can we find the second-largest rectangle efficiently? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_maximumrectangles",
                                "problem_name": "Maximum Rectangles",
                                "problem_slug": "maximum-rectangles",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "PwC",
                                        "Splunk",
                                        "KPMG",
                                        "OYO Rooms",
                                        "Byju's",
                                        "Dropbox",
                                        "Airbnb",
                                        "Databricks",
                                        "Epic Games",
                                        "Activision Blizzard",
                                        "NVIDIA",
                                        "Bain & Company",
                                        "GE Healthcare",
                                        "Etsy",
                                        "Reddit",
                                        "Ernst & Young",
                                        "Riot Games",
                                        "Chewy",
                                        "Roche",
                                        "IBM",
                                        "Electronic Arts",
                                        "Robinhood",
                                        "Uber",
                                        "Texas Instruments",
                                        "Walmart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is at the core of image processing tasks in fields such as computer vision and graphics. For instance, in object detection (like detecting faces in a social media photo tagging system), such algorithms can be used to locate the largest rectangular region containing the object of interest. Also, in digital print and scanning applications, the largest rectangle of 1's can be used to identify and remove noise or to center the focus on the desired object, improving image quality.",
                                    "hints": [
                                        {
                                            "hint": "Convert each row into a histogram For each row i, compute a heights array, where: heights[j]=heights[j]+1ifmatrix[i][j]=1,else0 This transforms each row into a histogram where heights represent consecutive 1s."
                                        },
                                        {
                                            "hint": "Apply the Largest Rectangle in Histogram algorithm.  Use monotonic stack to compute maximum rectangular area row-wise. Track the maximum area across all rows."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A continuous vertical sequence of 1s can be seen as a bar in a histogram, allowing us to use histogram techniques.",
                                            "question": "Why do we transform rows into histograms? "
                                        },
                                        {
                                            "answer": "Each row contributes to the cumulative heights, which define possible rectangles.",
                                            "question": " Why do we need to compute heights row-wise? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a rolling heights array and compute the max rectangle as new rows arrive.",
                                            "question": "How would this be implemented in a streaming environment where rows arrive in real-time? "
                                        },
                                        {
                                            "answer": "Yes, by modifying in-place using two auxiliary arrays instead of recomputing heights.",
                                            "question": "Can we optimize space complexity further? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_stockspanproblem",
                                "problem_name": "Stock span problem",
                                "problem_slug": "stock-span-problem",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Riot Games",
                                        "Square",
                                        "Reddit",
                                        "Target",
                                        "Databricks",
                                        "Instacart",
                                        "Walmart",
                                        "Epic Systems",
                                        "Electronic Arts",
                                        "Red Hat",
                                        "Rakuten",
                                        "Salesforce",
                                        "Zynga",
                                        "Goldman Sachs",
                                        "Western Digital",
                                        "Roche",
                                        "Rockstar Games",
                                        "Deloitte",
                                        "Chewy",
                                        "eBay",
                                        "Texas Instruments",
                                        "Dropbox",
                                        "Lyft",
                                        "Boston Consulting Group",
                                        "Medtronic",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, also known as the Stock Span Problem, is a fundamental concept often used in financial technologies, such as in trading algorithms. It computes how far back the price of a stock has been less than the current price, which can aid decision-making in stock trading. Thus, it's an essential part of the technology that powers applications and platforms for stock markets worldwide. On a conceptual level, it's closely related to the idea of a sliding window in which we monitor a specific parameter over a certain time - a technique broadly used in data streaming processing and time series analysis within the software industry.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would iterate over all previous days for each i and check how many consecutive days satisfy the condition, leading to O(n) complexity, which is inefficient for large n."
                                        },
                                        {
                                            "hint": "Use a Monotonic Decreasing Stack to efficiently find the previous smaller element. Maintain a stack of indices where prices are in decreasing order. For each day i, pop elements from the stack until a smaller price is found, and calculate the span as: S i =iprevioussmallerindex Push the current index onto the stack."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Storing indices allows us to directly compute the span as the difference between indices.",
                                            "question": "Why do we store indices instead of prices in the stack? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Both use monotonic stacks but in opposite order (NGE finds the next larger element, while this finds the previous smaller element).",
                                            "question": "How does this problem relate to Next Greater Element (NGE) problems? "
                                        },
                                        {
                                            "answer": "Both use monotonic stacks but in opposite order (NGE finds the next larger element, while this finds the previous smaller element).",
                                            "question": "How does this problem relate to Next Greater Element (NGE) problems? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_celebrityproblem",
                                "problem_name": "Celebrity Problem",
                                "problem_slug": "celebrity-problem",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "Nutanix",
                                        "Deloitte",
                                        "Stripe",
                                        "Johnson & Johnson",
                                        "Airbnb",
                                        "HashiCorp",
                                        "Visa",
                                        "Zoho",
                                        "Cerner",
                                        "Ubisoft",
                                        "Swiggy",
                                        "Red Hat",
                                        "Square",
                                        "Activision Blizzard",
                                        "IBM",
                                        "Chewy",
                                        "Twilio",
                                        "Dropbox",
                                        "ARM",
                                        "DoorDash",
                                        "JPMorgan Chase",
                                        "KPMG",
                                        "Databricks",
                                        "MongoDB",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concept of this \"Celebrity Problem\" is often used in the field of social network analysis and graph theory, particularly in recommendation systems used by popular social media platforms. For instance, they use a similar logic to identify influential users or \"celebrities\" in the network whose posts are widely circulated or who have a large audience. This aids in effectively target advertising, spread messages, or propagate information effectively.",
                                    "hints": [
                                        {
                                            "hint": "Start with two pointers, left = 0 and right = N-1. Compare M[left][right]: If M[left][right] = 1  left knows right, so left cannot be a celebrity  move left forward. Else  right cannot be a celebrity  move right backward. At the end of this step, we have one candidate."
                                        },
                                        {
                                            "hint": "Check if the candidate satisfies both conditions: Row Check: M[candidate][j] should be 0 for all j  candidate. (Candidate knows no one). Column Check: M[i][candidate] should be 1 for all i  candidate. (Everyone knows the candidate)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Row Check: Ensures the candidate does not know anyone. Column Check: Ensures everyone knows the candidate. Both conditions must be met for a valid celebrity.",
                                            "question": "Why do we check both rows and columns separately in validation? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Represent it as a directed graph, where an edge i  j means i knows j. A celebrity is a node with N-1 incoming edges and 0 outgoing edges.",
                                            "question": "Can this problem be solved using a graph representation? "
                                        },
                                        {
                                            "answer": "Modify the approach to rank individuals based on the count of 1s in their column.",
                                            "question": "What if we want to find the top K most famous people instead of just one celebrity? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_lrucache",
                                "problem_name": "LRU Cache",
                                "problem_slug": "lru-cache",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Activision Blizzard",
                                        "Bungie",
                                        "PwC",
                                        "Oracle",
                                        "Stripe",
                                        "Twilio",
                                        "Broadcom",
                                        "HCL Technologies",
                                        "Zoho",
                                        "Riot Games",
                                        "Red Hat",
                                        "Airbnb",
                                        "Deloitte",
                                        "Texas Instruments",
                                        "Freshworks",
                                        "Chewy",
                                        "Rakuten",
                                        "HashiCorp",
                                        "Epic Games",
                                        "Wayfair",
                                        "Seagate Technology",
                                        "Unity Technologies",
                                        "PayPal",
                                        "Lyft",
                                        "IBM",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of a Least Recently Used (LRU) cache is widely used in operating systems, databases, and software applications. For instance, in a web browser, it's used to cache web pages. It holds the most recently accessed pages for a quick revisit, discarding the least recently viewed pages when the cache limit is exceeded. The LRU cache data structure, as highlighted in this problem, allows the system to maintain and manage such resources efficiently in O(1) time, improving the overall performance of the software application or system.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would involve a list or an array, but searching for a key or maintaining usage order requires O(n) complexity."
                                        },
                                        {
                                            "hint": "HashMap (key -> Node) for O(1) lookups. Doubly Linked List to track the most recently used (MRU) and least recently used (LRU) elements. head (MRU)  most recently accessed item. tail (LRU)  least recently used item (to be removed when the cache exceeds capacity)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Efficient Deletion: In a singly linked list, removing an item from the middle or tail takes O(n) since theres no previous pointer. Efficient Insertion: A doubly linked list allows O(1) insertion and removal from both head and tail.",
                                            "question": "Why do we need a doubly linked list instead of a normal linked list? "
                                        },
                                        {
                                            "answer": "This ensures that recently accessed items remain in the cache, and oldest (LRU) items get removed when capacity exceeds.",
                                            "question": " Why do we move the accessed node to the front (MRU position)? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of removing the tail (LRU), remove the head (MRU) when the cache exceeds capacity.",
                                            "question": "How would this implementation change if we needed a Most Recently Used (MRU) cache? "
                                        },
                                        {
                                            "answer": "A heap-based approach takes O(log n) for updates, whereas the HashMap + Linked List approach is O(1).",
                                            "question": " How does this compare to a priority queue (heap) for LRU eviction? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_faqs_lfucache",
                                "problem_name": "LFU Cache",
                                "problem_slug": "lfu-cache",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Dropbox",
                                        "Roblox",
                                        "Twilio",
                                        "Western Digital",
                                        "Deloitte",
                                        "Instacart",
                                        "Shopify",
                                        "Bain & Company",
                                        "HashiCorp",
                                        "Docker",
                                        "Seagate Technology",
                                        "Siemens Healthineers",
                                        "American Express",
                                        "Riot Games",
                                        "Flipkart",
                                        "Target",
                                        "Databricks",
                                        "Zoho",
                                        "Uber",
                                        "PayPal",
                                        "IBM",
                                        "Airbnb",
                                        "Philips Healthcare",
                                        "Splunk",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of a Least Frequently Used (LFU) cache, as represented in this problem, is routinely used in database systems, web browser caching, and operating systems for page replacement. The idea is to keep the most frequently accessed items in memory for faster retrieval. For instance, web browsers like Chrome or Firefox use LFU to cache web pages. When the cache is full, the least frequently viewed web pages are evicted to make room for new ones. This makes returning to frequently visited sites much faster.",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would iterate over all keys to find the least frequently used key, leading to O(n) time complexity, which is inefficient."
                                        },
                                        {
                                            "hint": "Key-Value HashMap (cache)  Stores {key: (value, frequency)}. Frequency-List HashMap (freq_map)  Stores {frequency: OrderedDict(keys)}. Maintains order of access (LRU behavior) within the same frequency. A variable min_freq  Tracks the smallest frequency in freq_map (to identify LFU keys in O(1))."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "freq_map helps us group elements by frequency. This allows us to quickly remove the LFU key (smallest frequency) in O(1) time, instead of scanning all keys (O(n)) in brute-force solutions.",
                                            "question": "Why do we need freq_map instead of just tracking frequency inside cache? "
                                        },
                                        {
                                            "answer": "LRU evicts least recently used keys, while LFU evicts the least frequently used. LFU is better for long-term popularity tracking (e.g., caching web pages with persistent access patterns).",
                                            "question": " How does this compare to LRU Cache? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A min-heap can track (frequency, time, key), but deleting from the middle is O(log n) instead of O(1).",
                                            "question": "Can we implement LFU using a priority queue instead of freq_map? "
                                        },
                                        {
                                            "answer": "Yes, by adding a function to resize capacity, where we evict items until the new capacity is met.",
                                            "question": " Can we modify LFU to handle dynamically changing capacities? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "stack/queues_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 4,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "stack/queues_stack/queues_contest_countcollisons",
                                "problem_name": "Count Collisons",
                                "problem_slug": "count-collisons",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_contest_lexicographicallysmalleststring",
                                "problem_name": "Lexicographically Smallest String",
                                "problem_slug": "lexicographically-smallest-string",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "stack/queues_stack/queues_contest_maximumvalueofasubarray",
                                "problem_name": "Maximum Value Of A Subarray",
                                "problem_slug": "maximum-value-of-a-subarray",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "binarytrees",
                "category_name": "Binary Trees",
                "category_slug": "binary-trees",
                "category_rank": 11,
                "subcategories": [
                    {
                        "subcategory_id": "binarytrees_theory/traversals",
                        "subcategory_name": "Theory/Traversals",
                        "subcategory_slug": "theory-and-traversals",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_introduction",
                                "problem_name": "Introduction",
                                "problem_slug": "introduction-",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [
                                        "Bloomberg",
                                        "HCL Technologies",
                                        "Micron Technology",
                                        "Roche",
                                        "AMD",
                                        "Teladoc Health",
                                        "Red Hat",
                                        "Siemens Healthineers",
                                        "PwC",
                                        "Reddit",
                                        "Swiggy",
                                        "Airbnb",
                                        "Instacart",
                                        "Stripe",
                                        "Optum",
                                        "Byju's",
                                        "Zynga",
                                        "Johnson & Johnson",
                                        "Dropbox",
                                        "DoorDash",
                                        "Roblox",
                                        "Cloudflare",
                                        "Intel",
                                        "Activision Blizzard",
                                        "eBay"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_inordertraversal",
                                "problem_name": "Inorder Traversal",
                                "problem_slug": "inorder-traversal",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Broadcom",
                                        "ARM",
                                        "Seagate Technology",
                                        "Rockstar Games",
                                        "Freshworks",
                                        "Johnson & Johnson",
                                        "PayPal",
                                        "HashiCorp",
                                        "Medtronic",
                                        "Goldman Sachs",
                                        "Epic Games",
                                        "Flipkart",
                                        "Wayfair",
                                        "Snowflake",
                                        "Intel",
                                        "AMD",
                                        "Morgan Stanley",
                                        "Uber",
                                        "Airbnb",
                                        "Target",
                                        "Swiggy",
                                        "MongoDB",
                                        "Boston Consulting Group",
                                        "Reddit",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The Inorder traversal of a binary tree is commonly used in software development to process and manage hierarchical data structures, such as the Document Object Model (DOM) in web development. The DOM represents a web page so programs can change the document structure, style, and content. By using Inorder traversal, developers can efficiently access and manipulate elements on the webpage in the exact order they appear in the HTML markup, allowing for specific and efficient modifications to web content.",
                                    "hints": [
                                        {
                                            "hint": "Since inorder traversal first visits the left subtree, we use a stack to store nodes while traversing left."
                                        },
                                        {
                                            "hint": "Push nodes onto the stack while moving left, process them, then move to their right child."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Inorder is strictly defined for binary trees, but for an n-ary tree, a variation would be to process children in order around the root.",
                                            "question": "Can this traversal be modified for an n-ary tree? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Since an inorder traversal of a BST results in a sorted order, the tree can be reconstructed using its sorted array representation.",
                                            "question": "How would you use inorder traversal to reconstruct a BST? "
                                        },
                                        {
                                            "answer": "Modify the order by adjusting recursion or stack logic to change precedence of left, root, or right processing.",
                                            "question": "How would you traverse the tree in a depth-first manner but modify the order? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_preordertraversal",
                                "problem_name": "Preorder Traversal",
                                "problem_slug": "preorder-traversal",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Deloitte",
                                        "Ernst & Young",
                                        "Micron Technology",
                                        "JPMorgan Chase",
                                        "Bloomberg",
                                        "Western Digital",
                                        "Ubisoft",
                                        "Roblox",
                                        "HCL Technologies",
                                        "Square",
                                        "ARM",
                                        "Medtronic",
                                        "Uber",
                                        "Target",
                                        "Boston Consulting Group",
                                        "Swiggy",
                                        "Shopify",
                                        "Chewy",
                                        "Wayfair",
                                        "Broadcom",
                                        "Mastercard",
                                        "Nutanix",
                                        "Rockstar Games",
                                        "Salesforce",
                                        "Epic Systems",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: Preorder traversal of a binary tree is a classic algorithm often used in practical software development. For instance, in areas involving hierarchical datasets, such as the DOM (Document Object Model) in web development. In this context, each HTML/XML tag can be seen as a node in a tree with a hierarchical structure. Preorder traversal is then used to traverse the entire DOM in an orderly manner, allowing developers to effectively manipulate, add, or remove elements.",
                                    "hints": [
                                        {
                                            "hint": "A stack can be used to simulate recursion by manually maintaining the order of traversal. Since the traversal visits the root first, push the root onto the stack, process it, then push its right child before left (so the left is processed first)."
                                        },
                                        {
                                            "hint": "If the tree is empty (root is None), return an empty list. If the tree is unbalanced, the traversal should still correctly process all nodes."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Preorder is commonly used for creating copies of trees, serializing structures, and constructing expressions in syntax trees.",
                                            "question": "Why is preorder traversal useful? "
                                        },
                                        {
                                            "answer": "The stack ensures that the left subtree is processed first by pushing the right child before the left child.",
                                            "question": "How does an iterative approach maintain the traversal order? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of just left and right, iterate over all children in the correct order using a stack or recursion.",
                                            "question": "How would you modify this traversal for an n-ary tree? "
                                        },
                                        {
                                            "answer": "Preorder itself is a DFS traversal, but can be modified for inorder and postorder as well.",
                                            "question": "How would you traverse the tree in a depth-first search (DFS) manner? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_postordertraversal",
                                "problem_name": "Postorder Traversal",
                                "problem_slug": "postorder-traversal",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Twilio",
                                        "Johnson & Johnson",
                                        "McKinsey & Company",
                                        "Zoho",
                                        "Micron Technology",
                                        "PwC",
                                        "Shopify",
                                        "Zynga",
                                        "Riot Games",
                                        "Bain & Company",
                                        "Flipkart",
                                        "Square",
                                        "Reddit",
                                        "Walmart",
                                        "Intel",
                                        "Lyft",
                                        "Etsy",
                                        "Cloudflare",
                                        "DoorDash",
                                        "Freshworks",
                                        "Goldman Sachs",
                                        "Philips Healthcare",
                                        "KPMG",
                                        "MongoDB",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Binary tree traversal, including Postorder traversal, is a fundamental concept extensively used in practical software development. For example, it's used in certain database operations (like DBMS), graphic algorithms (in game development), and hierarchical file systems (like in operating systems and file explorer applications) to visit data in a structured and orderly manner. Postorder traversal can specifically be useful in certain mathematical calculations like expression tree evaluations, where the operation resides in the parent node and the operands are in the child nodes. The postorder traversal ensures that the operands are evaluated before the operation is applied.",
                                    "hints": [
                                        {
                                            "hint": "A stack can be used to simulate recursion manually. Since postorder requires processing root last, push elements in a modified preorder order. Root  Right  Left (instead of Root  Left  Right)."
                                        },
                                        {
                                            "hint": "Use one stack and a prev pointer to track whether traversal is moving up from left or right."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Postorder traversal is useful for deleting trees, evaluating mathematical expressions, and constructing dependency graphs (e.g., compilation order).",
                                            "question": "Why is postorder traversal useful? "
                                        },
                                        {
                                            "answer": "Left-skewed tree: The order follows a bottom-up sequence from left to root. Right-skewed tree: The order follows a right-to-left sequence, with the root last.",
                                            "question": "How does postorder traversal behave for a skewed tree? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Postorder follows depth-first search (DFS), so for level-order traversal, a queue-based approach (BFS) is required instead.",
                                            "question": "How would you modify the traversal to return nodes level by level? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_levelordertraversal",
                                "problem_name": "Level Order Traversal",
                                "problem_slug": "level-order-traversal",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Walmart",
                                        "Morgan Stanley",
                                        "Freshworks",
                                        "Texas Instruments",
                                        "Bloomberg",
                                        "Deloitte",
                                        "Square",
                                        "Chewy",
                                        "Zoho",
                                        "Electronic Arts",
                                        "KPMG",
                                        "Bungie",
                                        "Unity Technologies",
                                        "Etsy",
                                        "Optum",
                                        "Wayfair",
                                        "Nutanix",
                                        "Pinterest",
                                        "Western Digital",
                                        "MongoDB",
                                        "Roche",
                                        "Roblox",
                                        "Teladoc Health",
                                        "Mastercard",
                                        "Salesforce",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The problem of level order traversal is used extensively in real-world applications. For example, in networking, when you want to send a message to all systems in a network, you can model the network as a binary tree and use level order traversal to reach each system effectively. Additionally, in file systems, this method can help to retrieve files in a hierarchical structure. The implementation of garbage collection in Java also uses this concept of level order traversal, which is crucial in memory management in the software industry.",
                                    "hints": [
                                        {
                                            "hint": "A queue (FIFO) is the best way to handle level order traversal since we process nodes level by level."
                                        },
                                        {
                                            "hint": "Push the root node into the queue. While the queue is not empty, process all nodes at the current level, then enqueue their left and right children for the next level."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BFS ensures that all nodes at a given depth are processed before deeper nodes, making it ideal for level-wise processing. DFS (e.g., Preorder) follows root  left  right, which does not preserve level-wise ordering.",
                                            "question": "Why use BFS instead of DFS for level order traversal? "
                                        },
                                        {
                                            "answer": "Track the number of nodes in the current level before starting a new level, ensuring each level is processed separately.",
                                            "question": "How do we separate elements by levels? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of storing all values in a single list, use a nested list, where each sublist contains values from one level.",
                                            "question": "How would you modify this traversal to return a list of lists, where each sublist contains nodes at a particular level?  "
                                        },
                                        {
                                            "answer": "Use a deque (double-ended queue) and alternate between left-to-right and right-to-left processing at each level.",
                                            "question": "How can you modify the traversal to print a zigzag (spiral) order? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_theory/traversals_pre,post,inorderinonetraversal",
                                "problem_name": "Pre, Post, Inorder in one traversal",
                                "problem_slug": "pre,-post,-inorder-in-one-traversal",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Optum",
                                        "Philips Healthcare",
                                        "Activision Blizzard",
                                        "Micron Technology",
                                        "Riot Games",
                                        "Cerner",
                                        "Broadcom",
                                        "Square",
                                        "Nutanix",
                                        "Siemens Healthineers",
                                        "Docker",
                                        "KPMG",
                                        "HashiCorp",
                                        "Red Hat",
                                        "Robinhood",
                                        "McKinsey & Company",
                                        "Zoho",
                                        "Qualcomm",
                                        "Freshworks",
                                        "Byju's",
                                        "Texas Instruments",
                                        "Unity Technologies",
                                        "Epic Systems",
                                        "Dropbox",
                                        "Visa",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "In-order, pre-order and post-order are tree traversal methods that have real-life applications in the software industry. For instance, in database systems, these traversal algorithms are often used to parse expression trees. This is particularly important in optimizing queries or categorizing data. Similarly, compilers make use of these algorithms for syntax checking, creating symbol tables, or generating machine code. Fun fact, file system scans in operating systems are also modeled as a pre-order traversal of a tree!",
                                    "hints": [
                                        {
                                            "hint": "For Preorder traversal, a stack is used to process nodes before pushing their children. Inorder traversal requires a stack to track nodes while traversing left, processing the root, and then moving right. Postorder traversal is trickier because the root must be visited last, which can be handled using two stacks or by modifying Preorder traversal."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Postorder traversal is used in applications such as deleting a tree, evaluating expressions, and dependency resolution. It processes children before their parent, making it useful for tasks requiring bottom-up computation.",
                                            "question": "How does Postorder traversal differ in its usage compared to Inorder and Preorder? "
                                        },
                                        {
                                            "answer": "While Inorder, Preorder, and Postorder are defined for binary trees, variations exist for n-ary trees. Preorder and Postorder generalize well, but Inorder requires redefining traversal order.",
                                            "question": "Can traversal be applied to non-binary trees (n-ary trees)? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Using Morris Traversal, Inorder and Preorder traversals can be performed in O(1) space by modifying tree pointers temporarily. Postorder traversal is more complex and requires additional modifications or iterative tricks.",
                                            "question": "How would you perform all three traversals using constant space? "
                                        },
                                        {
                                            "answer": "Maintaining a depth counter while traversing (either recursively or iteratively) allows returning node values along with their depths. A queue-based level-order traversal can also help in structured depth tracking.",
                                            "question": "What modifications are needed if we also want to track node depths? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarytrees_mediumproblems",
                        "subcategory_name": "Medium Problems",
                        "subcategory_slug": "medium-problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_maximumdepthinbt",
                                "problem_name": "Maximum Depth in BT",
                                "problem_slug": "maximum-depth-in-bt",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Zoho",
                                        "Mastercard",
                                        "Wayfair",
                                        "Freshworks",
                                        "Electronic Arts",
                                        "Qualcomm",
                                        "Target",
                                        "Bungie",
                                        "Bain & Company",
                                        "Zynga",
                                        "Nutanix",
                                        "Broadcom",
                                        "GE Healthcare",
                                        "Teladoc Health",
                                        "Cerner",
                                        "Etsy",
                                        "HCL Technologies",
                                        "Red Hat",
                                        "NVIDIA",
                                        "Flipkart",
                                        "DoorDash",
                                        "OYO Rooms",
                                        "McKinsey & Company",
                                        "ARM",
                                        "Stripe",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The \"maximum depth of binary tree\" problem commonly occurs in real-world scenarios such as managing organisational hierarchies, implementing game trees in artificial intelligence, and structuring file systems in operating systems. For instance, it helps in determining the length of the longest inheritance chain in an object-oriented system or the maximum call stack depth in a recursive function. Understanding and implementing it efficiently is essential in ensuring speedy traversals, retrievals, and manipulation of such tree-based data structures.",
                                    "hints": [
                                        {
                                            "hint": "Since the depth of a node is determined by its deepest child, we can use a divide-and-conquer approach: the depth of a node is 1 + max(depth of left subtree, depth of right subtree). This naturally fits a recursive Depth-First Search (DFS) strategy."
                                        },
                                        {
                                            "hint": "An iterative approach can be used with Breadth-First Search (BFS). By using a queue, we traverse each level of the tree, counting the number of levels until we reach the last node. BFS is particularly useful for large trees since it avoids deep recursion stack issues."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The depth of a tree is determined by the longest path, not the total number of nodes. If we sum both depths, we would be counting paths from both sides simultaneously, which is incorrect.",
                                            "question": "Why do we take the maximum of the left and right subtree depths instead of summing them? "
                                        },
                                        {
                                            "answer": "BFS processes nodes level by level, so counting the levels naturally gives the maximum depth. The last processed level is the deepest level of the tree.",
                                            "question": " How does BFS help in calculating maximum depth iteratively? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of taking max(left, right), we take min(left, right). However, care must be taken: if a node has only one child, we must not consider the missing childs depth as 0. Instead, the depth should be computed from the existing child.",
                                            "question": "How would you modify this approach to find the minimum depth of a binary tree? "
                                        },
                                        {
                                            "answer": " What if the input is given as an array (heap representation)?\nFor a binary heap stored in an array, the depth can be computed as floor(log2(n)) + 1, where n is the number of elements.",
                                            "question": " What if the input is given as an array (heap representation)? x"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_checkiftwotreesareidenticalornot",
                                "problem_name": "Check if two trees are identical or not",
                                "problem_slug": "check-if-two-trees-are-identical-or-not",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Teladoc Health",
                                        "Deloitte",
                                        "Wayfair",
                                        "Siemens Healthineers",
                                        "Broadcom",
                                        "Optum",
                                        "PayPal",
                                        "Chewy",
                                        "Rakuten",
                                        "McKinsey & Company",
                                        "Activision Blizzard",
                                        "Rockstar Games",
                                        "Snowflake",
                                        "Western Digital",
                                        "AMD",
                                        "Swiggy",
                                        "Epic Games",
                                        "Etsy",
                                        "Target",
                                        "Electronic Arts",
                                        "DoorDash",
                                        "NVIDIA",
                                        "Boston Consulting Group",
                                        "Robinhood",
                                        "Riot Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The given problem is fundamentally used in various applications such as code compilers and database systems where we need to compare two Abstract Syntax Trees (ASTs). It's also used in code similarity checkers and plagiarism detection software where they need to analyze if two codes perform the same operations. In Data Science and ML applications, this concept is helpful in measuring the similarities between decision trees.",
                                    "hints": [
                                        {
                                            "hint": "An iterative DFS approach can be implemented using a stack to simulate recursion. Each time we pop a node pair (p, q), we compare their values and push their left and right children back onto the stack for further comparison."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Preorder traversal alone does not uniquely define a tree. Different trees can have the same preorder output but different structures. Instead, we must check each corresponding node recursively or iteratively.",
                                            "question": "Why cant we just compare Preorder traversals of both trees? "
                                        },
                                        {
                                            "answer": "Even if the upper levels match, any difference in the lower levels will make them different trees. A depth mismatch in left or right subtrees will cause a false result.",
                                            "question": "What if the trees have different heights but share some structure at the top? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of checking if both trees are identical, we need to check if one tree is contained within another. This requires a function to compare trees at each node and recursively check if q is a subtree of p.",
                                            "question": "How would you modify this problem to check if one tree is a subtree of another? "
                                        },
                                        {
                                            "answer": "A tree can be serialized into a string using Preorder traversal with null markers. Comparing two such serialized trees allows checking for identity without explicitly traversing the structure.",
                                            "question": "How does this problem relate to tree serialization? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_checkforbalancedbinarytrees",
                                "problem_name": "Check for balanced binary tree",
                                "problem_slug": "check-for-balanced-binary-tree",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Lyft",
                                        "Epic Games",
                                        "Roblox",
                                        "Freshworks",
                                        "Cerner",
                                        "Zynga",
                                        "DoorDash",
                                        "Flipkart",
                                        "Riot Games",
                                        "eBay",
                                        "Optum",
                                        "Morgan Stanley",
                                        "Electronic Arts",
                                        "IBM",
                                        "Dropbox",
                                        "Airbnb",
                                        "Siemens Healthineers",
                                        "Square",
                                        "HCL Technologies",
                                        "PayPal",
                                        "Twilio",
                                        "Zoho",
                                        "Teladoc Health",
                                        "Stripe",
                                        "Docker",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of checking if a binary tree is height-balanced is crucial in the development of databases and file systems, where balanced-tree data structures like AVL trees and Red-Black trees are used. An AVL tree, for instance, is a self-balancing binary search tree, and the heights of the two child subtrees of any node differ by at most one. This ensures that lookups, insertions, and deletions are all fast, optimizing overall system performance.",
                                    "hints": [
                                        {
                                            "hint": "We return the height of a subtree only if it is balanced. If at any point the height difference exceeds 1, we return an invalid flag (e.g., -1), allowing us to terminate early."
                                        },
                                        {
                                            "hint": "An iterative solution using level-order traversal (BFS) is possible, but it requires extra storage for tracking subtree heights, making it less efficient than the recursive approach."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The naive method calculates the height of each subtree separately, leading to redundant computations. This results in O(n) complexity, which is too slow for large trees. The optimized bottom-up approach computes height while checking balance, reducing time complexity to O(n).",
                                            "question": "Why is the naive recursive approach inefficient? "
                                        },
                                        {
                                            "answer": "No, a height-balanced tree ensures that height differences are small, but it doesnt guarantee the minimum height. The most balanced form would be a complete binary tree, but other balanced trees can have varying structures.",
                                            "question": "Does a height-balanced tree always have minimum height? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A complete binary tree has all levels fully filled except possibly the last, which must be filled left to right. This can be checked using level-order traversal (BFS) and verifying that no node appears after a null node.",
                                            "question": "How would you check if a tree is a complete binary tree? "
                                        },
                                        {
                                            "answer": "In a balanced BST (e.g., AVL or Red-Black Tree), search operations take O(log n) time, ensuring optimal efficiency. If a BST becomes unbalanced (skewed), search operations degrade to O(n), making balancing critical for performance.",
                                            "question": "How does tree balancing impact search efficiency in Binary Search Trees (BSTs)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_diameterofbinarytree",
                                "problem_name": "Diameter of Binary Tree",
                                "problem_slug": "diameter-of-binary-tree",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Intel",
                                        "Alibaba",
                                        "Swiggy",
                                        "Freshworks",
                                        "Electronic Arts",
                                        "Optum",
                                        "Reddit",
                                        "PayPal",
                                        "Stripe",
                                        "Visa",
                                        "Qualcomm",
                                        "Siemens Healthineers",
                                        "Robinhood",
                                        "Byju's",
                                        "Deloitte",
                                        "NVIDIA",
                                        "Wayfair",
                                        "Airbnb",
                                        "Rakuten",
                                        "Mastercard",
                                        "Snowflake",
                                        "OYO Rooms",
                                        "Splunk",
                                        "Bloomberg",
                                        "GE Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept underlying the Diameter of Binary Tree problem is used in practical software development, notably in the field of Network Routing Algorithms. These algorithms use the principles of tree traversal and diameter calculation to determine the most efficient path for data to travel between nodes in a network. Understanding the longest path or \"diameter\" helps engineers and developers optimize these paths and enhance the overall efficiency of the network.",
                                    "hints": [
                                        {
                                            "hint": "A naive approach computes the height separately for each node and calculates the possible diameter at each step, leading to an O(n) time complexity (height computation is O(n) at each of the O(n) nodes)."
                                        },
                                        {
                                            "hint": "An optimized approach computes height while finding the diameter, reducing the time complexity to O(n). This is done by modifying the recursive function to return both the height of the subtree and current max diameter at each step."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "An unbalanced tree does not affect the formula but increases the recursion depth. The longest path might entirely exist in the larger subtree, requiring additional checks to ensure it is correctly counted.",
                                            "question": "How does an unbalanced tree affect the diameter calculation? "
                                        },
                                        {
                                            "answer": "The height is the longest path from the root to a leaf (O(n) computation). The diameter considers paths between any two nodes, so a naive approach requires checking every node as a potential root, leading to O(n).",
                                            "question": "How does this differ from finding the height of a tree? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of just computing the length, store the nodes contributing to the maximum path during the traversal. Maintain an auxiliary list that tracks the longest left and right subtree paths at each node.",
                                            "question": "How would you modify this approach to return the actual path of the diameter? "
                                        },
                                        {
                                            "answer": "A recursive DFS solution requires O(h) space, where h is the tree height. This can be O(n) in skewed trees. An iterative approach can reduce stack overhead, but achieving O(1) space is not feasible without modifying the tree structure.",
                                            "question": "Can we determine the diameter in constant space? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_maximumpathsum",
                                "problem_name": "Maximum path sum",
                                "problem_slug": "maximum-path-sum-",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Alibaba",
                                        "Bain & Company",
                                        "Databricks",
                                        "Goldman Sachs",
                                        "Activision Blizzard",
                                        "Morgan Stanley",
                                        "Medtronic",
                                        "Dropbox",
                                        "ARM",
                                        "Seagate Technology",
                                        "Walmart",
                                        "Cloudflare",
                                        "Zoho",
                                        "Boston Consulting Group",
                                        "PwC",
                                        "Reddit",
                                        "Cerner",
                                        "HCL Technologies",
                                        "Western Digital",
                                        "Siemens Healthineers",
                                        "Snowflake",
                                        "Splunk",
                                        "Byju's",
                                        "Rakuten",
                                        "Roblox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept used in this problem is fundamental in the development of networking or routing protocols in the field of computer networks. Specifically, in routing tables, each path could be seen as a route and each node as a network point. The path sum could represent the total cost or delay of the route. By determining the path with the \"largest\" or \"smallest\" sum, network devices can decide the best path for data transmission. Similarly, file systems in Operating Systems use the same concept where they need to find the best path (with maximum or minimum resource usage) to store or retrieve data. It's an underlying concept also used in database indexing and many algorithms in artificial intelligence and machine learning.",
                                    "hints": [
                                        {
                                            "hint": "Compute the maximum path sum ending at the current node as the max of:max(leftsubtreesum,rightsubtreesum)+currentnodevalue. (This ensures we include only one child when extending the path upwards)."
                                        },
                                        {
                                            "hint": "Compute the maximum sum passing through the node by considering both children and the nodes value:leftsum+rightsum+nodevalue. Maintain a global maximum that tracks the highest encountered path sum."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If we return the computed sum from the recursive function, it will only return sums extending upward, missing cases where the maximum path is entirely inside a subtree. A global max tracker ensures we capture all cases.",
                                            "question": "Why do we maintain a global variable for the maximum sum? "
                                        },
                                        {
                                            "answer": "Level-order traversal processes nodes level by level, whereas we need subtree-based calculations. A bottom-up approach ensures correct computation at each node before considering parent nodes.",
                                            "question": "Why cant we solve this using level-order traversal? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In a balanced tree, paths distribute evenly, often leading to higher path sums compared to skewed trees, where most paths stay on one side. AVL trees ensure logarithmic height, preventing extreme cases where paths become too deep.",
                                            "question": "How does tree balancing affect the maximum path sum? "
                                        },
                                        {
                                            "answer": "If the tree structure were represented as a graph, a memoized DFS could optimize repeated calculations. However, since trees have a fixed structure, memoization is unnecessary in this case.",
                                            "question": "How does this problem relate to dynamic programming? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_mediumproblems_checkforsymmetricalbts",
                                "problem_name": "Check for symmetrical BTs",
                                "problem_slug": "check-for-symmetrical-bts",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Uber",
                                        "Optum",
                                        "Epic Systems",
                                        "Byju's",
                                        "Boston Consulting Group",
                                        "Micron Technology",
                                        "NVIDIA",
                                        "Western Digital",
                                        "Robinhood",
                                        "MongoDB",
                                        "IBM",
                                        "PwC",
                                        "PayPal",
                                        "Teladoc Health",
                                        "Oracle",
                                        "Flipkart",
                                        "Ubisoft",
                                        "Electronic Arts",
                                        "Dropbox",
                                        "eBay",
                                        "AMD",
                                        "DoorDash",
                                        "Epic Games",
                                        "Alibaba",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The concept of checking for symmetry in a binary tree, or verifying if a structure is a mirror image of itself, is applied in compilers or syntax checkers of Integrated Development Environments (IDEs). These tools often need to parse and analyze code syntax trees and confirm their correctness. Ensuring their symmetry can be a part of validating that code has been written in a balanced and structured way, thus optimizing the compiler's performance and improving code execution.",
                                    "hints": [
                                        {
                                            "hint": "A recursive approach naturally fits this problem. Check if both the left and right children exist. Ensure that their values are equal and recursively compare"
                                        },
                                        {
                                            "hint": "An iterative approach can be implemented using a queue (BFS) or stack (DFS) by processing nodes in pairs. Instead of recursion, push nodes into a queue in mirror order and check symmetry level by level."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A symmetric tree resembles a palindrome in tree form, where left and right halves mirror each other. Similar logic applies when checking symmetric strings or arrays.",
                                            "question": "How does this relate to palindrome structures? "
                                        },
                                        {
                                            "answer": "In an identical tree check, we compare corresponding nodes directly (left with left, right with right). In a mirror check, we compare left with right and right with left.",
                                            "question": "Why is a mirror check different from an identical tree check? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a bottom-up DFS approach, returning the largest symmetric subtree size while checking for symmetry at each node.",
                                            "question": "What changes would be needed to find the largest symmetric subtree? "
                                        },
                                        {
                                            "answer": "Morris traversal works for inorder traversal, but symmetry checking requires level-based traversal, which Morris traversal doesnt efficiently support.",
                                            "question": "Can this problem be solved using Morris traversal (O(1) space)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarytrees_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_zigzagorspiraltraversal",
                                "problem_name": "Zig Zag or Spiral Traversal",
                                "problem_slug": "zig-zag-or-spiral-traversal",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Bain & Company",
                                        "Zomato",
                                        "Shopify",
                                        "Siemens Healthineers",
                                        "Lyft",
                                        "KPMG",
                                        "Wayfair",
                                        "Snowflake",
                                        "Goldman Sachs",
                                        "Unity Technologies",
                                        "Electronic Arts",
                                        "Optum",
                                        "Splunk",
                                        "Chewy",
                                        "IBM",
                                        "Red Hat",
                                        "Swiggy",
                                        "Oracle",
                                        "Riot Games",
                                        "Mastercard",
                                        "Rakuten",
                                        "Square",
                                        "HCL Technologies",
                                        "Medtronic",
                                        "Zoho",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, known as Zigzag Level Order Traversal or Breadth First Search level order traversal in binary trees, is extensively used in artificial intelligence and machine learning. It is primarily leveraged in decision tree algorithms, used for building classification models. Furthermore, it is a crucial part of navigation systems, where decisions are made at each node until the destination node is reached. Understanding this pattern can greatly improve the search or recommendation algorithms in various sectors including e-commerce, social media and more.",
                                    "hints": [
                                        {
                                            "hint": "The Breadth-First Search (BFS) approach using a queue is optimal for level-order traversal."
                                        },
                                        {
                                            "hint": "An alternative DFS (preorder traversal) approach is possible but requires: Passing the current level index to determine the order dynamically. Storing values in a list of lists where odd levels are reversed before returning."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "DFS explores depth-first, which does not naturally follow level-order traversal. While DFS can track depth and store nodes per level, we need extra logic to reverse odd levels, making it less intuitive than BFS.",
                                            "question": " Why is DFS not the preferred approach for this problem? "
                                        },
                                        {
                                            "answer": "Yes, we can store all levels left to right, then reverse every alternate level before returning the result. However, this adds O(n) extra time complexity for reversing lists. A deque allows us to handle this efficiently during traversal.",
                                            "question": "Can we just reverse every alternate level after traversal? "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Spiral order traversal is similar but does not alternate direction at each level. Instead, nodes are processed in a strictly alternating spiral order (left to right  right to left  left to right).",
                                            "question": "How would you modify the approach to return a spiral level-order traversal instead? "
                                        },
                                        {
                                            "answer": "An iterative DFS would use a stack instead of a queue, keeping track of levels explicitly. However, maintaining zigzag order dynamically in DFS requires extra logic, making BFS more natural.",
                                            "question": "How would an iterative DFS implementation compare to BFS? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_boundarytraversal",
                                "problem_name": "Boundary Traversal",
                                "problem_slug": "boundary-traversal",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Visa",
                                        "Red Hat",
                                        "Unity Technologies",
                                        "Bloomberg",
                                        "Nutanix",
                                        "Byju's",
                                        "OYO Rooms",
                                        "Siemens Healthineers",
                                        "Lyft",
                                        "Zomato",
                                        "Western Digital",
                                        "JPMorgan Chase",
                                        "Texas Instruments",
                                        "Bungie",
                                        "Mastercard",
                                        "Morgan Stanley",
                                        "Reddit",
                                        "PayPal",
                                        "Dropbox",
                                        "Target",
                                        "Micron Technology",
                                        "IBM",
                                        "Goldman Sachs",
                                        "Airbnb",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "In the field of computer graphics and game development, tree traversal algorithms, similar to the concept in the boundary traversal of a binary tree, are used for space partitioning. Techniques like Binary Space Partitioning (BSP) trees help in determining what objects need to be rendered and are critical for optimizing performance. In simple terms, it can be said that your favorite video game performs well because similar tree traversal techniques help decide what elements to show on your screen at any point in time!",
                                    "hints": [
                                        {
                                            "hint": "Start from the left child of the root. Move down the left subtree, collecting the first node encountered at each level. Stop when a leaf node is reached (do not include leaves in this step). "
                                        },
                                        {
                                            "hint": "Start from the right child of the root. Move down the right subtree, collecting the first node encountered at each level. Do not include leaves. Store the values in reverse order before adding them to the final result."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Leaf nodes are already collected in a separate traversal step. If included in the left/right boundary steps, they would be duplicated.",
                                            "question": "Why exclude leaf nodes while collecting left and right boundaries?  "
                                        },
                                        {
                                            "answer": "Level-order traversal processes nodes row by row, while boundary traversal follows a specific anti-clockwise order, focusing on edge nodes.",
                                            "question": "How does this differ from level-order traversal?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of left boundary  leaves  right boundary (reverse order), the order would be root  right boundary  leaves  left boundary (reverse order).",
                                            "question": "How would you modify this if the traversal needed to be clockwise instead of anti-clockwise?  "
                                        },
                                        {
                                            "answer": "DFS explores all nodes before backtracking, whereas boundary traversal restricts traversal to only boundary nodes.",
                                            "question": "How does boundary traversal differ from a depth-first traversal (DFS)?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_verticalordertraversal",
                                "problem_name": "Vertical Order Traversal",
                                "problem_slug": "vertical-order-traversal",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "HashiCorp",
                                        "Zynga",
                                        "Alibaba",
                                        "Medtronic",
                                        "Walmart",
                                        "Deloitte",
                                        "NVIDIA",
                                        "Dropbox",
                                        "Uber",
                                        "Rockstar Games",
                                        "Epic Systems",
                                        "KPMG",
                                        "IBM",
                                        "Docker",
                                        "Optum",
                                        "McKinsey & Company",
                                        "Cloudflare",
                                        "AMD",
                                        "Wayfair",
                                        "Boston Consulting Group",
                                        "Red Hat",
                                        "Qualcomm",
                                        "Bain & Company",
                                        "Splunk",
                                        "Texas Instruments",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The process of computing a binary tree's vertical order traversal is used in practical software development in data visualization and UI design. For example, organizational chart layouts and displaying hierarchical data, where nodes represent entities and edges represent relationships between entities, utilize this concept. Being able to depict this data in a visually digestible form, using a vertical traversal pattern, allows users to make more informed decisions based on these relationships. Efficient implementation of this problem is essential for ensuring the process is run effectively and quickly, enhancing the user experience.",
                                    "hints": [
                                        {
                                            "hint": "Use a dictionary (column_map) where the key is the column index and the value is a list of (row, value) tuples. Traverse the tree using BFS (queue-based approach) or DFS (recursion). At each node (row, col), store (row, value) in the column_map[col]."
                                        },
                                        {
                                            "hint": "After traversal, extract values from column_map and sort them: Primary Sorting: By increasing column index (col). Secondary Sorting: Within each column, sort first by row and then by value (if the row is the same)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures that when multiple nodes are in the same column, they appear top-to-bottom, and in case of a tie, they appear in ascending order of value.",
                                            "question": "Why do we sort by both row index and node value?  "
                                        },
                                        {
                                            "answer": "BFS naturally processes nodes level by level, making it easier to track row index without recursion overhead. DFS can be used, but it requires explicit tracking of row and column indices during recursion.",
                                            "question": "Why does BFS work better than DFS in this case?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In diagonal traversal, nodes at (row, col) map to diagonal = row - col. Instead of grouping by column, we would group by diagonal index.",
                                            "question": "What if diagonal traversal was required instead of vertical order?  "
                                        },
                                        {
                                            "answer": "Level order traversal processes nodes row-wise, whereas vertical order traversal processes nodes column-wise.",
                                            "question": "How does this compare to level order traversal?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_topviewofbt",
                                "problem_name": "Top View of BT",
                                "problem_slug": "top-view-of-bt",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "NVIDIA",
                                        "Splunk",
                                        "Zomato",
                                        "Medtronic",
                                        "Twilio",
                                        "Instacart",
                                        "Unity Technologies",
                                        "Zoho",
                                        "Pinterest",
                                        "Flipkart",
                                        "Epic Games",
                                        "IBM",
                                        "Cloudflare",
                                        "eBay",
                                        "Seagate Technology",
                                        "Zynga",
                                        "Bloomberg",
                                        "Freshworks",
                                        "Riot Games",
                                        "Optum",
                                        "JPMorgan Chase",
                                        "Red Hat",
                                        "Reddit",
                                        "OYO Rooms",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of this problem, which is traversing through a binary tree, is extensively used in databases as well as file systems. For instance, the B-tree structure, a type of binary tree, allows for efficient insertion, deletion and search operations. This is especially beneficial for databases and file systems where data is large and needs to be stored on the hard drive. In cases like these, reducing the number of disk access during operations is crucial for the overall performance. So, understanding how to traverse binary trees isn't just restricted to coding puzzles, but has very tangible real-world applications in software development!",
                                    "hints": [
                                        {
                                            "hint": "Use a queue of tuples (node, horizontal_distance), starting with (root, 0). Process each node level by level, ensuring that we encounter nodes in top-to-bottom order."
                                        },
                                        {
                                            "hint": "Use a hashmap (top_nodes) where: Key: Horizontal Distance (HD). Value: First node encountered at that HD. If an HD is encountered for the first time, store the nodes value."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BFS processes nodes level by level, ensuring that we always encounter the topmost node first. DFS can work, but it requires explicit depth tracking to avoid incorrect overwrites.",
                                            "question": "Why do we use BFS instead of DFS?  "
                                        },
                                        {
                                            "answer": "Since BFS processes nodes level by level, the first node encountered for an HD is stored and never replaced.",
                                            "question": "What happens if multiple nodes share the same HD?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In bottom view, we replace existing entries instead of keeping the first one. This ensures that the last node at each HD is stored instead of the first.",
                                            "question": "How would this approach change if we needed a bottom view instead of a top view?  "
                                        },
                                        {
                                            "answer": "The approach already runs in O(N log N) due to sorting by HD. Using an ordered map (TreeMap in Java or sortedcontainers in Python) avoids explicit sorting, making it O(N log N) but slightly faster.",
                                            "question": "Can this approach be optimized further?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_bottomviewofbt",
                                "problem_name": "Bottom view of BT",
                                "problem_slug": "bottom-view-of-bt",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Alibaba",
                                        "JPMorgan Chase",
                                        "Rockstar Games",
                                        "Pinterest",
                                        "Byju's",
                                        "PayPal",
                                        "DoorDash",
                                        "Western Digital",
                                        "Mastercard",
                                        "Deloitte",
                                        "Flipkart",
                                        "Stripe",
                                        "Siemens Healthineers",
                                        "OYO Rooms",
                                        "Zynga",
                                        "Teladoc Health",
                                        "Chewy",
                                        "Roblox",
                                        "Ubisoft",
                                        "Cerner",
                                        "Swiggy",
                                        "Zoho",
                                        "Robinhood",
                                        "Philips Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: This problem is not just a theoretical one but has practical usage in software development too, especially in graphical user interface (GUI) applications and game development. In these areas, constructing and traversing trees, as well as deciding which node (or element) to showcase when two nodes overlap, are common scenarios. For instance, a game might use this concept to decide which character or object to highlight when two characters are at the same position on the Y-axis but at different depths (Z-axis).-which is akin to viewing from the bottom. The concepts used to solve this problem are also integral to data visualization, database systems, and machine learning algorithms for decision trees.",
                                    "hints": [
                                        {
                                            "hint": "Use a queue of tuples (node, horizontal_distance), starting with (root, 0). Process each node level by level, ensuring that the last node encountered at each HD is stored."
                                        },
                                        {
                                            "hint": "Use a hashmap (bottom_nodes) where: Key: Horizontal Distance (HD). Value: The last node encountered at that HD. As BFS progresses, overwrite the existing value in bottom_nodes[HD] since we need the last encountered node."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Each node's HD is unique for its vertical column. Since BFS processes nodes level by level, the last node encountered at each HD is stored as the bottom view.",
                                            "question": "How does the horizontal distance (HD) help in identifying the bottom view?  "
                                        },
                                        {
                                            "answer": "Yes, but BFS is more intuitive since it guarantees level-by-level processing without needing explicit depth tracking.",
                                            "question": "Can this be done using a recursive approach?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Vertical order traversal groups all nodes column-wise. Bottom view only considers the last encountered node for each column.",
                                            "question": "How does this problem compare to the vertical order traversal of a tree?  "
                                        },
                                        {
                                            "answer": "The approach already runs in O(N log N) due to sorting by HD. Using an ordered map (TreeMap in Java or sortedcontainers in Python) avoids explicit sorting, making it O(N log N) but slightly faster.",
                                            "question": "Can this approach be optimized further?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_right/leftviewofbt",
                                "problem_name": "Right/Left View of BT",
                                "problem_slug": "right-left-view-of-bt",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Micron Technology",
                                        "Unity Technologies",
                                        "Databricks",
                                        "NVIDIA",
                                        "Seagate Technology",
                                        "Bloomberg",
                                        "Deloitte",
                                        "Alibaba",
                                        "Goldman Sachs",
                                        "Square",
                                        "Bain & Company",
                                        "IBM",
                                        "Docker",
                                        "Ernst & Young",
                                        "Morgan Stanley",
                                        "Snowflake",
                                        "Pinterest",
                                        "Johnson & Johnson",
                                        "Stripe",
                                        "Western Digital",
                                        "Roche",
                                        "OYO Rooms",
                                        "DoorDash",
                                        "Lyft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is practically applied in database technologies that involve tree-based indexing like B-Trees or B+ Trees, commonly used in many SQL and NoSQL databases. For instance, MongoDB utilizes a variant of B-tree data structure for its indexes. Visibility from a certain perspective (here, it's from the right) can be used to optimize searches, traversals, or even distribution of nodes in parallel computing scenarios. Hence, understanding these kinds of problems is key to designing efficient data management or networking systems.",
                                    "hints": [
                                        {
                                            "hint": "Use a queue to process nodes level by level, keeping track of their depth. At each level, store only the last node encountered in that level (i.e., the rightmost node). Process the right child first, then the left child, ensuring that the rightmost node is encountered first."
                                        },
                                        {
                                            "hint": "Maintain a list (right_view[]) where right_view[level] stores the rightmost node at that level. The right_view list contains nodes arranged from top to bottom, forming the right-side view of the tree."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": " By processing the right child first, we ensure that the first node encountered at a level is the rightmost one.",
                                            "question": "How do we ensure the rightmost node is stored at each level? "
                                        },
                                        {
                                            "answer": "Yes! In a recursive approach, we: Use preorder traversal (Root  Right  Left). Maintain a depth variable and track the first node encountered at each depth. If a node is the first node encountered at its depth, it is added to the result.",
                                            "question": "Can this problem be solved using a recursive DFS approach?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of processing the right child first, process the left child first.",
                                            "question": "How would you modify the approach to return the left-side view instead?  "
                                        },
                                        {
                                            "answer": "The queue is needed to maintain level-order traversal, so while a single list wouldn't store all nodes, we could optimize memory by modifying it in place.",
                                            "question": "Can we solve this problem using a single list instead of a queue?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_printroottonotepathinbt",
                                "problem_name": "Print root to node path in BT",
                                "problem_slug": "print-root-to-note-path-in-bt",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Cloudflare",
                                        "Lyft",
                                        "Docker",
                                        "Etsy",
                                        "Shopify",
                                        "Boston Consulting Group",
                                        "Johnson & Johnson",
                                        "Bain & Company",
                                        "Rakuten",
                                        "Teladoc Health",
                                        "Flipkart",
                                        "Byju's",
                                        "Chewy",
                                        "Oracle",
                                        "Square",
                                        "Rockstar Games",
                                        "Micron Technology",
                                        "ARM",
                                        "Walmart",
                                        "Activision Blizzard",
                                        "Ernst & Young",
                                        "Ubisoft",
                                        "Salesforce",
                                        "Cerner",
                                        "OYO Rooms",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem involves using tree traversal, which is a key component of handling structured data. An interesting real-world application of such problems is in parsing data in XML or JSON format. These data formats are extensively used in web and app development, APIs, and configuration files. The tree-based structure of these formats often requires programs that can traverse their hierarchical nature, similar to the problem of finding all root-to-leaf paths in a binary tree.",
                                    "hints": [
                                        {
                                            "hint": "Start from the root node and traverse the tree recursively. Maintain a current path list that stores nodes visited so far."
                                        },
                                        {
                                            "hint": "When reaching a leaf node, store the current path in the result list. Use backtracking to remove the last node when returning from recursion."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "DFS is naturally suited for pathfinding problems since it explores one complete path before backtracking. BFS requires storing more nodes in memory, making it less space-efficient.",
                                            "question": "Why use DFS instead of BFS?  "
                                        },
                                        {
                                            "answer": "When returning from recursion, we remove the last node from the path to ensure it does not affect other recursive calls.",
                                            "question": "Why do we need backtracking in the recursive approach?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of storing lists, concatenate values into a string like \"1->2->5\".",
                                            "question": "What if we needed to return paths as strings instead of lists?  "
                                        },
                                        {
                                            "answer": " Modify traversal to include a running sum and filter paths based on conditions.",
                                            "question": "What if some nodes had a special property (e.g., sum constraint)? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_lcainbt",
                                "problem_name": "LCA in BT",
                                "problem_slug": "lca-in-bt",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Rockstar Games",
                                        "Robinhood",
                                        "MongoDB",
                                        "Micron Technology",
                                        "American Express",
                                        "Broadcom",
                                        "Uber",
                                        "Boston Consulting Group",
                                        "Ernst & Young",
                                        "Texas Instruments",
                                        "Red Hat",
                                        "Riot Games",
                                        "Philips Healthcare",
                                        "Lyft",
                                        "Cloudflare",
                                        "Epic Systems",
                                        "Target",
                                        "Zomato",
                                        "Swiggy",
                                        "Seagate Technology",
                                        "Rakuten",
                                        "Qualcomm",
                                        "Mastercard",
                                        "Snowflake",
                                        "Unity Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of finding the lowest common ancestor (LCA) in a binary tree is a crucial part of Git version control system, which is widely used in software development. Git stores its metadata as a simple directed acyclic graph, and uses this algorithm to efficiently determine the most recent common ancestor of two branches. This aids in streamlining merging operations and tracking down bugs in the code.",
                                    "hints": [
                                        {
                                            "hint": "Recursively search the left subtree for p and q. Recursively search the right subtree for p and q."
                                        },
                                        {
                                            "hint": "If both left and right subtrees return non-null values, then the current node is the LCA because p and q are in different subtrees. If only one subtree returns a non-null value, return that subtrees value (it means both p and q are located in the same subtree). If both left and right return null, return null."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": " Yes, by storing parent pointers and using a hash set to track visited ancestors, but recursion is more elegant.",
                                            "question": "Can we solve this problem iteratively? "
                                        },
                                        {
                                            "answer": "If the tree is a BST, we can solve the problem more efficiently in O(log N) by using BST properties.",
                                            "question": "How does this differ for a Binary Search Tree (BST)?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, we would generalize the function to return the lowest node that contains all given nodes in its subtree.",
                                            "question": "Can this be extended to find LCA of multiple nodes instead of just two?  "
                                        },
                                        {
                                            "answer": "We would track node depth while traversing and return the deepest LCA found.",
                                            "question": "How would this change if we needed the \"deepest\" common ancestor instead?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_maximumwidthofbt",
                                "problem_name": "Maximum Width of BT",
                                "problem_slug": "maximum-width-of-bt",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Ubisoft",
                                        "Salesforce",
                                        "OYO Rooms",
                                        "Electronic Arts",
                                        "Airbnb",
                                        "Medtronic",
                                        "American Express",
                                        "Reddit",
                                        "Cloudflare",
                                        "Stripe",
                                        "Intel",
                                        "ARM",
                                        "Riot Games",
                                        "Epic Games",
                                        "Broadcom",
                                        "Oracle",
                                        "Unity Technologies",
                                        "Swiggy",
                                        "Optum",
                                        "Instacart",
                                        "Freshworks",
                                        "Bloomberg",
                                        "Zynga",
                                        "Byju's",
                                        "Shopify",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem, essentially about finding the maximum width of a binary tree, has direct applications in creating balanced search algorithms in databases. Database management systems often use tree data structures (B-trees, B+ trees, etc.) to ensure faster access to information. The width here represents the number of nodes in each level of the tree, and keeping this number balanced or controlled allows databases to ensure efficient querying times. This problem reinforces the importance of understanding and handling tree data structures effectively, as this can directly influence the performance of many software applications that depend on databases.",
                                    "hints": [
                                        {
                                            "hint": "Initialize a queue with (root, index = 0), where index represents the position in a complete binary tree. Perform BFS level by level"
                                        },
                                        {
                                            "hint": "Track the first and last index of nodes at the current level. Compute width as last_index - first_index + 1 and update max_width. Add children to the queue with calculated indices based on complete tree properties"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since the problem requires measuring gaps between nodes, using indices from a complete binary tree representation helps in accurately computing distances between leftmost and rightmost nodes.",
                                            "question": "Why do we track indices in a complete binary tree format?  "
                                        },
                                        {
                                            "answer": "The width is calculated based on indices, meaning it counts the empty positions between nodes rather than just counting non-null nodes.",
                                            "question": "What happens if there are missing nodes in the middle of a level?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of using position-based width, simply count the number of nodes at each level without considering gaps.",
                                            "question": "How would you modify the approach to count only non-null nodes?  "
                                        },
                                        {
                                            "answer": " Yes! Just keep track of the maximum node count at any level instead of width calculation.",
                                            "question": "Can this be extended to find the level with the maximum number of nodes instead of width? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_printallnodesatadistanceofkinbt",
                                "problem_name": "Print all nodes at a distance of K in BT",
                                "problem_slug": "print-all-nodes-at-a-distance-of-k-in-bt",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Walmart",
                                        "MongoDB",
                                        "Activision Blizzard",
                                        "HashiCorp",
                                        "Etsy",
                                        "Riot Games",
                                        "Rakuten",
                                        "Teladoc Health",
                                        "Cloudflare",
                                        "Broadcom",
                                        "Philips Healthcare",
                                        "Pinterest",
                                        "Optum",
                                        "GE Healthcare",
                                        "Shopify",
                                        "Bloomberg",
                                        "Roche",
                                        "Intel",
                                        "Twilio",
                                        "Instacart",
                                        "Cerner",
                                        "Uber",
                                        "Swiggy",
                                        "Bungie",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem or its underpinning concept finds great application in social networking apps like Facebook, LinkedIn, etc. In these apps, a user's connection with other users is a graph, and this problem helps in discovering nodes (other users), who are at a specified distance (degrees of connection, for example, friends of friends - 2nd degree connections on LinkedIn) from a target node (a particular user). Facebooks People You May Know feature and LinkedIns Connections of feature work based on this concept.",
                                    "hints": [
                                        {
                                            "hint": "Use DFS or BFS to build a graph (adjacency list) where: Each node points to its left and right children. Each node points to its parent (establishing bidirectional links)."
                                        },
                                        {
                                            "hint": "Start from the target node and use BFS to traverse exactly k levels. Keep track of visited nodes to avoid cycles. Once BFS reaches level k, store all nodes and return them."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The tree is unidirectional (parent  child), but we need to traverse both upward and downward. By storing parent links, we can move upward in addition to left/right child traversal.",
                                            "question": "Why do we need to convert the tree into a graph?  "
                                        },
                                        {
                                            "answer": "If the tree is left-skewed or right-skewed, the traversal still works since parent links help in moving upward.",
                                            "question": "What happens if the tree is skewed?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store all nodes encountered from level 0 to k in BFS traversal.",
                                            "question": "How would this change if we needed all nodes within distance k instead of exactly k?  "
                                        },
                                        {
                                            "answer": " Yes, but would require modifying the tree structure in place, which is not ideal.",
                                            "question": "Can this be done without extra space for the graph? "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_minimumtimetakentoburnthebtfromagivennode",
                                "problem_name": "Minimum time taken to burn the BT from a given Node",
                                "problem_slug": "minimum-time-taken-to-burn-the-bt-from-a-given-node",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "eBay",
                                        "Airbnb",
                                        "Etsy",
                                        "American Express",
                                        "Shopify",
                                        "Mastercard",
                                        "Seagate Technology",
                                        "HashiCorp",
                                        "Roche",
                                        "Unity Technologies",
                                        "Uber",
                                        "Visa",
                                        "Goldman Sachs",
                                        "Boston Consulting Group",
                                        "Instacart",
                                        "OYO Rooms",
                                        "NVIDIA",
                                        "Cerner",
                                        "Optum",
                                        "Nutanix",
                                        "Cloudflare",
                                        "Epic Systems",
                                        "Rockstar Games",
                                        "Docker",
                                        "Snowflake",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "While this specific problem about setting a binary tree on fire is not directly applied in the software industry, the underlying concepts of tree traversal, breadth-first search, depth-first search, and shortest path finding are essential in various areas. They are used in data mining and machine learning algorithms, routing protocols like Open Shortest Path First in networks, file system hierarchies in operating systems, graph databases, and even in the layout rendering in Android's XML design. This problem helps to enhance the understanding of these concepts in a unique way.",
                                    "hints": [
                                        {
                                            "hint": "Use DFS (or BFS) to create an adjacency list representation of the tree. Each node should have references to its left child, right child, and parent to allow traversal in both directions."
                                        },
                                        {
                                            "hint": "Start BFS traversal from the target node (fire source). Spread fire level by level every second. Keep track of visited nodes to avoid cycles."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The tree is unidirectional (parent  child), but fire spreads in both directions (upward and downward). By tracking parent nodes, we can move up the tree.",
                                            "question": "Why do we need to convert the tree into a graph?  "
                                        },
                                        {
                                            "answer": "Maintain a visited set to track already burned nodes.",
                                            "question": "How do we prevent re-burning nodes?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of returning time, store nodes per second level during BFS.",
                                            "question": "How would we modify this if we needed to return all nodes that burn at each second?  "
                                        },
                                        {
                                            "answer": "Yes, but DFS would require tracking maximum depth from the target node and handling multiple subtree burn times.",
                                            "question": "Can we solve this problem using only DFS?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_faqs_counttotalnoesinacompletebt",
                                "problem_name": "Count total nodes in a complete BT",
                                "problem_slug": "count-total-nodes-in-a-complete-bt",
                                "problem_rank": 12,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Optum",
                                        "Freshworks",
                                        "Unity Technologies",
                                        "Philips Healthcare",
                                        "HCL Technologies",
                                        "Goldman Sachs",
                                        "Shopify",
                                        "Visa",
                                        "IBM",
                                        "Zoho",
                                        "Instacart",
                                        "Bloomberg",
                                        "Broadcom",
                                        "Pinterest",
                                        "Medtronic",
                                        "Rakuten",
                                        "eBay",
                                        "Johnson & Johnson",
                                        "Robinhood",
                                        "Reddit",
                                        "Rockstar Games",
                                        "HashiCorp",
                                        "Walmart",
                                        "Dropbox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept of counting the number of nodes in a binary tree is useful in many software applications. For instance, in file systems and databases, Binary Trees (especially Binary Search Trees) are often used for efficient searching and sorting of data. Here, the knowledge of total nodes can be used for optimization, load balancing, and in determining how deep the tree is, which is essential while performing operations like adding, deleting, or searching for a node. Furthermore, companies like Google use similar principles in their MapReduce programming model to process huge sets of data efficiently.",
                                    "hints": [
                                        {
                                            "hint": "Perform a DFS (recursive) or BFS (iterative) traversal. Maintain a counter that increments for each node encountered. Base Case: If the root is null, return 0."
                                        },
                                        {
                                            "hint": "If a tree is complete, its height can be determined by following the leftmost path. A complete binary tree has at most 2^h - 1 nodes. The last level may not be completely full, meaning we need to count nodes in the last level."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": " If a tree is perfect, it has exactly 2^h - 1 nodes, and we can compute it directly in O(1).",
                                            "question": "What if the tree is a perfect binary tree? "
                                        },
                                        {
                                            "answer": "In a complete tree, every level (except the last) is fully filled, so the leftmost path always reaches the maximum height.",
                                            "question": "Why does following the leftmost path give the tree height?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The same DFS/BFS approach works, but the optimized binary search method is specific to binary trees.",
                                            "question": "What if we needed to count nodes in a tree where each node has more than two children?  "
                                        },
                                        {
                                            "answer": "Counting leaf nodes involves checking if a node has no children, whereas counting all nodes requires traversing the full structure.",
                                            "question": "How does this compare to counting leaf nodes?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarytrees_constructionproblems",
                        "subcategory_name": "Construction Problems",
                        "subcategory_slug": "construction-problems",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_constructionproblems_requirementsneededtoconstructauniquebt",
                                "problem_name": "Requirements needed to construct a unique BT",
                                "problem_slug": "requirements-needed-to-construct-a-unique-bt",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "Zomato",
                                        "Alibaba",
                                        "McKinsey & Company",
                                        "Micron Technology",
                                        "Medtronic",
                                        "AMD",
                                        "Deloitte",
                                        "GE Healthcare",
                                        "Epic Games",
                                        "Oracle",
                                        "Swiggy",
                                        "Uber",
                                        "Freshworks",
                                        "Wayfair",
                                        "Databricks",
                                        "IBM",
                                        "ARM",
                                        "Johnson & Johnson",
                                        "DoorDash",
                                        "Robinhood",
                                        "Ernst & Young",
                                        "NVIDIA",
                                        "Zynga",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem can be commonly seen in the construction of Abstract Syntax Trees (ASTs) in compilers. Compilers use these different tree traversal techniques to parse the syntax of programming languages. An incorrect traversal can lead to incorrect construction of the AST, leading to incorrect execution or wrong results. Moreover, understanding binary trees is fundamental to database querying, such as SQL, where they are used to quickly retrieve stored data. So, solving this problem indeed has a significant importance in practical software development.",
                                    "hints": [
                                        {
                                            "hint": "Given two types of tree traversals, we need to determine if a unique binary tree can be reconstructed. Each traversal is represented by an integer identifier 1  Preorder Traversal 2  Inorder Traversal 3  Postorder Traversal "
                                        },
                                        {
                                            "hint": "A binary tree can only be uniquely constructed if:  One of the traversals must be Inorder, because Inorder preserves the relative position of nodes. The second traversal must be either Preorder or Postorder"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Inorder preserves relative left and right positions, ensuring a consistent tree structure. Without Inorder, Preorder and Postorder alone are ambiguous.",
                                            "question": "Why do we need Inorder for uniqueness?  "
                                        },
                                        {
                                            "answer": "No, unless additional constraints (like BST properties) are given. A single traversal does not provide enough information about left vs. right children.",
                                            "question": "Can a tree be reconstructed from only one traversal?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If explicit parent-child mappings were provided, we could reconstruct without needing two traversals.",
                                            "question": "What if additional information (like parent-child relationships) was given?  "
                                        },
                                        {
                                            "answer": "More than two traversals would be needed since binary tree rules do not apply.",
                                            "question": "Can this be extended to ternary or quaternary trees?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_constructionproblems_constructabtfrompreorderandinorder",
                                "problem_name": "Construct a BT from Preorder and Inorder",
                                "problem_slug": "construct-a-bt-from-preorder-and-inorder",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "ARM",
                                        "Zomato",
                                        "Morgan Stanley",
                                        "Rockstar Games",
                                        "Cerner",
                                        "Snowflake",
                                        "Epic Games",
                                        "GE Healthcare",
                                        "Qualcomm",
                                        "DoorDash",
                                        "Rakuten",
                                        "Roche",
                                        "Oracle",
                                        "Optum",
                                        "Splunk",
                                        "Reddit",
                                        "Flipkart",
                                        "Philips Healthcare",
                                        "AMD",
                                        "Chewy",
                                        "Square",
                                        "Johnson & Johnson",
                                        "Wayfair",
                                        "Unity Technologies",
                                        "Micron Technology",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept underlying this problem is fundamental to the way databases organize and retrieve their data. Databases use tree structures (like Binary Search Trees) to store data, which optimizes search queries, inserts, deletes, and sequential data access. Efficient tree construction algorithms, like the one this problem aims to solve, are therefore vital to the database's performance. Also, this concept is utilized in routing protocols in network software, and the visual representation of hierarchical data, such as directory structures or organization charts in applications.",
                                    "hints": [
                                        {
                                            "hint": "Locate the root's index in inorder. The left subtree elements are before the root index. The right subtree elements are after the root index."
                                        },
                                        {
                                            "hint": " Recursively Construct the Left and Right Subtrees Use sliced subarrays to pass correct values for left and right subtree construction."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Preorder traversal gives us the root first, allowing us to determine subtree boundaries from inorder. Inorder traversal preserves the left-right relationship, ensuring correct tree structure.",
                                            "question": "Why does this approach work?  "
                                        },
                                        {
                                            "answer": "Recursion mimics tree structure naturally, making it easier to handle subproblems. Iterative solutions require explicit stack management, which is harder.",
                                            "question": "Why do we use recursion instead of iteration?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, using a stack-based approach with preorder processing.",
                                            "question": "Can this be done iteratively instead of recursively?  "
                                        },
                                        {
                                            "answer": "BST properties can allow an alternate construction method without needing inorder traversal.",
                                            "question": "How would this change if the tree was a BST?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_constructionproblems_constructabtfrompostorderandinorder",
                                "problem_name": "Construct a BT from Postorder and Inorder",
                                "problem_slug": "construct-a-bt-from-postorder-and-inorder",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Red Hat",
                                        "Medtronic",
                                        "Teladoc Health",
                                        "Uber",
                                        "PwC",
                                        "ARM",
                                        "Square",
                                        "Bain & Company",
                                        "Cloudflare",
                                        "Chewy",
                                        "IBM",
                                        "NVIDIA",
                                        "Target",
                                        "Deloitte",
                                        "American Express",
                                        "Qualcomm",
                                        "Instacart",
                                        "Intel",
                                        "Seagate Technology",
                                        "Epic Games",
                                        "JPMorgan Chase",
                                        "OYO Rooms",
                                        "Johnson & Johnson",
                                        "Splunk",
                                        "Activision Blizzard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem is directly relevant in the world of computer graphics and rendering. Particularly, it's used in algorithms for \"Binary Space Partitioning\" - a method often employed in 3D computer graphics for rendering scenes with a large number of overlapping objects. Constructing binary trees using preorder and inorder traversals is crucial in defining the ordering and space divisions. Not to forget, such problems also have substantial uses in designing compilers and databases.",
                                    "hints": [
                                        {
                                            "hint": "Locate the root in the inorder array to determine: Left subtree nodes (all nodes to the left of the root in inorder). Right subtree nodes (all nodes to the right of the root in inorder)."
                                        },
                                        {
                                            "hint": "Recursively build the left and right subtrees using the respective subarrays from postorder and inorder."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The approach fails because locating the root in inorder is not unique. To handle duplicates, we can use additional information like index maps.",
                                            "question": "What happens if duplicates exist in the arrays?  "
                                        },
                                        {
                                            "answer": "Use a HashMap (dictionary) to store inorder value  index mappings, reducing lookup time to O(1).",
                                            "question": "How do we optimize repeated root lookups in inorder?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Rebuilding expression trees from syntax orders, deserialization of tree structures.",
                                            "question": "How does this problem relate to real-world applications?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_constructionproblems_serializeandde-serializebt",
                                "problem_name": "Serialize and De-serialize BT",
                                "problem_slug": "serialize-and-de-serialize-bt",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Stripe",
                                        "Rockstar Games",
                                        "PayPal",
                                        "Databricks",
                                        "ARM",
                                        "HCL Technologies",
                                        "Robinhood",
                                        "Uber",
                                        "Intel",
                                        "Zomato",
                                        "HashiCorp",
                                        "MongoDB",
                                        "Epic Games",
                                        "Broadcom",
                                        "Walmart",
                                        "Activision Blizzard",
                                        "Bungie",
                                        "DoorDash",
                                        "Target",
                                        "McKinsey & Company",
                                        "Alibaba",
                                        "Cerner",
                                        "KPMG",
                                        "JPMorgan Chase",
                                        "American Express",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Did you know that the concept of serialization and deserialization is heavily used in sending and receiving data over the network or storing data in databases? For instance, in web development, when data is fetched from an API, it's often transmitted in JSON format which is text-based and easy to read. But, that's not how your objects exist in your code. They're in the form of complex data structures or binary format. Hence, they need to be converted (serialize) into a string form to travel across the network. Then, at the destination, they are converted back (deserialize) into usable objects. This allows different software systems, possibly deployed on different platforms and written in different languages, to communicate and exchange complex data.",
                                    "hints": [
                                        {
                                            "hint": "Serialization: Use BFS (level-order traversal) to process nodes. Store null values for missing children to maintain tree structure. Use comma-separated values (CSV format). Use Preorder traversal (Root  Left  Right). Store \"N\" (or null) for missing children."
                                        },
                                        {
                                            "hint": "Deserialization: Read the string and split it into nodes. Use a queue to rebuild the tree level by level. Read values sequentially and recursively reconstruct the tree."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "null nodes preserve tree structure, ensuring correct reconstruction.",
                                            "question": "Why do we need to store null values in serialization?  "
                                        },
                                        {
                                            "answer": "Possible, but tracking parents and children becomes harder.",
                                            "question": "Can we deserialize without using a queue?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! But a more space-efficient approach is to store only Preorder traversal and reconstruct using BST properties.",
                                            "question": "Can this work for a BST (Binary Search Tree)?  "
                                        },
                                        {
                                            "answer": "Instead of left/right pointers, store lists of children.",
                                            "question": "How would you modify this for an N-ary tree?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarytrees_traversalinconstantspace",
                        "subcategory_name": "Traversal in Constant Space",
                        "subcategory_slug": "traversal-in-constant-space",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_traversalinconstantspace_morristraversal|inorder",
                                "problem_name": "Morris Inorder Traversal",
                                "problem_slug": "morris-inorder-traversal-",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Epic Systems",
                                        "Visa",
                                        "Zoho",
                                        "Shopify",
                                        "Lyft",
                                        "Ernst & Young",
                                        "Morgan Stanley",
                                        "Western Digital",
                                        "GE Healthcare",
                                        "Salesforce",
                                        "eBay",
                                        "Unity Technologies",
                                        "Stripe",
                                        "Qualcomm",
                                        "Robinhood",
                                        "Swiggy",
                                        "MongoDB",
                                        "Byju's",
                                        "Boston Consulting Group",
                                        "Cloudflare",
                                        "Oracle",
                                        "Flipkart",
                                        "IBM",
                                        "Cerner",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of an Inorder Tree Traversal, including the optimized Morris Inorder Traversal, has extensive practical applications in database systems. Database storage and querying often utilize B-trees and B+ trees, which are generalized binary trees. Thus, Inorder Traversal is used to retrieve items from these trees in a sorted manner. This is crucial for operations like range queries or sorted output which forms the backbone of database manipulation languages like SQL.",
                                    "hints": [
                                        {
                                            "hint": "Instead of using a stack, it modifies the tree structure temporarily by creating threaded links using the rightmost node of the left subtree."
                                        },
                                        {
                                            "hint": "Instead of using a stack, it modifies the tree structure temporarily by creating threaded links using the rightmost node of the left subtree."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Traditional inorder traversal uses a recursive call stack (O(H) space) or an explicit stack (O(N) space). Morris traversal modifies the tree temporarily by linking the inorder predecessor to the current node, allowing backtracking without a stack. Once the traversal revisits a node, it removes the temporary threaded link, restoring the original tree structure.",
                                            "question": "How does Morris Traversal achieve O(1) space complexity?  "
                                        },
                                        {
                                            "answer": "The inorder predecessor is the rightmost node in the left subtree. Before moving left, we link this nodes right child to the current node, allowing us to return without using a stack.",
                                            "question": "Why do we find the inorder predecessor?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Recursive traversal uses O(H) space (stack frames), and iterative traversal with a stack uses O(N) space. Morris traversal uses O(1) space, making it ideal for constrained environments.",
                                            "question": "How does Morris traversal compare to recursive and iterative traversal?  "
                                        },
                                        {
                                            "answer": "It modifies the tree structure temporarily, which might not be acceptable in all cases. Finding the inorder predecessor requires extra steps, making it slightly slower in practice than a stack-based iterative approach. It only works efficiently for binary trees, not general trees.",
                                            "question": "What are the limitations of Morris traversal?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_traversalinconstantspace_morrispreordertraversal",
                                "problem_name": "Morris Preorder Traversal",
                                "problem_slug": "morris-preorder-traversal-",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "PayPal",
                                        "McKinsey & Company",
                                        "Snowflake",
                                        "Western Digital",
                                        "Zynga",
                                        "Etsy",
                                        "Databricks",
                                        "Ernst & Young",
                                        "Salesforce",
                                        "Morgan Stanley",
                                        "HCL Technologies",
                                        "Lyft",
                                        "Epic Systems",
                                        "Qualcomm",
                                        "Walmart",
                                        "Red Hat",
                                        "Johnson & Johnson",
                                        "Wayfair",
                                        "Robinhood",
                                        "Stripe",
                                        "Roblox",
                                        "Reddit",
                                        "Medtronic",
                                        "KPMG",
                                        "Philips Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of binary tree traversal, including the efficient Morris preorder traversal, is widely used in the software industry for data analysis and database management. For example, SQL uses binary trees and traversal algorithms to fetch, insert, delete or update data records. The same concept is applied in GUI rendering, file systems, router algorithms, artificial intelligence for decision-making, and in managing hierarchical data in applications. The efficiency and speed of the traversal are essential to performance, making algorithms like Morris preorder traversal crucial in handling larger databases or complex data structures.",
                                    "hints": [
                                        {
                                            "hint": "If a node has a left child, find its inorder predecessor (rightmost node in the left subtree). Create a temporary link from the inorder predecessor to the current node to allow backtracking. If a node has no left child, visit it directly and move right."
                                        },
                                        {
                                            "hint": "Print the node before moving to the left subtree (Preorder: Root  Left  Right). If revisiting via the threaded link, remove the link and move right."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The inorder predecessor is the rightmost node in the left subtree. It acts as a temporary bridge back to the current node after processing the left subtree.",
                                            "question": "What is the role of the inorder predecessor in Morris Traversal?  "
                                        },
                                        {
                                            "answer": "The node is processed immediately and traversal moves to the right child. No threaded links are required in this case.",
                                            "question": "What happens if a node has no left child?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Postorder traversal requires reversing right child processing, making it more complex. It involves modifying the tree to process right children last, often using an auxiliary structure.",
                                            "question": "How would this approach change for Postorder traversal?  "
                                        },
                                        {
                                            "answer": "No, because Morris Traversal relies on binary tree properties (left and right child relationships). For an N-ary tree, Morris traversal cannot be directly applied.",
                                            "question": "Can this be extended to an N-ary tree?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarytrees_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 6,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "binarytrees_binarytrees_contest_minimumtravelcost",
                                "problem_name": "Minimum Travel Cost",
                                "problem_slug": "minimum-travel-cost",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarytrees_binarytrees_contest_networkmessagepassing",
                                "problem_name": "Maximum subtree sum",
                                "problem_slug": "maximum-subtree-sum",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "tree_greatness",
                                "problem_name": "Tree Greatness",
                                "problem_slug": "tree-greatness",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "binarysearchtrees",
                "category_name": "Binary Search Trees",
                "category_slug": "binary-search-trees",
                "category_rank": 12,
                "subcategories": [
                    {
                        "subcategory_id": "binarysearchtrees_theoryandbasics",
                        "subcategory_name": "Theory and Basics",
                        "subcategory_slug": "theory-and-basics",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_theoryandbasics_introductiontobst",
                                "problem_name": "Introduction to BST",
                                "problem_slug": "introduction-to-bst",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Siemens Healthineers",
                                        "PwC",
                                        "Instacart",
                                        "Cerner",
                                        "Broadcom",
                                        "Rockstar Games",
                                        "Salesforce",
                                        "Byju's",
                                        "Roche",
                                        "Airbnb",
                                        "Splunk",
                                        "Mastercard",
                                        "Boston Consulting Group",
                                        "Goldman Sachs",
                                        "AMD",
                                        "JPMorgan Chase",
                                        "PayPal",
                                        "Target",
                                        "Ernst & Young",
                                        "KPMG",
                                        "OYO Rooms",
                                        "Visa",
                                        "Oracle",
                                        "Databricks",
                                        "Medtronic"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_theoryandbasics_searchinbst",
                                "problem_name": "Search in BST",
                                "problem_slug": "search-in-bst",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "Bain & Company",
                                        "Salesforce",
                                        "GE Healthcare",
                                        "Byju's",
                                        "Alibaba",
                                        "Lyft",
                                        "eBay",
                                        "Databricks",
                                        "Siemens Healthineers",
                                        "Splunk",
                                        "IBM",
                                        "Mastercard",
                                        "Etsy",
                                        "Roblox",
                                        "Epic Games",
                                        "PayPal",
                                        "PwC",
                                        "Docker",
                                        "Zomato",
                                        "Dropbox",
                                        "Twilio",
                                        "Johnson & Johnson",
                                        "AMD",
                                        "OYO Rooms",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Searching for a specific node in a binary search tree (BST) is a fundamental function that underlies many real-world applications, including database management systems and search engines. These systems often use a form of BST known as a B-tree. When you perform a Google search or a SQL query, these systems are using a version of the search operation defined in this problem to efficiently find relevant records among possibly billions. This is because BST allow for efficient lookups, additions, and deletions, which are key operations for these systems.",
                                    "hints": [
                                        {
                                            "hint": "If val == root.val, return the subtree rooted at this node. If val < root.val, recursively search in the left subtree. If val > root.val, recursively search in the right subtree."
                                        },
                                        {
                                            "hint": "If val matches the current node, return it. If val < root.val, move to the left subtree. If val > root.val, move to the right subtree. If null is reached, return null (value not found)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A valid BST does not have duplicate values by definition. If duplicates exist (e.g., in a modified BST with duplicate handling), we might need to return all matching nodes instead of just one.",
                                            "question": "What if multiple nodes have the same value in the BST?"
                                        },
                                        {
                                            "answer": "BST properties guarantee that if val < root.val, it must be in the left subtree (if it exists). Likewise, if val > root.val, it must be in the right subtree. Unlike a normal binary tree, BST only requires searching in one direction, reducing time complexity.",
                                            "question": "Why do we not search both left and right subtrees?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "We can track the closest node encountered while traversing the BST. Instead of returning null, return the node with the smallest absolute difference from val.",
                                            "question": "How can this be extended to return the closest value if val does not exist?"
                                        },
                                        {
                                            "answer": "For a general binary tree, there is no ordering property, so we must perform a full tree traversal (DFS or BFS) instead of binary search. This increases complexity to O(n).",
                                            "question": "How does this problem change if we were searching in a normal binary tree (not a BST)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_theoryandbasics_floorinabst",
                                "problem_name": "Floor and Ceil in a BST",
                                "problem_slug": "floor-and-ceil-in-a-bst",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "MongoDB",
                                        "Roche",
                                        "Broadcom",
                                        "IBM",
                                        "Epic Games",
                                        "Lyft",
                                        "Intel",
                                        "Shopify",
                                        "Unity Technologies",
                                        "McKinsey & Company",
                                        "Alibaba",
                                        "Wayfair",
                                        "DoorDash",
                                        "Morgan Stanley",
                                        "Salesforce",
                                        "OYO Rooms",
                                        "Reddit",
                                        "Ernst & Young",
                                        "Medtronic",
                                        "Rakuten",
                                        "Oracle",
                                        "Swiggy",
                                        "HCL Technologies",
                                        "Red Hat",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem's underlying concept is extensively used in database management systems (DBMS) and indexing techniques. For instance, when you're performing a database query using SQL to find a specific value in a table, a database system may use a binary search tree or B-tree internally (as an index) to look for that value. This greatly reduces search time, especially in substantial-sized databases. Finding floor and ceil values can be relevant in range-based queries or searches, such as identifying items in a certain price range on an e-commerce platform. Hence, proficiency in understanding and solving such problems may contribute to optimizing database operations and queries.",
                                    "hints": [
                                        {
                                            "hint": "\"Traverse the BST while updating floor and ceil. If key == root.val, Floor = key, Ceil = key (since key exists in BST). If key < root.val, Update ceil = root.val and Move left. If key > root.val, Update floor = root.val and Move right.\""
                                        },
                                        {
                                            "hint": "\"Recursively explore the BST based on key, updating floor and ceil dynamically. The base case occurs when we reach a null node.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If every node in the BST is greater than key, no floor exists (floor = -1), and the smallest node becomes the ceil.",
                                            "question": "What happens if all values in the BST are greater than key?"
                                        },
                                        {
                                            "answer": "We can search for both in a single traversal using the BST property. Instead of performing separate searches, we update floor and ceil dynamically during one DFS/BFS traversal.",
                                            "question": "Why cant we search for both floor and ceil in one pass?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For large-scale BSTs (like B-Trees used in databases), balanced partitioning and cached floor/ceil lookups speed up queries significantly.",
                                            "question": "Can this be optimized further for very large trees?"
                                        },
                                        {
                                            "answer": "Since AVL trees are self-balancing, search operations remain O(log n), preventing the worst-case O(n) scenario seen in skewed BSTs. The algorithm remains the same but benefits from faster lookups.",
                                            "question": "How would this be implemented in an AVL tree?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearchtrees_medium",
                        "subcategory_name": "Medium",
                        "subcategory_slug": "medium",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_insertagivennodeinbst",
                                "problem_name": "Insert a given node in BST",
                                "problem_slug": "insert-a-given-node-in-bst",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Bain & Company",
                                        "Philips Healthcare",
                                        "Zomato",
                                        "Zynga",
                                        "eBay",
                                        "Square",
                                        "Epic Games",
                                        "Siemens Healthineers",
                                        "JPMorgan Chase",
                                        "Rakuten",
                                        "Freshworks",
                                        "Rockstar Games",
                                        "Shopify",
                                        "Pinterest",
                                        "Bloomberg",
                                        "Texas Instruments",
                                        "Broadcom",
                                        "PwC",
                                        "Cerner",
                                        "HCL Technologies",
                                        "Electronic Arts",
                                        "Dropbox",
                                        "Uber",
                                        "Optum",
                                        "Johnson & Johnson",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The problem underlying this concept is extensively used in the development of databases. When adding new records, most databases use binary search trees (specifically, B-trees or B+ trees), or variants of them, to maintain sorted data and ensure fast search, insert, and delete operations. This way, when you look up a piece of information in a large database, the engine will use binary search trees to quickly locate the data you need.",
                                    "hints": [
                                        {
                                            "hint": "If root == null, create a new node with val and return it. If val < root.val, insert val into the left subtree (root.left). If val > root.val, insert val into the right subtree (root.right). Return the root node after insertion."
                                        },
                                        {
                                            "hint": "Start from the root and traverse the tree. If val < current.val, move left. If val > current.val, move right. When an empty spot (null) is found, create a new node and attach it. Return the original root."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the BST is left-heavy, inserting a large value will extend it further right. If it is right-heavy, inserting a small value will extend it further left.",
                                            "question": "What happens if the BST is skewed?"
                                        },
                                        {
                                            "answer": "Standard BST insertion does not balance the tree. To ensure balanced insertion, use AVL trees or Red-Black Trees, which rebalance after insertions.",
                                            "question": "Can we balance the tree after insertion?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "BSTs are the basis for B-Trees, used in database indexing. Balanced insertions ensure efficient search, insert, and delete operations in structured storage systems.\n",
                                            "question": "How does this problem relate to databases and indexing?"
                                        },
                                        {
                                            "answer": "After insertion, perform rotations and balance updates to maintain a logarithmic height. AVL trees ensure balance immediately, while Red-Black trees allow temporary imbalance.",
                                            "question": "How would you modify this for self-balancing trees (AVL, Red-Black Trees)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_deleteanodeinbst",
                                "problem_name": "Delete a node in BST",
                                "problem_slug": "delete-a-node-in-bst",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Twilio",
                                        "AMD",
                                        "NVIDIA",
                                        "eBay",
                                        "Riot Games",
                                        "Byju's",
                                        "Unity Technologies",
                                        "IBM",
                                        "Lyft",
                                        "Cerner",
                                        "Target",
                                        "Instacart",
                                        "Robinhood",
                                        "Morgan Stanley",
                                        "Medtronic",
                                        "Walmart",
                                        "Siemens Healthineers",
                                        "Teladoc Health",
                                        "Chewy",
                                        "Zynga",
                                        "JPMorgan Chase",
                                        "Johnson & Johnson",
                                        "Swiggy",
                                        "Nutanix",
                                        "Electronic Arts",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem is very fundamental in the field of database management systems (DBMS). When you delete a record from the database, if it's organized in a binary search tree manner, the DBMS under the hood performs exactly this operation of finding and deleting a node from a BST. So think about it, every time you hit 'delete' on an item in a software application, you're indirectly making use of this BST deletion logic.",
                                    "hints": [
                                        {
                                            "hint": "Search for the key in the BST. Once found, If it has no children, remove it (return None). If it has one child, replace it with its child. If it has two children, replace it with the smallest node in the right subtree (inorder successor) or the largest node in the left subtree (inorder predecessor)."
                                        },
                                        {
                                            "hint": "\"Use an iterative approach to locate the node. Use the same deletion logic as the recursive method but with a loop.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The inorder successor (smallest node in the right subtree) or inorder predecessor (largest node in the left subtree) ensures that the BST remains valid while maintaining its properties.",
                                            "question": "Why do we replace the node with its inorder successor or predecessor?"
                                        },
                                        {
                                            "answer": "A normal binary tree does not have ordering constraints, so we can delete any node without maintaining order. In a BST, we must carefully restructure after deletion to keep it sorted.",
                                            "question": "How does this differ from deletion in a normal binary tree?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If a balanced tree (like an AVL Tree) is used, it will self-balance after deletion. If a standard BST is used, it may become skewed, requiring rebalancing.",
                                            "question": "How does this operation affect tree balance?"
                                        },
                                        {
                                            "answer": "Pass a list of keys and call the deletion function iteratively for each value, ensuring the tree remains valid.",
                                            "question": "How would you modify the solution to delete multiple values at once?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_kthsmallestandlargestelementinbst",
                                "problem_name": "Kth Smallest and Largest element in BST",
                                "problem_slug": "kth-smallest-and-largest-element-in-bst",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "GE Healthcare",
                                        "Zomato",
                                        "Cloudflare",
                                        "Medtronic",
                                        "Swiggy",
                                        "Shopify",
                                        "Robinhood",
                                        "IBM",
                                        "Johnson & Johnson",
                                        "Alibaba",
                                        "Cerner",
                                        "Flipkart",
                                        "Bungie",
                                        "Lyft",
                                        "Electronic Arts",
                                        "PayPal",
                                        "Visa",
                                        "Red Hat",
                                        "Roche",
                                        "Boston Consulting Group",
                                        "Mastercard",
                                        "Activision Blizzard",
                                        "Reddit",
                                        "JPMorgan Chase",
                                        "American Express",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This kind of problem is often encountered in databases and data analytics frameworks where sorting and querying operations are commonly performed. For example, finding the 'kth' smallest or largest value in a data set is a very common requirement in reporting, where you may want to find things like the top three sales results or the lowest five temperatures recorded. Binary Search Trees (BST) are frequently used in these contexts due to their efficient search, insert and delete operations. Moreover, Databases can store index keys in a BST format to optimize search time.",
                                    "hints": [
                                        {
                                            "hint": "Perform an inorder traversal while maintaining a counter. Stop when the k-th smallest element is found. Similarly, for k-th largest, perform a reverse inorder traversal."
                                        },
                                        {
                                            "hint": "Perform a full inorder traversal and store values in an array. The k-th smallest is at index k-1, and the k-th largest is at index n-k."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "No, because inorder traversal finds only the smallest values first, while reverse inorder finds largest values first. We need two separate traversals.",
                                            "question": "Can we find both k-th smallest and k-th largest in a single traversal?"
                                        },
                                        {
                                            "answer": "In a balanced BST (AVL, Red-Black Tree), searching for the k-th element takes O(log n + k).\nIn a skewed BST, the worst-case time complexity is O(n).",
                                            "question": "How does tree balancing affect performance?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, by maintaining a count of nodes in each subtree, we can skip unnecessary traversals. This reduces average complexity to O(log n) in a balanced BST.",
                                            "question": "Can we optimize finding the k-th smallest/largest using a count property?"
                                        },
                                        {
                                            "answer": "The median of a BST is the n/2-th smallest element. Finding the median efficiently is a direct application of this problem.",
                                            "question": "How does this relate to median finding in BSTs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_checkifatreeisabstornot",
                                "problem_name": "Check if a tree is a BST or not",
                                "problem_slug": "check-if-a-tree-is-a-bst-or-not",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Medtronic",
                                        "HCL Technologies",
                                        "Ubisoft",
                                        "PwC",
                                        "Red Hat",
                                        "Uber",
                                        "Visa",
                                        "Shopify",
                                        "Qualcomm",
                                        "American Express",
                                        "Pinterest",
                                        "Ernst & Young",
                                        "Intel",
                                        "Roche",
                                        "Reddit",
                                        "Goldman Sachs",
                                        "OYO Rooms",
                                        "eBay",
                                        "Morgan Stanley",
                                        "Robinhood",
                                        "Johnson & Johnson",
                                        "PayPal",
                                        "Bungie",
                                        "Nutanix",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: Checking if a binary tree is a binary search tree (BST) is not just a theoretical problem, but has practical applications in various software technologies. Databases can utilize BSTs for indexing purposes, allowing them to perform search, insert, delete operations efficiently. Therefore, understanding and validating BSTs are critical processes in ensuring integrity and performance in database systems. Likewise, in languages like C++ and Java, BSTs underlie certain container types (eg. TreeMap, TreeSet in Java, and set, multiset, map, multimap in C++) offering fast lookup, addition and removal of items. This problem's solution can contribute to performance optimization of these containers.",
                                    "hints": [
                                        {
                                            "hint": "Recursively check. The left subtree must be within (min_val, root.val). The right subtree must be within (root.val, max_val). If a node violates the constraint, return False."
                                        },
                                        {
                                            "hint": "\"Perform inorder traversal (Left  Root  Right). Store previous node value while traversing. If current node value  previous node value, return False.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If BST allows duplicates, ensure they appear only on the left or right subtree consistently.\nIf duplicates are not allowed, modify checks to ensure strictly increasing order.",
                                            "question": "How does this algorithm handle duplicate values?"
                                        },
                                        {
                                            "answer": "BST does not require balance, only ordering constraints. Unbalanced trees are still valid BSTs if ordering holds.",
                                            "question": "What happens if the tree is unbalanced?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For an array-based tree, check arr[i] > arr[(i-1)/2] for all nodes. However, this works only for complete BSTs, not general BSTs.",
                                            "question": "How would this change if the tree was stored as an array (heap representation)?"
                                        },
                                        {
                                            "answer": "BST validation only checks ordering, while AVL tree validation also checks height balance (|left_height - right_height|  1).",
                                            "question": "What is the difference between BST validation and AVL tree validation?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_lcainbst",
                                "problem_name": "LCA in BST",
                                "problem_slug": "lca-in-bst",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "Epic Games",
                                        "AMD",
                                        "Pinterest",
                                        "Western Digital",
                                        "Uber",
                                        "Walmart",
                                        "Electronic Arts",
                                        "HashiCorp",
                                        "HCL Technologies",
                                        "Unity Technologies",
                                        "Visa",
                                        "Twilio",
                                        "KPMG",
                                        "Bloomberg",
                                        "PayPal",
                                        "Swiggy",
                                        "Wayfair",
                                        "Rockstar Games",
                                        "Roblox",
                                        "Robinhood",
                                        "McKinsey & Company",
                                        "Databricks",
                                        "eBay",
                                        "American Express",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem is very relevant in the field of web technologies, particularly in DOM (Document Object Model) manipulation which is a critical component of web development. An HTML document can also be viewed as a tree structure (though not a binary tree, however), and finding common ancestors between two nodes can be applied for example, when trying to determine the closest common parent of two different elements on a page for DOM manipulation tasks such as styling, event handling or even debugging!",
                                    "hints": [
                                        {
                                            "hint": "\"If both p and q are smaller than root.val, LCA must be in the left subtree: LCA(root,p,q)=LCA(root.left,p,q)ifp.val,q.val<root.val If both p and q are greater, LCA is in the right subtree: LCA(root,p,q)=LCA(root.right,p,q)ifp.val,q.val>root.val Otherwise, root is the split point, meaning root is the LCA.\""
                                        },
                                        {
                                            "hint": "\"By Iterative Approach (Optimized for Space) Start at the root and traverse down the BST until you find the split point. The first node where p and q are on different sides is the LCA.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In a BST, if both values are less than root, they must be in the left subtree.",
                                            "question": " Why do we traverse left when both p and q are smaller?"
                                        },
                                        {
                                            "answer": "The LCA is the first node that contains both nodes in its subtree, so if one node is the ancestor of the other, return it.",
                                            "question": "What if one of the nodes is the LCA itself?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a standard LCA approach by checking for p and q in left/right subtrees without BST constraints.",
                                            "question": "How would you modify this solution if the tree were not a BST?"
                                        },
                                        {
                                            "answer": "The worst-case time complexity becomes O(n), so consider self-balancing BSTs (e.g., AVL, Red-Black trees).",
                                            "question": " What if the BST were unbalanced?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_constructabstfromapreordertraversal",
                                "problem_name": "Construct a BST from a preorder traversal",
                                "problem_slug": "construct-a-bst-from-a-preorder-traversal",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "NVIDIA",
                                        "Reddit",
                                        "Byju's",
                                        "PwC",
                                        "eBay",
                                        "Seagate Technology",
                                        "Salesforce",
                                        "Teladoc Health",
                                        "Stripe",
                                        "Morgan Stanley",
                                        "Oracle",
                                        "Bungie",
                                        "Visa",
                                        "Deloitte",
                                        "AMD",
                                        "Walmart",
                                        "PayPal",
                                        "Alibaba",
                                        "Airbnb",
                                        "Bloomberg",
                                        "Splunk",
                                        "Robinhood",
                                        "Texas Instruments",
                                        "Databricks",
                                        "Philips Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The practical application of this programming problem is most prevalent in the development of databases and search engines. Binary Search Trees (BSTs) are extensively used to streamline searching and sorting processes. For instance, in a database with millions of records, using BSTs significantly reduces the time complexity to find a specific record. Also, the concept of preorder traversal is used in JavaScript frameworks like React to navigate around the Document Object Model (DOM). The knowledge and ability to construct a BST from a given preorder traversal data can help in optimizing tasks related to searching, insertion, and deletion in the real-world software applications.",
                                    "hints": [
                                        {
                                            "hint": "\"Construct the root using preorder[0]. Recursively divide preorder into left and right subtrees: Elements smaller than root form the left subtree. Elements greater than root form the right subtree. Build the left and right subtrees recursively.\""
                                        },
                                        {
                                            "hint": "\"Use a monotonic decreasing stack to keep track of parent nodes. Iterate over preorder, and for each value: If its smaller than the top of the stack, its the left child. If its greater, pop elements until finding its parent, then make it the right child.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The first element greater than root in preorder marks the start of the right subtree.",
                                            "question": "How do we efficiently determine left and right subtrees?"
                                        },
                                        {
                                            "answer": "No, because inorder traversal does not preserve hierarchy (only sorts elements).",
                                            "question": "Can this problem be solved using inorder traversal?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use reverse traversal (Right  Left  Root) and construct in reverse.",
                                            "question": "How would you construct a BST from its postorder traversal?"
                                        },
                                        {
                                            "answer": "Impossible unless we also have preorder/postorder, as inorder does not provide hierarchy.",
                                            "question": "How would you construct a BST from its inorder traversal?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_medium_inordersuccessorandpredecessorinbst",
                                "problem_name": "Inorder successor and predecessor in BST",
                                "problem_slug": "inorder-successor-and-predecessor-in-bst",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "Ernst & Young",
                                        "Wayfair",
                                        "Unity Technologies",
                                        "Boston Consulting Group",
                                        "Morgan Stanley",
                                        "NVIDIA",
                                        "Robinhood",
                                        "Ubisoft",
                                        "ARM",
                                        "MongoDB",
                                        "Alibaba",
                                        "Epic Games",
                                        "Electronic Arts",
                                        "Philips Healthcare",
                                        "Lyft",
                                        "Qualcomm",
                                        "OYO Rooms",
                                        "HashiCorp",
                                        "Deloitte",
                                        "Teladoc Health",
                                        "Bungie",
                                        "Zynga",
                                        "Snowflake",
                                        "Salesforce",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The problem of finding Inorder predecessor and successor in a Binary Search Tree (BST) can be seen in many real-world applications such as databases or software that deal with a large set of sorted data, allowing quick insertion, deletion and lookup operations. For instance, popular database management systems like Oracle or MySQL use varieties of tree data structures such as B-Tree, B+ Tree (an extension of BST). When you need to find nearest lesser (predecessor) and nearest greater (successor) values to a particular key, applications can use Inorder traversal method, similar to the above mentioned problem, within such tree-based structures to get the result efficiently. It's a common operation, particularly in navigating, organizing and managing hierarchical or ordered information.",
                                    "hints": [
                                        {
                                            "hint": "\"If key exists in the BST and has a left subtree, the predecessor is the rightmost (max) node in its left subtree. Otherwise, traverse the BST: If root.val < key, update predecessor = root.val and move right. Otherwise, move left.\""
                                        },
                                        {
                                            "hint": "\"If key exists and has a right subtree, the successor is the leftmost (min) node in its right subtree. Otherwise, traverse the BST: If root.val > key, update successor = root.val and move left. Otherwise, move right.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Because in a BST:\nLeft subtree contains smaller values  Candidate for predecessor.\nRight subtree contains larger values  Candidate for successor.",
                                            "question": " Why do we move left for the successor and right for the predecessor?"
                                        },
                                        {
                                            "answer": "Yes, but it takes O(n) time, while BST traversal is O(h) (log n for balanced BSTs).",
                                            "question": "Can this problem be solved using inorder traversal?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Perform inorder traversal and track predecessor and successor manually.",
                                            "question": "How would you modify this solution for a general Binary Tree (not BST)?"
                                        },
                                        {
                                            "answer": "The approach mimics binary search, as we narrow down the predecessor and successor",
                                            "question": "How does this problem relate to binary search?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearchtrees_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_faqs_binarysearchtreeiterator",
                                "problem_name": "BST iterator",
                                "problem_slug": "bst-iterator",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "Walmart",
                                        "Zoho",
                                        "Etsy",
                                        "Lyft",
                                        "HashiCorp",
                                        "Roblox",
                                        "Cerner",
                                        "Optum",
                                        "Activision Blizzard",
                                        "AMD",
                                        "Shopify",
                                        "Airbnb",
                                        "Twilio",
                                        "Seagate Technology",
                                        "Cloudflare",
                                        "Wayfair",
                                        "Robinhood",
                                        "Rakuten",
                                        "Rockstar Games",
                                        "PayPal",
                                        "Alibaba",
                                        "Splunk",
                                        "JPMorgan Chase",
                                        "NVIDIA",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This concept of BSTIterator is widely used in databases and file systems. In such systems, data is often stored in a binary search tree format to allow efficient search, insertion, and deletion operations. An in-order BST iterator, like the one in the problem, allows developers to efficiently traverse through this data in a sorted manner, which can markedly improve the performance of operations like range queries, sorting and displaying data. This functionality is typically offered by databases' 'cursor' abstraction, and is fundamental to SQL operations.",
                                    "hints": [
                                        {
                                            "hint": "\"Perform an inorder traversal during initialization and store the elements in an array. next() simply returns the next element from the stored list. hasNext() checks if more elements are available.\""
                                        },
                                        {
                                            "hint": "\"Instead of storing all elements, use a stack to simulate recursion. Push all left children first. When next() is called: Pop the top element. Push its right subtrees leftmost path into the stack.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Optimizes space from O(n) to O(h), where h is the tree height.\nEnsures O(1) average time complexity for next().",
                                            "question": "Why do we use a stack instead of storing the entire inorder traversal?"
                                        },
                                        {
                                            "answer": "Inorder traversal = Left  Root  Right, so we process leftmost nodes first.",
                                            "question": "Why do we push only left children initially?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use two stacks (one for normal and one for reversed inorder).",
                                            "question": "How would you modify this iterator to support prev() for reverse traversal?"
                                        },
                                        {
                                            "answer": "Yes, but inorder traversal would not guarantee sorted order.",
                                            "question": "Can this iterator be extended to work on general binary trees?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_faqs_twosuminbst",
                                "problem_name": "Two sum in BST",
                                "problem_slug": "two-sum-in-bst",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Siemens Healthineers",
                                        "Unity Technologies",
                                        "HCL Technologies",
                                        "Bungie",
                                        "ARM",
                                        "Seagate Technology",
                                        "Freshworks",
                                        "Rakuten",
                                        "Cerner",
                                        "Optum",
                                        "Intel",
                                        "Visa",
                                        "Shopify",
                                        "Instacart",
                                        "Square",
                                        "Medtronic",
                                        "Bain & Company",
                                        "Western Digital",
                                        "KPMG",
                                        "Salesforce",
                                        "Johnson & Johnson",
                                        "Airbnb",
                                        "Twilio",
                                        "AMD",
                                        "Mastercard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is essentially the underpinning of a lot of algorithmic problem-solving and decision-making that goes on in real-time applications. A fun fact about this problem is that it is actually used in financial trading software. In these systems, a balance needs to be maintained and therefore, it is often required to find two numbers in a dataset that sum to a certain value. This helps in maintaining that balance and making sure that the trading activities always net out. This operation has to be very fast, and binary search trees are one of the most efficient data structures for this purpose.",
                                    "hints": [
                                        {
                                            "hint": "\"Perform inorder traversal and store elements in a hash set. For each node x, check if k - x exists in the hash set. If found, return True, otherwise continue.\""
                                        },
                                        {
                                            "hint": "\"Use BST Iterator (next()) for inorder traversal (ascending order). Use Reverse BST Iterator (prev()) for reverse inorder (descending order). Compare smallest + largest using two iterators.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BST inorder traversal gives a sorted array, which allows two-pointer or binary search optimizations.",
                                            "question": "Why use inorder traversal?"
                                        },
                                        {
                                            "answer": "Each node is processed only once, and set lookups are O(1) on average.",
                                            "question": "Why does the hash set approach work in O(n) time?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store all valid (x, k-x) pairs in a set.",
                                            "question": "How would you modify this solution to return all unique pairs?"
                                        },
                                        {
                                            "answer": "BST provides structure, reducing search complexity.",
                                            "question": " How does this compare to finding k sum pairs in an unsorted array?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_faqs_correctbstwithtwonodesswapped",
                                "problem_name": "Correct BST with two nodes swapped",
                                "problem_slug": "correct-bst-with-two-nodes-swapped",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Epic Systems",
                                        "Teladoc Health",
                                        "Flipkart",
                                        "Riot Games",
                                        "Optum",
                                        "Alibaba",
                                        "Visa",
                                        "ARM",
                                        "KPMG",
                                        "JPMorgan Chase",
                                        "Rockstar Games",
                                        "OYO Rooms",
                                        "Shopify",
                                        "Western Digital",
                                        "Goldman Sachs",
                                        "Splunk",
                                        "Robinhood",
                                        "AMD",
                                        "IBM",
                                        "Instacart",
                                        "GE Healthcare",
                                        "McKinsey & Company",
                                        "HashiCorp",
                                        "HCL Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem mirrors a real-world issue that can occur in database recovery. Databases can sometimes experience inconsistencies due to errors, mistaken swaps, and so on. Programmers would need to rectify these inconsistencies without causing more errors by using algorithms similar to the solution of this problem. In fact, binary search trees, like the ones mentioned in the problem, are frequently used to store data in databases due to their efficient search, insert, and delete operations!",
                                    "hints": [
                                        {
                                            "hint": "\"As we traverse in inorder (Left  Root  Right), the correct sequence should be in ascending order. If prev.val > curr.val, we found an out-of-order pair.\""
                                        },
                                        {
                                            "hint": "\"Perform Morris Traversal to detect swapped nodes in O(1) space. Identify two misplaced nodes during traversal. Swap their values to restore BST properties.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Because only two values were swapped, exactly two positions in inorder traversal will be incorrect.",
                                            "question": " Why are there exactly two misplaced nodes?"
                                        },
                                        {
                                            "answer": "Swapping nodes changes tree structure, but swapping only values restores the BST without modifications.",
                                            "question": "Why do we swap values instead of swapping nodes?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Sort the inorder array and perform minimum swaps.",
                                            "question": " How would you modify the solution if nodes were swapped randomly, not just two?"
                                        },
                                        {
                                            "answer": "Yes, using stack-based inorder traversal instead of recursion.",
                                            "question": "Can this be solved iteratively using a stack?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "binarysearchtrees_binarysearchtrees_faqs_largestbstinbinarytree",
                                "problem_name": "Largest BST in Binary Tree",
                                "problem_slug": "largest-bst-in-binary-tree",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "GE Healthcare",
                                        "Cloudflare",
                                        "Roche",
                                        "Epic Systems",
                                        "Texas Instruments",
                                        "Snowflake",
                                        "Bain & Company",
                                        "Zomato",
                                        "Philips Healthcare",
                                        "Broadcom",
                                        "OYO Rooms",
                                        "Boston Consulting Group",
                                        "Databricks",
                                        "McKinsey & Company",
                                        "Zoho",
                                        "JPMorgan Chase",
                                        "Visa",
                                        "Twilio",
                                        "Pinterest",
                                        "Rockstar Games",
                                        "Optum",
                                        "Qualcomm",
                                        "HashiCorp",
                                        "Chewy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem taps into the core usage of the Binary Search Tree (BST) in software development. Real-world applications of BSTs include database systems, such as MySQL, where managing and querying large amounts of data efficiently is a key requirement. By ensuring certain subtrees maintain the properties of a BST, operations like searching, insertion, and deletion can be performed quicker, enhancing the overall performance. This problem of identifying the largest BST in a binary tree echoes the optimization tasks often required in real-world applications.",
                                    "hints": [
                                        {
                                            "hint": "\"For each node: Recursively check left and right subtrees. Determine min, max, size of the largest BST subtree found. If the node satisfies BST conditions, update the maximum BST size.\""
                                        },
                                        {
                                            "hint": "\"Perform postorder traversal to check each subtree. Track min, max, size of the largest BST at each node. Return the largest BST size found. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Postorder (Left  Right  Root) ensures that we process children first, making BST checks easier.",
                                            "question": "Why do we use postorder traversal?"
                                        },
                                        {
                                            "answer": "Postorder (Left  Right  Root) ensures that we process children first, making BST checks easier.",
                                            "question": "Why do we use postorder traversal?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a pointer to the root of the largest BST found.",
                                            "question": "How would you modify this solution to return the actual BST subtree instead of just its size?"
                                        },
                                        {
                                            "answer": "Allow equal values only on a specific side (left or right) based on constraints.",
                                            "question": "How would this change if duplicate values were allowed in the BST?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "binarysearchtrees_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 4,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "range_sum_in_bst",
                                "problem_name": "Range Sum in BST",
                                "problem_slug": "range-sum-in-bst",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "great_tree",
                                "problem_name": "Great Tree",
                                "problem_slug": "great-tree",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "heaps",
                "category_name": "Heaps",
                "category_slug": "heaps",
                "category_rank": 13,
                "subcategories": [
                    {
                        "subcategory_id": "heaps_implementationandtheory",
                        "subcategory_name": "Theory and Implementation",
                        "subcategory_slug": "theory-and-implementation",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_heaps(theoryvideo)",
                                "problem_name": "Heaps (Theory Video)",
                                "problem_slug": "heaps-theory",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_heapifyalgorithm",
                                "problem_name": "Heapify Algorithm",
                                "problem_slug": "heapify-algorithm",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Swiggy",
                                        "Robinhood",
                                        "Flipkart",
                                        "Walmart",
                                        "Intel",
                                        "Texas Instruments",
                                        "Western Digital",
                                        "Byju's",
                                        "Teladoc Health",
                                        "Freshworks",
                                        "Cerner",
                                        "NVIDIA",
                                        "Chewy",
                                        "GE Healthcare",
                                        "Bloomberg",
                                        "Target",
                                        "Unity Technologies",
                                        "Zynga",
                                        "Lyft",
                                        "Bungie",
                                        "KPMG",
                                        "Docker",
                                        "PwC",
                                        "American Express",
                                        "Deloitte",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Compare the node with its parent at parent = (ind-1) // 2. If nums[ind] < nums[parent], swap them and move up recursively. Stop when ind == 0 (root) or no more violations exist.\""
                                        },
                                        {
                                            "hint": "\"Compare the node with its left child at 2*ind + 1 and right child at 2*ind + 2. Swap with the smallest child if nums[ind] is greater. Recursively move down until heap property is restored.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the new value is smaller, it may violate the parent rule  heapify up.\nIf the new value is larger, it may violate the child rule  heapify down.",
                                            "question": " Why do we sometimes heapify up and sometimes heapify down?"
                                        },
                                        {
                                            "answer": "If the new value does not violate heap rules, no changes are required.",
                                            "question": "What if we set a value but the heap remains valid?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a Fibonacci Heap or Lazy Heap Updates to batch modifications and reduce complexity.",
                                            "question": "How can we optimize updates if they happen frequently?"
                                        },
                                        {
                                            "answer": "Heapify operations rely on indexed access, so arrays are the best choice. Using a linked list would increase traversal time to O(n) instead of O(log n).",
                                            "question": " How would you implement this if the heap was stored in a different data structure (e.g., linked list)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_buildheapfromagivenarray",
                                "problem_name": "Build heap from a given Array",
                                "problem_slug": "build-heap-from-a-given-array",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Etsy",
                                        "Electronic Arts",
                                        "PwC",
                                        "Databricks",
                                        "Zynga",
                                        "Zomato",
                                        "Cloudflare",
                                        "Philips Healthcare",
                                        "Morgan Stanley",
                                        "Ubisoft",
                                        "Snowflake",
                                        "Roche",
                                        "Zoho",
                                        "Docker",
                                        "Robinhood",
                                        "Dropbox",
                                        "Optum",
                                        "Uber",
                                        "PayPal",
                                        "Walmart",
                                        "HashiCorp",
                                        "Ernst & Young",
                                        "Red Hat",
                                        "Swiggy",
                                        "Boston Consulting Group",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "For each node at index i. Find the left child at 2*i + 1. Find the right child at 2*i + 2."
                                        },
                                        {
                                            "hint": "\"Swap with the smallest child if nums[i] > nums[child]. Recursively heapify down until the heap property is restored.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Nodes beyond (n//2) - 1 are leaf nodes, which already satisfy the heap property.\nWe only need to heapify down from non-leaf nodes.",
                                            "question": "Why do we start heapifying from (n//2) - 1 instead of index 0?"
                                        },
                                        {
                                            "answer": "Heapify down efficiently restores the heap from the bottom up.\nHeapify up is useful for inserting elements one by one but is less efficient for building a heap.",
                                            "question": "Why is heapify down used instead of heapify up?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Heapifying requires O(n log n) traversal time in a linked list, making it inefficient.\nArrays are preferred for heaps due to direct index-based access.",
                                            "question": "How does this work if the heap is stored in a linked list instead of an array?"
                                        },
                                        {
                                            "answer": "Instead of placing the smallest child at the top, place the largest child during heapify.\nChange comparisons from nums[i] > nums[child] to nums[i] < nums[child].",
                                            "question": "How would you modify this to build a max-heap instead?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_implementminheap",
                                "problem_name": "Implement Min Heap",
                                "problem_slug": "implement-min-heap",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Epic Systems",
                                        "MongoDB",
                                        "Docker",
                                        "Swiggy",
                                        "Epic Games",
                                        "DoorDash",
                                        "Uber",
                                        "Boston Consulting Group",
                                        "Medtronic",
                                        "Morgan Stanley",
                                        "Bloomberg",
                                        "Freshworks",
                                        "GE Healthcare",
                                        "AMD",
                                        "Snowflake",
                                        "Twilio",
                                        "Reddit",
                                        "Johnson & Johnson",
                                        "Bain & Company",
                                        "American Express",
                                        "Instacart",
                                        "Lyft",
                                        "ARM",
                                        "Broadcom",
                                        "Roche",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "The heap is usually stored in an array. An empty list can represent an initial empty heap."
                                        },
                                        {
                                            "hint": "Add x to the end of the array. The smallest element is always at index 0. Swap the root (minimum element) with the last element. Return the length of the array representing the heap. Return True if the array is empty, otherwise False."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Insertion: New elements start at the bottom, so we move up to fix order.\nDeletion: The last element is moved to the top, so we move down to fix order.",
                                            "question": "Why do we heapify-up on insertion but heapify-down on deletion?"
                                        },
                                        {
                                            "answer": "Insertion: New elements start at the bottom, so we move up to fix order.\nDeletion: The last element is moved to the top, so we move down to fix order.",
                                            "question": "Why do we heapify-up on insertion but heapify-down on deletion?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a self-balancing heap to maintain real-time priority ordering.",
                                            "question": " How would this be implemented for a dynamic streaming dataset (priority queue)?"
                                        },
                                        {
                                            "answer": "Instead of 2*i+1 and 2*i+2, use d*i+1, d*i+2, ..., d*i+d for children.\nHeapify operations check among d children instead of 2.",
                                            "question": "How does this extend to a d-ary heap (e.g., ternary heap with 3 children per node)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_implementmaxheap",
                                "problem_name": "Implement Max Heap",
                                "problem_slug": "implement-max-heap",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Airbnb",
                                        "McKinsey & Company",
                                        "Rockstar Games",
                                        "Splunk",
                                        "Swiggy",
                                        "Western Digital",
                                        "Roche",
                                        "Byju's",
                                        "MongoDB",
                                        "Ernst & Young",
                                        "Reddit",
                                        "Visa",
                                        "Chewy",
                                        "Unity Technologies",
                                        "JPMorgan Chase",
                                        "Zomato",
                                        "Nutanix",
                                        "Optum",
                                        "Walmart",
                                        "Goldman Sachs",
                                        "PayPal",
                                        "Cloudflare",
                                        "Flipkart",
                                        "Cerner",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Since the maximum value is the largest number stored, it must be found by scanning the heap (worst case O(n)). Alternatively, maintain a secondary max pointer while inserting elements (if extra space is allowed).\""
                                        },
                                        {
                                            "hint": "\"Find the largest value in the heap (brute-force O(n) scan). Swap it with the last element, remove it, and heapify down to restore the min-heap order.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A Min-Heap naturally orders values in ascending order. By negating values, we store the largest values as the smallest negative numbers, effectively reversing the order while still using min-heap operations.",
                                            "question": "Why do we use negative values for max-heap simulation?"
                                        },
                                        {
                                            "answer": "Since we negate values, negative inputs will be flipped to positive internally, ensuring heap operations work as expected.",
                                            "question": "What happens if all values are negative?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of negating values, use a direct Max-Heap (heapify-up and heapify-down adjusted for > instead of <).",
                                            "question": " How would you modify this for a standard Max-Heap instead of a Min-Heap?"
                                        },
                                        {
                                            "answer": "Instead of 2*i+1 and 2*i+2, children are at di + 1, di + 2, ..., d*i + d.\nHeapify down must consider d children instead of 2.",
                                            "question": "How does this extend to a d-ary heap (e.g., ternary heap with 3 children per node)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_checkifanarrayrepresentsaminheap",
                                "problem_name": "Check if an array represents a min heap",
                                "problem_slug": "check-if-an-array-represents-a-min-heap-",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Philips Healthcare",
                                        "OYO Rooms",
                                        "Cerner",
                                        "Optum",
                                        "KPMG",
                                        "Mastercard",
                                        "Target",
                                        "Alibaba",
                                        "Square",
                                        "Ubisoft",
                                        "Roche",
                                        "Seagate Technology",
                                        "Byju's",
                                        "Goldman Sachs",
                                        "eBay",
                                        "Ernst & Young",
                                        "Zoho",
                                        "Siemens Healthineers",
                                        "Splunk",
                                        "Freshworks",
                                        "Flipkart",
                                        "PwC",
                                        "Johnson & Johnson",
                                        "MongoDB",
                                        "DoorDash",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: Binary min-heaps play a critical role in various data-intensive applications in the software industry. They are particularly effective in designing priority queues and implementing algorithms like Dijkstra's shortest path. Also, in the network sector, binary min-heaps help to handle bandwidth management and packet scheduling in Internet routers. Thus, a function that determines the validity of a binary min-heap can act as a useful debugging tool in these scenarios, ensuring that the underlying data structure is correctly organized and functional.",
                                    "hints": [
                                        {
                                            "hint": "\"A binary min-heap is stored in array form, where: Parent of i is at (i-1) // 2. Left child of i is at 2*i + 1. Right child of i is at 2*i + 2.\""
                                        },
                                        {
                                            "hint": "\"To check if nums is a valid min-heap: Iterate through all parent nodes (indices 0 to (n//2) - 1). Compare each parent with its left and right children (if they exist). If any parent is greater than a child, return False.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A heap does not require total sorting. It only needs each parent  its children.",
                                            "question": "Why do we only check parent-child relations (nums[i]  nums[2*i+1])?"
                                        },
                                        {
                                            "answer": "BST: Left subtree < root < right subtree (strict ordering).\nHeap: Only requires parent  children, not full ordering.",
                                            "question": "How is this different from a binary search tree (BST)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of nums[i]  nums[child], check nums[i]  nums[child].",
                                            "question": " How would you check if an array represents a max-heap instead of a min-heap?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_convertminheaptomaxheap",
                                "problem_name": "Convert Min Heap to Max Heap",
                                "problem_slug": "convert-min-heap-to-max-heap",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Activision Blizzard",
                                        "Broadcom",
                                        "Visa",
                                        "Johnson & Johnson",
                                        "Lyft",
                                        "Epic Games",
                                        "Bain & Company",
                                        "Intel",
                                        "Freshworks",
                                        "HCL Technologies",
                                        "Snowflake",
                                        "Splunk",
                                        "Micron Technology",
                                        "Goldman Sachs",
                                        "Rockstar Games",
                                        "Riot Games",
                                        "Electronic Arts",
                                        "Epic Systems",
                                        "Ubisoft",
                                        "Cerner",
                                        "Docker",
                                        "Cloudflare",
                                        "Pinterest",
                                        "Robinhood",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concepts of min-heaps and max-heaps are used prominently in creating priority queues in software development. Priority queues are widely used in several real-world applications, like Dijkstra's algorithm for shortest path in graph problems, in load balancing and interrupt handling in an operating system, and in data compression algorithms like Huffman coding. The conversion between min-heaps and max-heaps could be beneficial in scenarios where the priority order needs to be reversed or dynamically changed in applications.",
                                    "hints": [
                                        {
                                            "hint": "\"Start from the last non-leaf node ((n//2) - 1). Apply heapify-down for each node in reverse order. Ensure that every parent is greater than its children by swapping if necessary.\""
                                        },
                                        {
                                            "hint": "\"Find the left child at 2*i + 1. Find the right child at 2*i + 2. Swap with the largest child if nums[i] < nums[child]. Recursively heapify down until the heap property is restored.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Leaf nodes (from n//2 onward) are already valid heaps (no children to compare).\nOnly non-leaf nodes need to be heapified down.",
                                            "question": "Why do we start heapifying from (n//2) - 1 instead of 0?"
                                        },
                                        {
                                            "answer": "Since both min-heap and max-heap use the same array structure, we only modify values in-place.",
                                            "question": "Why does this work in-place without extra space?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Apply heapify-down in reverse order (swap with the smallest child instead of the largest).",
                                            "question": " How would you modify this to convert a max-heap into a min-heap?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_heapsort",
                                "problem_name": "Heap Sort",
                                "problem_slug": "heap-sort",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Electronic Arts",
                                        "Databricks",
                                        "Twilio",
                                        "Intel",
                                        "DoorDash",
                                        "Roblox",
                                        "Activision Blizzard",
                                        "Alibaba",
                                        "PayPal",
                                        "Etsy",
                                        "Oracle",
                                        "Seagate Technology",
                                        "Ubisoft",
                                        "Wayfair",
                                        "Docker",
                                        "PwC",
                                        "McKinsey & Company",
                                        "Rockstar Games",
                                        "MongoDB",
                                        "Stripe",
                                        "OYO Rooms",
                                        "Swiggy",
                                        "Reddit",
                                        "Uber",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Convert nums into a max-heap (largest element at root). Start heapifying from last non-leaf node (n//2) - 1 down to 0. Use heapify-down to maintain the heap property.\""
                                        },
                                        {
                                            "hint": "\"Swap the root (max element) with the last element. Reduce heap size and heapify-down the new root to restore heap order. Repeat until the array is sorted in non-decreasing order.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Leaf nodes (n//2 to n-1) are already valid heaps, so no need to heapify them.\nOnly non-leaf nodes need adjustment.",
                                            "question": "Why start heapifying from (n//2) - 1?"
                                        },
                                        {
                                            "answer": "Heap sort has worst-case O(n log n) complexity, while quicksort can degrade to O(n).\nHeap sort is better for nearly sorted or small arrays where recursion overhead of quicksort is expensive.",
                                            "question": "Why is heap sort preferred over quicksort in some cases?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Heap sort is inherently unstable (swaps can change relative order).\nSolution: Store (value, index) pairs and sort based on original indices for stability.",
                                            "question": "Can heap sort be modified to be stable?"
                                        },
                                        {
                                            "answer": "Heapify is inefficient for linked lists (O(n log n) traversal).\nUse merge sort instead, as its more cache-friendly.",
                                            "question": "How would you modify heap sort for a linked list?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "heaps_heaps_implementationandtheory_k-thlargestelementinanarray",
                                "problem_name": "K-th Largest element in an array",
                                "problem_slug": "k-th-largest-element-in-an-array",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Epic Games",
                                        "Cloudflare",
                                        "Optum",
                                        "Johnson & Johnson",
                                        "Cerner",
                                        "Broadcom",
                                        "Target",
                                        "Pinterest",
                                        "Salesforce",
                                        "Mastercard",
                                        "Medtronic",
                                        "Snowflake",
                                        "Stripe",
                                        "Texas Instruments",
                                        "Electronic Arts",
                                        "KPMG",
                                        "Byju's",
                                        "Rockstar Games",
                                        "Swiggy",
                                        "Qualcomm",
                                        "Morgan Stanley",
                                        "Zoho",
                                        "Goldman Sachs",
                                        "Bain & Company",
                                        "DoorDash",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept underlying the \"kth largest element\" problem is widely used in real-time analytics applications and Big Data processing, where one might need to find the top k values out of massive streams of data. This concept is used in systems used by massive social media platforms where they need to identify the top trending topics, hashtags, or posts at any given time. Similarly, this same principle is used in music streaming apps to find the top k most listened songs out of millions of songs available.",
                                    "hints": [
                                        {
                                            "hint": "\"Use a min-heap of size k. Insert the first k elements into the heap.  The heaps root (smallest in the heap) is the k-th largest element.\""
                                        },
                                        {
                                            "hint": "\"Convert the entire array into a max-heap (O(n)). Extract k elements using heapify-down (O(k log n)). The k-th extracted element is the k-th largest.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A min-heap of size k tracks the top k largest elements, making extraction O(1).\nA max-heap stores everything, requiring O(k log n) extraction.",
                                            "question": "Why use a min-heap for k-th largest instead of max-heap?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Perform reverse inorder traversal, counting elements until reaching k.\nTime Complexity: O(h + k)  O(log n + k) for balanced BSTs.",
                                            "question": "What changes for k-th largest in a BST instead of an array?"
                                        },
                                        {
                                            "answer": "QuickSelect is O(n) on average but O(n)` worst case.\nMedian of Medians ensures O(n) worst case but is more complex to implement.",
                                            "question": "How does QuickSelect compare to Median of Medians for selection problems?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "heaps_faqs",
                        "subcategory_name": "FAQs",
                        "subcategory_slug": "faqs",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "heaps_heaps_faqs_kthlargestelementinastreamofrunningintegers",
                                "problem_name": "Kth largest element in a stream of running integers",
                                "problem_slug": "kth-largest-element-in-a-stream-of-running-integers",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Snowflake",
                                        "Zomato",
                                        "Rockstar Games",
                                        "Square",
                                        "AMD",
                                        "Wayfair",
                                        "Ernst & Young",
                                        "Philips Healthcare",
                                        "Visa",
                                        "Flipkart",
                                        "Freshworks",
                                        "Morgan Stanley",
                                        "Teladoc Health",
                                        "Cloudflare",
                                        "Cerner",
                                        "PwC",
                                        "Alibaba",
                                        "Uber",
                                        "Bloomberg",
                                        "Red Hat",
                                        "Siemens Healthineers",
                                        "GE Healthcare",
                                        "Medtronic",
                                        "PayPal",
                                        "Epic Systems",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "The smallest element in the heap is the k-th largest element in the stream. Any number smaller than the heaps root is ignored. Any number larger than the root replaces it, maintaining the top k largest elements."
                                        },
                                        {
                                            "hint": "\"Insert val into the heap if the size is less than k. If the heap already has k elements, compare val with the smallest element: If val > heap[0], replace heap[0] and heapify. If val <= heap[0], discard it.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A min-heap of size k efficiently tracks the k-th largest element.\nThe root always holds the k-th largest value, avoiding full sorting.",
                                            "question": "Why use a min-heap instead of a max-heap?"
                                        },
                                        {
                                            "answer": "Sorting each time costs O(n log n), while heap operations are O(log k).\nSorting is too slow for large data streams.",
                                            "question": "Can we use sorting instead of a heap?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Stock market analysis (track top k highest prices).\nLeaderboard ranking (finding k-th highest score).\nData stream processing (analyzing incoming data efficiently).\n",
                                            "question": "How does this work in real-world applications?"
                                        },
                                        {
                                            "answer": "Use a max-heap of size k (instead of a min-heap).\nThe largest value in the max-heap is the k-th smallest.",
                                            "question": "How would you find the k-th smallest element instead?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "heaps_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest-heaps",
                        "subcategory_rank": 3,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "k_nearest_integers",
                                "problem_name": "K Nearest Integers",
                                "problem_slug": "k-nearest-integers",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "minimum_operations_to_exceed_target",
                                "problem_name": "Minimum Operations To Exceed Target",
                                "problem_slug": "minimum-operations-to-exceed-target",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "furthest_reachable_mountain",
                                "problem_name": "Furthest Reachable Mountain",
                                "problem_slug": "furthest-reachable-mountain",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "graphs",
                "category_name": "Graphs",
                "category_slug": "graph",
                "category_rank": 14,
                "subcategories": [
                    {
                        "subcategory_id": "graphs_theoryandtraversals",
                        "subcategory_name": "Theory and traversals",
                        "subcategory_slug": "theory-and-traversals",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_theoryandtraversals_introductiontograph",
                                "problem_name": "Introduction to Graph",
                                "problem_slug": "introduction-to-graph",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "graphs_graphs_theoryandtraversals_connectedcomponents",
                                "problem_name": "Connected Components",
                                "problem_slug": "connected-components",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Micron Technology",
                                        "Chewy",
                                        "Teladoc Health",
                                        "JPMorgan Chase",
                                        "OYO Rooms",
                                        "NVIDIA",
                                        "Cerner",
                                        "Visa",
                                        "Roche",
                                        "Siemens Healthineers",
                                        "Reddit",
                                        "Goldman Sachs",
                                        "Mastercard",
                                        "Salesforce",
                                        "Red Hat",
                                        "Stripe",
                                        "AMD",
                                        "Databricks",
                                        "Johnson & Johnson",
                                        "Zynga",
                                        "PayPal",
                                        "Activision Blizzard",
                                        "Walmart",
                                        "Optum",
                                        "Epic Systems",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One real-world application of this problem is in the realm of social networking platforms. These platforms, such as Facebook or LinkedIn, represent users as nodes(vertices) and their relationships as edges. The algorithm to find connected components can identify clusters of users who are all interconnected, essentially revealing user communities and helping improve friend recommendations or targeted advertising. For example, if all your existing friends form a connected component, it's highly likely that a recommendation from this group will be a valid friendship suggestion. The 'connected components' has immense practical significance in the area of social network analysis.",
                                    "hints": [
                                        {
                                            "hint": "Maintain a boolean array visited[V], where visited[i] = True means the node has already been counted in a component. Start DFS/BFS from an unvisited node, marking all reachable nodes in that component as visited."
                                        },
                                        {
                                            "hint": "Another approach is Union-Find (Disjoint Set Union) to keep track of components. Initially, each node is its own component. For each edge (a, b), merge the sets containing a and b. The number of unique parents in the DSU structure gives the number of components."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It visits all nodes in a component before moving to another, ensuring each DFS/BFS call represents one full component.",
                                            "question": "Why does DFS/BFS correctly count the number of components?"
                                        },
                                        {
                                            "answer": "The algorithm still works; each disconnected part will be counted as a separate component.",
                                            "question": " What if the graph is disconnected?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Convert the edge list into an adjacency list before performing DFS/BFS.",
                                            "question": "How would this change if the graph was stored as an edge list instead of an adjacency list?"
                                        },
                                        {
                                            "answer": "Use Path Compression and Union by Rank to speed up the merging process to nearly O(1) per operation.",
                                            "question": "How would you optimize Union-Find for large graphs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_theoryandtraversals_traversaltechniques",
                                "problem_name": "Traversal Techniques",
                                "problem_slug": "traversal-techniques",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Intel",
                                        "Twilio",
                                        "Swiggy",
                                        "MongoDB",
                                        "JPMorgan Chase",
                                        "Alibaba",
                                        "Broadcom",
                                        "Shopify",
                                        "Boston Consulting Group",
                                        "Cloudflare",
                                        "Target",
                                        "Etsy",
                                        "Unity Technologies",
                                        "Stripe",
                                        "Roche",
                                        "Johnson & Johnson",
                                        "Dropbox",
                                        "Splunk",
                                        "Qualcomm",
                                        "ARM",
                                        "Epic Systems",
                                        "Lyft",
                                        "Western Digital",
                                        "Deloitte",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The techniques of Depth First Search (DFS) and Breadth First Search (BFS) that this problem explores are widely used in real-world routing algorithms, like Google Maps. They need to traverse through a huge graph of roads and intersections (vertices) and find the shortest or fastest path. Moreover, DFS is also used in web-crawlers of search engines like Google to visit and index new webpages, wherein the link structure of the websites is treated as a graph.",
                                    "hints": [
                                        {
                                            "hint": "\"Use recursion (or a stack) to explore as deep as possible before backtracking. Maintain a visited array to mark visited nodes and avoid cycles. Start from vertex 0 and visit nodes in the order they appear in adj[i].\""
                                        },
                                        {
                                            "hint": "\"Use a queue to explore nodes level by level (FIFO order). Begin from 0, mark it as visited, and process all connected nodes before moving deeper. The traversal order follows the order of neighbors in adj[i].\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "DFS explores deep first, requiring backtracking, so recursion or an explicit stack is used.\nBFS explores all neighbors before moving deeper, requiring a queue (FIFO order).",
                                            "question": "Why does DFS use a stack while BFS uses a queue?"
                                        },
                                        {
                                            "answer": "DFS may revisit nodes without a visited array`, leading to infinite recursion.\nBFS correctly handles cycles by ensuring each node is processed only once.",
                                            "question": "What happens if the graph contains cycles?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use BFS, as it guarantees the shortest path in O(V + E).\nTrack parent nodes to reconstruct the path.",
                                            "question": "How would you modify DFS/BFS to find the shortest path in an unweighted graph?"
                                        },
                                        {
                                            "answer": "Maintain a recursion stack (visited[i] == True while in recursion) to detect back edges.",
                                            "question": "How would you modify DFS to detect cycles in the graph?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_traversalproblems",
                        "subcategory_name": "Traversal Problems",
                        "subcategory_slug": "traversal-problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_traversalproblems_numberofprovinces",
                                "problem_name": "Number of provinces",
                                "problem_slug": "number-of-provinces",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Rockstar Games",
                                        "GE Healthcare",
                                        "PayPal",
                                        "Zoho",
                                        "Western Digital",
                                        "Bungie",
                                        "Salesforce",
                                        "Oracle",
                                        "Activision Blizzard",
                                        "Boston Consulting Group",
                                        "Optum",
                                        "Square",
                                        "Shopify",
                                        "HashiCorp",
                                        "ARM",
                                        "Uber",
                                        "American Express",
                                        "Zynga",
                                        "Target",
                                        "Instacart",
                                        "McKinsey & Company",
                                        "Ernst & Young",
                                        "Texas Instruments",
                                        "Etsy",
                                        "Riot Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept derived from this problem, is often used in the domain of social networking applications like LinkedIn, Facebook etc. They use a similar concept in identifying 'network clusters' in their friend graph. A network cluster, in this case, could be seen as a 'province' where everyone is somehow connected. This helps in refining their recommendation systems to suggest new connections within the same network cluster and essentially grow the regional network. Algorithms with a similar foundation to this are also used in the detection of communities in various network structures.",
                                    "hints": [
                                        {
                                            "hint": "Treat each row of the adjacency matrix as a node and use DFS or BFS to explore all connected nodes starting from an unvisited city. Every time a new DFS/BFS starts, it identifies a new province (connected component)."
                                        },
                                        {
                                            "hint": "Maintain a boolean array visited[V] to track which cities have been explored. Every DFS/BFS call finds one province, so increment the province count."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, but the problem gives a matrix, so directly working with it avoids extra preprocessing.\nAdjacency lists are better when adj is sparse.",
                                            "question": "Can we use adjacency lists instead of an adjacency matrix?"
                                        },
                                        {
                                            "answer": "Union-Find quickly merges groups, reducing time complexity to nearly O(n) per operation with path compression.",
                                            "question": " How does Union-Find (Disjoint Set Union) help?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For directed graphs, strongly connected components (SCCs) should be found using Kosarajus or Tarjans Algorithm.",
                                            "question": "How would you modify this for a directed graph?"
                                        },
                                        {
                                            "answer": "Convert it into an adjacency list and use optimized BFS/DFS traversal.",
                                            "question": "How does this change if the matrix is sparse?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_numberofislands",
                                "problem_name": "Number of islands",
                                "problem_slug": "number-of-islands",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Seagate Technology",
                                        "DoorDash",
                                        "Flipkart",
                                        "Goldman Sachs",
                                        "American Express",
                                        "Databricks",
                                        "Pinterest",
                                        "Visa",
                                        "Philips Healthcare",
                                        "HashiCorp",
                                        "Electronic Arts",
                                        "Western Digital",
                                        "Wayfair",
                                        "Dropbox",
                                        "Robinhood",
                                        "Broadcom",
                                        "Uber",
                                        "Shopify",
                                        "Target",
                                        "Intel",
                                        "McKinsey & Company",
                                        "Optum",
                                        "Splunk",
                                        "AMD",
                                        "Qualcomm",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This programming problem is fundamental to the sectors of digital image processing and Geographic Information System (GIS). Recognizing \"islands\" or unique contiguous areas within an image can be used in satellite image processing and telemetry to identify separate landmasses or regions on earth. For instance, Google Maps uses similar algorithms to differentiate between various landforms. Moreover, it can also find its applications in the field of medical imaging where we may need to separate different regions, tissues or organs within the body.",
                                    "hints": [
                                        {
                                            "hint": "\"DFS (Recursive or Stack-based Iterative): Start from an unvisited '1', mark all reachable '1's as visited using DFS. Each DFS call marks an entire island. BFS (Queue-based): Similar to DFS, but uses a queue to explore all connected lands level by level.\""
                                        },
                                        {
                                            "hint": "\"Treat each '1' as an initially separate set. Merge adjacent '1' cells into one connected component using Union-Find. The number of unique components after merging gives the number of islands.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Islands can be connected diagonally, so we must check 8 directions (left, right, up, down, and 4 diagonals).",
                                            "question": " Why do we check diagonal connections?"
                                        },
                                        {
                                            "answer": "BFS is iterative (using a queue), which avoids deep recursion issues that can cause stack overflow in large grids.",
                                            "question": "Why is BFS preferred over DFS in some cases?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track the size of each island during DFS/BFS and return the maximum size found.",
                                            "question": " How can we find the largest island in the grid?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_floodfillalgorithm",
                                "problem_name": "Flood fill algorithm",
                                "problem_slug": "flood-fill-algorithm",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Alibaba",
                                        "NVIDIA",
                                        "Rockstar Games",
                                        "Zomato",
                                        "Bloomberg",
                                        "Seagate Technology",
                                        "Airbnb",
                                        "Freshworks",
                                        "eBay",
                                        "HCL Technologies",
                                        "Broadcom",
                                        "Etsy",
                                        "Twilio",
                                        "Intel",
                                        "Ubisoft",
                                        "Johnson & Johnson",
                                        "Visa",
                                        "Stripe",
                                        "Ernst & Young",
                                        "Reddit",
                                        "Flipkart",
                                        "Bungie",
                                        "Micron Technology",
                                        "Qualcomm",
                                        "Byju's",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The flood fill algorithm, as described in this problem, is widely used in graphics editing tools, such as Photoshop and GIMP, as well as in game development. For example, when you use the \"bucket fill\" tool in a painting software to change the color of a connected region, you are effectively using the flood fill algorithm. Similarly, in games like Minesweeper, the algorithm is used to reveal connected, non-mined squares.",
                                    "hints": [
                                        {
                                            "hint": "\"Start from (sr, sc), recursively explore all 4-connected pixels with the same color. Change their color to newColor and continue the process. Base Case: If a pixel is out of bounds or has a different color, stop.\""
                                        },
                                        {
                                            "hint": "\"Instead of recursion, use a queue (FIFO order) to iteratively process all pixels level by level. This avoids stack overflow issues in very large images where recursion depth might be too high.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use a visited check by marking pixels with newColor or using a boolean visited array.",
                                            "question": "How do we prevent infinite loops when filling?"
                                        },
                                        {
                                            "answer": "If image[sr][sc] == newColor, return immediately, otherwise, the function will keep modifying the same color indefinitely.",
                                            "question": "What happens if newColor is the same as the original color?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a multi-criteria flood fill, checking both color and other attributes.",
                                            "question": "How would you modify this if pixels had multiple properties (e.g., color and texture)?"
                                        },
                                        {
                                            "answer": "Yes, it can be adapted to explore all reachable paths in a maze.",
                                            "question": "Can flood fill be used for maze-solving or pathfinding?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_numberofenclaves",
                                "problem_name": "Number of enclaves",
                                "problem_slug": "number-of-enclaves",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Morgan Stanley",
                                        "Ubisoft",
                                        "Pinterest",
                                        "Salesforce",
                                        "Oracle",
                                        "Target",
                                        "Byju's",
                                        "OYO Rooms",
                                        "Siemens Healthineers",
                                        "Walmart",
                                        "Nutanix",
                                        "Philips Healthcare",
                                        "Splunk",
                                        "Zoho",
                                        "Johnson & Johnson",
                                        "Cerner",
                                        "Stripe",
                                        "MongoDB",
                                        "eBay",
                                        "Qualcomm",
                                        "Flipkart",
                                        "Square",
                                        "KPMG",
                                        "Wayfair",
                                        "Dropbox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: Problems like these have practical use in video game development, specifically in world-building and environment design. The algorithm that checks for land cells in a grid that you can't walk off is extensively used in designing the navigatable areas in different game maps. For instance, popular sandbox games such as Minecraft, where players can manipulate the in-game environment, this checks ensure that there are no inaccessible or infinitely looping paths formed when the players alter the game terrain.",
                                    "hints": [
                                        {
                                            "hint": "\"The binary matrix represents an implicit graph, where each land cell is a node. Water cells (0) act as barriers, preventing movement. Boundary-connected land cells (1s) are not enclosed, so we must exclude them.\""
                                        },
                                        {
                                            "hint": "\"Use a visited array to track explored land cells. Alternatively, modify the grid in-place by converting boundary-connected land (1s) to -1 or some marker.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Boundary-connected land cells will always escape, so we mark them first to avoid unnecessary checks.",
                                            "question": "Why flood fill from the boundary instead of scanning the entire grid?"
                                        },
                                        {
                                            "answer": "If all 1s are connected to the boundary, the answer is 0.\nIf an inner landmass is completely enclosed by water (0s), it is counted.",
                                            "question": "What if the grid is entirely land (1s)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use DFS/BFS per enclosed region, keeping a region counter instead of a single count.",
                                            "question": "How would you modify the algorithm to count separate enclosed land regions?"
                                        },
                                        {
                                            "answer": "This is a variant, where only fully enclosed islands (not touching the boundary) are counted.",
                                            "question": " How does this relate to the \"Number of Islands\" problem?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_rottenoranges",
                                "problem_name": "Rotten Oranges",
                                "problem_slug": "rotten-oranges",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Walmart",
                                        "Robinhood",
                                        "Splunk",
                                        "Roche",
                                        "Johnson & Johnson",
                                        "Chewy",
                                        "Dropbox",
                                        "Lyft",
                                        "Electronic Arts",
                                        "Micron Technology",
                                        "Philips Healthcare",
                                        "Activision Blizzard",
                                        "Docker",
                                        "Unity Technologies",
                                        "Wayfair",
                                        "Ernst & Young",
                                        "IBM",
                                        "Bain & Company",
                                        "Shopify",
                                        "Alibaba",
                                        "Zynga",
                                        "GE Healthcare",
                                        "Rockstar Games",
                                        "Western Digital",
                                        "Medtronic",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is an instance of the Breadth-First Search (BFS) algorithm and simulates a typical spread mechanism like virus propagation, pollution spread, etc. A practical software application of this concept can be found in computer graphics used for animation and game development. Here, this BFS algorithm can be used for \"flood fill\" operations, where you \"fill\" or change the color of a particular area on the screen (like converting all the fresh oranges to rotten ones in our problem). Additionally, the BFS algorithm is also used in networking software to traverse nodes or routers, and in social media algorithms to understand and predict how information or trends spread across a network.",
                                    "hints": [
                                        {
                                            "hint": "\"Since the rot spreads level by level, BFS (Queue-based) is the best approach. Push all initially rotten oranges (2) into the queue as starting points. Process oranges minute by minute, marking newly rotten oranges and tracking time.\""
                                        },
                                        {
                                            "hint": "\"Count the total fresh oranges (1s) initially. Track the number of fresh oranges that rot over time. If, after BFS, some fresh oranges remain, return -1 (not all oranges can rot).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By processing all rotten oranges (2s) simultaneously, BFS correctly tracks rot spread minute by minute.",
                                            "question": " How do we ensure all oranges rot in the minimum time?"
                                        },
                                        {
                                            "answer": "No, because BFS relies on a FIFO queue to track spreading over time.",
                                            "question": "Can BFS be implemented without an explicit queue?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Introduce a time decay factor, where a rotten orange turns fresh again after k minutes.\nThis would require additional state tracking in BFS.",
                                            "question": "How would you modify this if oranges could \"heal\" back to fresh after some time?"
                                        },
                                        {
                                            "answer": "Instead of 4 directions, consider 8 directions (up, down, left, right + 4 diagonals).",
                                            "question": "How would you modify this if an orange could rot diagonally as well?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_distanceofnearestcellhavingone",
                                "problem_name": "Distance of nearest cell having one",
                                "problem_slug": "distance-of-nearest-cell-having-one",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Epic Games",
                                        "Deloitte",
                                        "Johnson & Johnson",
                                        "OYO Rooms",
                                        "NVIDIA",
                                        "Philips Healthcare",
                                        "Alibaba",
                                        "Seagate Technology",
                                        "Docker",
                                        "Chewy",
                                        "Red Hat",
                                        "Boston Consulting Group",
                                        "Etsy",
                                        "Bloomberg",
                                        "Target",
                                        "American Express",
                                        "Broadcom",
                                        "Zoho",
                                        "Medtronic",
                                        "Riot Games",
                                        "Swiggy",
                                        "Epic Systems",
                                        "Rakuten",
                                        "Walmart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This concept has practical relevance in geographical information systems (GIS) software. One of the most typical use cases is the \"distance raster calculation\". For instance, it is used to calculate the shortest distance from a specific location (represented by '1' in the grid) to every other location in the defined area. This problem essentially represents how GIS systems compute 'proximity analysis' - determining the nearest pharmacy, hospital, grocery store, etc., which is a core feature in navigation and map apps like Google Maps or Uber.",
                                    "hints": [
                                        {
                                            "hint": "\"All cells containing 1 are sources (starting points) in BFS. Push all 1s into a queue first with an initial distance of 0. Then, process BFS level by level, updating distances for 0s as they are visited.\""
                                        },
                                        {
                                            "hint": "\"Maintain a distance matrix, initialized to  for 0s and 0 for 1s. Update distances in BFS as we explore neighbors in 4 directions (up, down, left, right). Stop updating a cell if its current distance is already smaller than the computed distance.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BFS works faster for unweighted grids, while Dijkstras is needed for weighted graphs.",
                                            "question": "Can we use Dijkstras Algorithm instead?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify BFS to ignore -1 cells and avoid updating their distances.",
                                            "question": "What if some cells were blocked (e.g., -1 representing an obstacle)?"
                                        },
                                        {
                                            "answer": "Yes, use a two-pass DP approach:\nFirst pass (top-left to bottom-right) updates distances from the top and left.\nSecond pass (bottom-right to top-left) updates distances from the bottom and right.\nHowever, BFS is more intuitive and efficient for this problem.",
                                            "question": " Can we solve this using Dynamic Programming (DP)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_surroundedregions",
                                "problem_name": "Surrounded Regions",
                                "problem_slug": "surrounded-regions",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "Cerner",
                                        "Robinhood",
                                        "Texas Instruments",
                                        "Ubisoft",
                                        "Oracle",
                                        "Snowflake",
                                        "JPMorgan Chase",
                                        "Morgan Stanley",
                                        "Dropbox",
                                        "Chewy",
                                        "Etsy",
                                        "Nutanix",
                                        "Reddit",
                                        "Splunk",
                                        "Swiggy",
                                        "Salesforce",
                                        "Unity Technologies",
                                        "Epic Games",
                                        "Boston Consulting Group",
                                        "Airbnb",
                                        "Cloudflare",
                                        "Bungie",
                                        "Instacart",
                                        "Activision Blizzard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is essentially a variation of the often-used 'Flood Fill' algorithm, which is an important tool in computer graphics. Applications such as Photoshop make use of this algorithm in their \"fill\" tool, where an entire area of similar color is replaced by another color with just one click. Similarly, this problem replaces an entire area of similar characters with another character. Besides, Flood Fill algorithm is also applied in gaming industry for mechanics like territory control, path finding, and more.",
                                    "hints": [
                                        {
                                            "hint": "Start from all 'O's on the boundary (first & last row, first & last column). Use DFS or BFS to mark all connected 'O's as safe (e.g., change them to -1 temporarily)."
                                        },
                                        {
                                            "hint": "\"Traverse the grid again: Convert remaining 'O's to 'X' (they are enclosed). Convert marked -1 back to 'O'.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Only 'O's connected to the boundary remain unchanged, so marking them first avoids unnecessary checks.",
                                            "question": "Why start from the boundary instead of scanning the whole grid?"
                                        },
                                        {
                                            "answer": "DFS/BFS efficiently marks boundary-connected regions in O(N  M) time instead of repeatedly scanning the grid.",
                                            "question": "Why use DFS/BFS instead of brute force checking all 'O' cells?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use adjacency lists instead of 2D arrays for better memory efficiency.",
                                            "question": " What if the matrix was sparse (mostly empty)?"
                                        },
                                        {
                                            "answer": "Yes, we can mark safe 'O's with -1 (or any placeholder) and restore them later.",
                                            "question": "Can we modify the matrix in-place?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_traversalproblems_numberofdistinctislands",
                                "problem_name": "Number of distinct islands",
                                "problem_slug": "number-of-distinct-islands",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "PayPal",
                                        "Cerner",
                                        "Bain & Company",
                                        "MongoDB",
                                        "Flipkart",
                                        "Johnson & Johnson",
                                        "Oracle",
                                        "Alibaba",
                                        "Pinterest",
                                        "Mastercard",
                                        "Instacart",
                                        "NVIDIA",
                                        "Optum",
                                        "Ernst & Young",
                                        "Wayfair",
                                        "DoorDash",
                                        "eBay",
                                        "Splunk",
                                        "Qualcomm",
                                        "Etsy",
                                        "Siemens Healthineers",
                                        "Zoho",
                                        "Square",
                                        "Dropbox",
                                        "Rockstar Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is similar to the problem of image recognition in computer vision. It reflects the task of identifying unique shapes in a binary image. For instance, identifying different hand written digits in a scanned document, or detecting specific objects in satellite imagery. Techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS), commonly used in solving this coding problem, are similarly used in computer vision tasks to recognize patterns and categorize images.",
                                    "hints": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_cycles",
                        "subcategory_name": "Cycles",
                        "subcategory_slug": "cycles",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_cycles_detectacycleinanundirectedgraph",
                                "problem_name": "Detect a cycle in an undirected graph",
                                "problem_slug": "detect-a-cycle-in-an-undirected-graph",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "DoorDash",
                                        "Databricks",
                                        "Shopify",
                                        "Intel",
                                        "Bloomberg",
                                        "Epic Games",
                                        "Western Digital",
                                        "Instacart",
                                        "Mastercard",
                                        "Johnson & Johnson",
                                        "Reddit",
                                        "Ubisoft",
                                        "Wayfair",
                                        "HashiCorp",
                                        "Deloitte",
                                        "Morgan Stanley",
                                        "Zynga",
                                        "Etsy",
                                        "Broadcom",
                                        "Boston Consulting Group",
                                        "Goldman Sachs",
                                        "Robinhood",
                                        "Square",
                                        "Electronic Arts",
                                        "Walmart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fact: Detecting cycles in a graph is a fundamental problem that has a wide array of applications in the software industry. It is used in networking and telecommunication for finding routing loops or cyclical data dependencies. Also, it finds usage in DevOps for spotting potential infinite loops in tasks automation like ansible, puppet, etc. More so, in social networking applications like Facebook or LinkedIn, it can help track circular friend requests or connections. Algorithms for detecting cycles are extensively used in garbage collection mechanism in programming languages like Python, Java and Javascript to identify and clean up objects that are no longer needed by the program to efficiently manage memory.",
                                    "hints": [
                                        {
                                            "hint": "\"Use DFS with a visited array to track traversal. A cycle exists if a visited node is reached again and it is not the parent node.\""
                                        },
                                        {
                                            "hint": "\"Use Union-Find to track connected components. If an edge connects two nodes already in the same set, a cycle is detected.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In an undirected graph, a visited neighbor could be the previous node in traversal, which is not a cycle.",
                                            "question": "Why check the parent in DFS for cycles?"
                                        },
                                        {
                                            "answer": "Union-Find tracks connected components efficiently, detecting if two nodes already belong to the same component when an edge is added.",
                                            "question": "Why use Union-Find for cycle detection?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify DFS to store path traces and return all cycle paths.",
                                            "question": "How can we find all cycles instead of just detecting one?"
                                        },
                                        {
                                            "answer": "Use incremental DSU updates to detect cycles in real-time.",
                                            "question": "What if the graph was dynamically changing (edges being added/removed)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_cycles_bipartitegraph",
                                "problem_name": "Bipartite graph",
                                "problem_slug": "bipartite-graph",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Siemens Healthineers",
                                        "Unity Technologies",
                                        "Zomato",
                                        "Intel",
                                        "Broadcom",
                                        "NVIDIA",
                                        "Roblox",
                                        "Texas Instruments",
                                        "IBM",
                                        "ARM",
                                        "MongoDB",
                                        "Etsy",
                                        "Lyft",
                                        "Pinterest",
                                        "Alibaba",
                                        "Twilio",
                                        "Shopify",
                                        "PayPal",
                                        "KPMG",
                                        "Zoho",
                                        "Target",
                                        "McKinsey & Company",
                                        "Boston Consulting Group",
                                        "Wayfair",
                                        "Byju's",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The problem at the heart of bipartite graph detection is used heavily in computer sciences, especially in network and social media applications. One real-world example is in designing matchmaking systems in multiplayer video games. In these games, players are sometimes seen as two distinct sets - for example, team A and team B - and we need to ensure each player in team A has a corresponding match in team B. Hence, the problem of partitioning the players into compatible teams turns out to be checking for a bipartite graph!",
                                    "hints": [
                                        {
                                            "hint": "\"Use BFS to color nodes alternately (like a checkerboard pattern). If a node is already colored with the same color as its adjacent node, the graph is not bipartite.\""
                                        },
                                        {
                                            "hint": "\"Recursively assign alternating colors to adjacent nodes. If any conflict is found, return False.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In an odd-length cycle, alternating colors fail at some point, leading to two adjacent nodes having the same color.",
                                            "question": " Why does an odd-length cycle mean the graph is not bipartite?"
                                        },
                                        {
                                            "answer": "BFS is preferred as it naturally colors level by level (like a breadth-first layer coloring).\nDFS works as well but can lead to deep recursion.",
                                            "question": "Why use BFS instead of DFS?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A graph is bipartite if and only if it is 2-colorable.",
                                            "question": "How does this relate to two-coloring a graph?"
                                        },
                                        {
                                            "answer": "Directed graphs require different approaches, such as checking Strongly Connected Components (SCCs).",
                                            "question": "How would you modify this for a directed graph?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_cycles_topologicalsortorkahn'salgorithm",
                                "problem_name": "Topological sort or Kahn's algorithm",
                                "problem_slug": "topological-sort-or-kahns-algorithm",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Stripe",
                                        "MongoDB",
                                        "Bungie",
                                        "Activision Blizzard",
                                        "Chewy",
                                        "GE Healthcare",
                                        "Byju's",
                                        "Reddit",
                                        "OYO Rooms",
                                        "Docker",
                                        "Zomato",
                                        "Rakuten",
                                        "Cloudflare",
                                        "Databricks",
                                        "Bloomberg",
                                        "Oracle",
                                        "Target",
                                        "PwC",
                                        "eBay",
                                        "Walmart",
                                        "Uber",
                                        "Mastercard",
                                        "Epic Games",
                                        "Teladoc Health",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One interesting application of the topological sorting algorithm in real-world software development is in job scheduling. It helps to establish a sequence of tasks where some tasks are dependent on others being completed first. This algorithm helps in the correct priority-based execution of tasks for project management software and operating systems. Also, package managers use topological sorting to resolve dependencies between packages to ensure correct installation order.",
                                    "hints": [
                                        {
                                            "hint": "\"Perform DFS on unvisited nodes. Push nodes to a stack after all their neighbors are visited (post-order traversal). The reverse of the stack gives a valid topological order.\""
                                        },
                                        {
                                            "hint": "\"Maintain an in-degree array (count of incoming edges for each node). Start with nodes having 0 in-degree (no dependencies). Process each node and reduce the in-degree of its neighbors. Nodes whose in-degree becomes 0 are added to the queue.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Cycles prevent a valid ordering, as no node in a cycle can appear before the others.",
                                            "question": " Why is topological sorting only possible for DAGs?"
                                        },
                                        {
                                            "answer": "Post-order traversal ensures a node is pushed to the stack only after visiting all its children, giving the correct order when reversed.",
                                            "question": "How does DFS ensure topological sorting?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, as long as all u  v constraints are satisfied, multiple valid orderings exist.",
                                            "question": "Can DFS and BFS give different valid topological sorts?"
                                        },
                                        {
                                            "answer": "Topological sorting remains the same, but it can be used to find shortest/longest paths in DAGs.",
                                            "question": "How would this change if the graph was weighted?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_cycles_detectacycleinadirectedgraph",
                                "problem_name": "Detect a cycle in a directed graph",
                                "problem_slug": "detect-a-cycle-in-a-directed-graph",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Target",
                                        "Broadcom",
                                        "Morgan Stanley",
                                        "Chewy",
                                        "Johnson & Johnson",
                                        "Instacart",
                                        "Siemens Healthineers",
                                        "Byju's",
                                        "Mastercard",
                                        "Goldman Sachs",
                                        "AMD",
                                        "PayPal",
                                        "ARM",
                                        "Walmart",
                                        "Deloitte",
                                        "Boston Consulting Group",
                                        "Pinterest",
                                        "McKinsey & Company",
                                        "Shopify",
                                        "Medtronic",
                                        "DoorDash",
                                        "Robinhood",
                                        "Uber",
                                        "Texas Instruments",
                                        "GE Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The problem of detecting cycles in a directed graph is essentially used in software dependency management systems. These systems, such as NPM for JavaScript or Maven for Java, have to resolve various package dependencies while avoiding cycles. A cycle would mean you have a circular dependency, which often leads to infinite recursion or other logical errors. Thus, algorithms solving such problems are integral to the smooth operation of modern software development and operations.",
                                    "hints": [
                                        {
                                            "hint": "\"Use DFS with a recursion stack to track visited nodes. A cycle exists if a node is visited again while still being processed (present in the recursion stack).\""
                                        },
                                        {
                                            "hint": "\"A DAG (Directed Acyclic Graph) can always be topologically sorted. If a valid topological sort is not possible (i.e., not all nodes are processed), a cycle exists.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In a directed graph, a cycle means a back edge exists, where a node is revisited before completing its DFS call.",
                                            "question": " Why check the recursion stack in DFS for cycles?"
                                        },
                                        {
                                            "answer": "Yes, but with a different approach:\nIf a visited node is encountered again and it is not the parent, a cycle exists.",
                                            "question": "Can DFS detect cycles in an undirected graph?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A deadlock occurs if there is a cycle in the resource allocation graph, making cycle detection crucial.",
                                            "question": "How does this relate to detecting deadlocks in operating systems?"
                                        },
                                        {
                                            "answer": "No, both methods correctly detect cycles, but BFS (Kahns Algorithm) requires extra processing (in-degree tracking), whereas DFS (recursion stack) works naturally.",
                                            "question": "Can DFS and BFS give different results for cycle detection?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_hardproblems",
                        "subcategory_name": "Hard Problems",
                        "subcategory_slug": "hard-problems",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_hardproblems_findeventualsafestates",
                                "problem_name": "Find eventual safe states",
                                "problem_slug": "find-eventual-safe-states",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Uber",
                                        "Docker",
                                        "Robinhood",
                                        "HashiCorp",
                                        "Micron Technology",
                                        "Roblox",
                                        "PwC",
                                        "Rockstar Games",
                                        "IBM",
                                        "Riot Games",
                                        "Zomato",
                                        "Epic Games",
                                        "Siemens Healthineers",
                                        "Dropbox",
                                        "Unity Technologies",
                                        "Stripe",
                                        "Johnson & Johnson",
                                        "Lyft",
                                        "Deloitte",
                                        "Seagate Technology",
                                        "Shopify",
                                        "Cerner",
                                        "Goldman Sachs",
                                        "Nutanix",
                                        "Target",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The problem of finding safe nodes in a graph is directly relevant to the implementation of network routing protocols. Network devices, like routers, create a graph representation of the network topology. As packets of data traverse the network, they follow the paths defined by this graph. In some cases, a failed device or lost connection could render a node, or even an entire sub-network, unreachable. These are equivalent to the terminal nodes in this problem. So, effectively determining safe nodes could ensure the reliable delivery of packets by avoiding isolated or failure-prone segments of the network.",
                                    "hints": [
                                        {
                                            "hint": "Reverse all edges (construct the reverse graph). Use Kahns Algorithm (BFS with indegree processing) to find nodes that can reach terminal nodes. Sort the result in ascending order before returning."
                                        },
                                        {
                                            "hint": "\"Use DFS to detect cycles: Any node part of a cycle is not safe. Mark visited nodes and store results for faster lookup (memoization). If DFS reaches a terminal node or another known safe node, mark the current node safe.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In the original graph, safe nodes are hard to track.\nIn the reverse graph, terminal nodes become zero in-degree nodes, allowing BFS to process them first.",
                                            "question": " Why reverse the graph for Kahns Algorithm?"
                                        },
                                        {
                                            "answer": "The algorithm naturally accounts for this, as all terminal nodes and their reachable nodes are safe.",
                                            "question": "What if the graph has multiple terminal nodes?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use adjacency lists instead of matrices for memory efficiency.\nParallelize BFS processing for large datasets.",
                                            "question": "Can this be optimized for very large graphs?"
                                        },
                                        {
                                            "answer": "Run BFS/DFS separately on each component and process them independently.",
                                            "question": "How do we handle disconnected graphs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_courseschedulei",
                                "problem_name": "Course Schedule I",
                                "problem_slug": "course-schedule-i",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "McKinsey & Company",
                                        "Red Hat",
                                        "AMD",
                                        "Optum",
                                        "Chewy",
                                        "Morgan Stanley",
                                        "KPMG",
                                        "Flipkart",
                                        "Etsy",
                                        "Target",
                                        "American Express",
                                        "Salesforce",
                                        "Stripe",
                                        "Teladoc Health",
                                        "Byju's",
                                        "Square",
                                        "Unity Technologies",
                                        "Epic Games",
                                        "Pinterest",
                                        "eBay",
                                        "Boston Consulting Group",
                                        "PwC",
                                        "Freshworks",
                                        "Rakuten",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem mimics the concept of handling dependencies in project management and software development tools. For instance, in package managers like npm (Node Package Manager), a package can't be installed before its dependencies are resolved. Similarly, in project management tools like Jira, certain tasks may be blocked until prerequisite tasks are completed. This problem essentially deals with a directed graph and a cycle detection which is similar to detection of cyclic dependencies in real life software development.",
                                    "hints": [
                                        {
                                            "hint": "\"Construct the graph using an adjacency list. Compute the in-degree (number of prerequisites) for each node. Use Kahns Algorithm (BFS) to process nodes with zero in-degree (no prerequisites). If we can process all N tasks, return True; otherwise, return False (cycle exists).\""
                                        },
                                        {
                                            "hint": "\"Use DFS with a recursion stack to detect back edges (which indicate a cycle). If a cycle is found, return False; otherwise, return True.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A cycle means some tasks depend on themselves, making it impossible to finish them.",
                                            "question": "Why does a cycle make task completion impossible?"
                                        },
                                        {
                                            "answer": "Run BFS/DFS from all unvisited nodes to check all components",
                                            "question": "How do we handle disconnected graphs?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "No change needed, since both BFS and DFS handle multiple dependencies naturally.",
                                            "question": "How would you modify this if tasks could have multiple prerequisites?"
                                        },
                                        {
                                            "answer": "Modify topological sorting to process higher-priority tasks first.",
                                            "question": "How would this change if some tasks had priority levels?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_coursescheduleii",
                                "problem_name": "Course Schedule II",
                                "problem_slug": "course-schedule-ii",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Zynga",
                                        "Epic Games",
                                        "Optum",
                                        "American Express",
                                        "Deloitte",
                                        "Rakuten",
                                        "McKinsey & Company",
                                        "Airbnb",
                                        "Activision Blizzard",
                                        "ARM",
                                        "Roblox",
                                        "AMD",
                                        "Salesforce",
                                        "Flipkart",
                                        "Instacart",
                                        "Cerner",
                                        "Seagate Technology",
                                        "Docker",
                                        "Western Digital",
                                        "Swiggy",
                                        "Nutanix",
                                        "Shopify",
                                        "Stripe",
                                        "Ernst & Young",
                                        "Teladoc Health",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem presents a real-world application of the topological sort algorithm, which is commonly used in project scheduling, ordering of compilation tasks, determining the sequence of tasks in project management, and resolving dependencies in package installation. In software development, it helps to identify the order of execution of interdependent classes or frameworks. An interesting use of this concept is in social media algorithms to determine the order of displaying posts based on relevance and dependency.",
                                    "hints": [
                                        {
                                            "hint": "\"This method relies on in-degree tracking, which counts how many prerequisites a task has. Any task with an in-degree of 0 (i.e., no prerequisites) can be executed immediately.\""
                                        },
                                        {
                                            "hint": "As each task is completed, it reduces the in-degree of dependent tasks, allowing more tasks to become available for execution. If at any point, no tasks with 0 in-degree remain while tasks are still unprocessed, this means a cycle exists."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since a graph can have multiple valid topological sorts, any correct sequence that satisfies the constraints is acceptable. BFS-based Kahns Algorithm often provides lexicographically smallest order when tasks are processed in a predefined order.",
                                            "question": "What happens if there are multiple valid orderings?"
                                        },
                                        {
                                            "answer": "No, because this is a graph traversal problem, not an optimization problem. Dynamic Programming is useful when solving problems with overlapping subproblems and optimal substructure, neither of which applies here.",
                                            "question": "Can this problem be solved using Dynamic Programming instead of Graph Algorithms?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "In that case, we would need to extend topological sorting to consider task durations. A longest path algorithm in a DAG could be used to determine the overall time required to complete all tasks while respecting dependencies.",
                                            "question": "How would this change if certain tasks had weights (e.g., different completion times)?"
                                        },
                                        {
                                            "answer": "This can be formulated as a critical path problem, where the goal is to minimize makespan, the total execution time required when considering dependencies and execution parallelism.",
                                            "question": "What if we wanted to minimize the number of steps required to complete all tasks while respecting dependencies?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_alientdictionary",
                                "problem_name": "Alien Dictionary",
                                "problem_slug": "alient-dictionary",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Roblox",
                                        "KPMG",
                                        "PayPal",
                                        "Target",
                                        "HCL Technologies",
                                        "Reddit",
                                        "PwC",
                                        "Qualcomm",
                                        "Databricks",
                                        "Western Digital",
                                        "Wayfair",
                                        "Splunk",
                                        "Instacart",
                                        "Teladoc Health",
                                        "Stripe",
                                        "Siemens Healthineers",
                                        "HashiCorp",
                                        "Byju's",
                                        "ARM",
                                        "Walmart",
                                        "Chewy",
                                        "NVIDIA",
                                        "Bloomberg",
                                        "Oracle",
                                        "MongoDB",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept behind this problem is used in software that deals with multiple languages, internationalization or character set conversion. These softwares often have to determine the collation order of characters in different languages, as it can greatly vary. It is also used in translation software where the sequence of characters in different languages needs to be identified. Additionally, it provides an interesting take on sorting algorithms and graph theory, which are cornerstone concepts in various areas of software development, from database management to resource allocation.",
                                    "hints": [
                                        {
                                            "hint": "\"Compare each word with the next word and determine the first mismatching character. If \"\"word1\"\" appears before \"\"word2\"\" and the first different letter is 'x' in \"\"word1\"\" and 'y' in \"\"word2\"\", then 'x' must come before 'y' in the ordering. This gives a directed edge x  y in the graph.\""
                                        },
                                        {
                                            "hint": "\"Track how many times each character appears as a dependent (i.e., its in-degree). Start with characters that have in-degree 0 (letters that appear first). Process letters in BFS order, ensuring that all constraints are met.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If \"abc\" appears before \"ab\", this is an invalid dictionary, and no valid ordering exists.",
                                            "question": "What if two adjacent words have no different characters (i.e., one is a prefix of another)?"
                                        },
                                        {
                                            "answer": "Characters that are present but have no dependencies should still be included in the result. They can appear in any position that does not violate constraints.",
                                            "question": "What happens if some characters do not appear in ordering constraints?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of a standard topological sort, we would need a priority-based sorting algorithm, similar to Huffman Coding, where letters with more constraints or higher frequency take precedence.",
                                            "question": "How would this change if words had frequency counts, and we needed the most frequent letter first?"
                                        },
                                        {
                                            "answer": "These characters should be added to the result arbitrarily, as they have no restrictions on their placement.",
                                            "question": "What if some characters appeared in the dictionary but were not used in any constraints?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_shortestpathindag",
                                "problem_name": "Shortest path in DAG",
                                "problem_slug": "shortest-path-in-dag",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Boston Consulting Group",
                                        "Databricks",
                                        "Twilio",
                                        "Texas Instruments",
                                        "Philips Healthcare",
                                        "Uber",
                                        "Optum",
                                        "McKinsey & Company",
                                        "Broadcom",
                                        "Lyft",
                                        "Snowflake",
                                        "Cerner",
                                        "Bungie",
                                        "Zoho",
                                        "Ernst & Young",
                                        "Activision Blizzard",
                                        "Electronic Arts",
                                        "Intel",
                                        "Roblox",
                                        "Morgan Stanley",
                                        "Seagate Technology",
                                        "Shopify",
                                        "Freshworks",
                                        "Medtronic",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "A practical application of this programming problem lies in routing and navigation software, such as Google Maps or Waze. The \"Directed Acyclic Graph\" represents the map's network of roads, with the \"vertices\" representing intersections and the \"edges\" representing the roads themselves. The algorithm to find the \"shortest path\" from a source (user's starting point) to all vertices (possible destinations) is a fundamental operation of these services. This would allow them to provide real-time directions and traffic updates, indicating the fastest route to the destination. If a path can't be found (represented by '-1'), it means that destination is unreachable from the current location.",
                                    "hints": [
                                        {
                                            "hint": "Since the graph is a Directed Acyclic Graph (DAG), use topological sorting to process vertices in a valid order. After sorting, relax edges following the topological order to compute shortest paths efficiently."
                                        },
                                        {
                                            "hint": "Unlike Dijkstras algorithm (which uses a priority queue), topological sorting followed by relaxation solves it in O(N + M) time. This approach works because in a DAG, edges always point forward, preventing cycles."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since its a DAG, negative cycles are impossible, and the approach remains valid. If there were cycles, wed need Bellman-Ford instead.",
                                            "question": "What if the graph has negative weights?  "
                                        },
                                        {
                                            "answer": "The algorithm automatically considers the minimum-weight path during relaxation.",
                                            "question": "What if there are multiple shortest paths to a node?  "
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, by reversing the weights (multiplying by -1) and applying the same topological sorting + relaxation approach.",
                                            "question": "Can we modify this to find the longest path in a DAG?  "
                                        },
                                        {
                                            "answer": "Introduce a dummy node (N) with edges of weight 0 pointing to all sources, then run the same algorithm from node N.",
                                            "question": "How can we handle multiple sources instead of a single source?  "
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_shortestpathinundirectedgraphwithunitweights",
                                "problem_name": "Shortest path in undirected graph with unit weights",
                                "problem_slug": "shortest-path-in-undirected-graph-with-unit-weights",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Seagate Technology",
                                        "Activision Blizzard",
                                        "Red Hat",
                                        "Western Digital",
                                        "Epic Systems",
                                        "Splunk",
                                        "NVIDIA",
                                        "Airbnb",
                                        "OYO Rooms",
                                        "HCL Technologies",
                                        "JPMorgan Chase",
                                        "AMD",
                                        "ARM",
                                        "Intel",
                                        "Chewy",
                                        "Nutanix",
                                        "Rockstar Games",
                                        "Robinhood",
                                        "Salesforce",
                                        "Swiggy",
                                        "Optum",
                                        "Micron Technology",
                                        "PwC",
                                        "Twilio",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of algorithm, known as the Shortest Path algorithm, is the foundation of routing on the internet. Electric signals travel faster through some types of wires or connections than others, so finding the route that gets data to its destination the quickest is a common application of Shortest Path algorithms. They are also used in map applications for finding the quickest route to your destination, accounting not only for distance but also for things like traffic and speed limits.",
                                    "hints": [
                                        {
                                            "hint": " Perform a topological sort to find an ordering of nodes where every node appears before its dependent nodes. Initialize a distance array with inf (or a large value) for all nodes, except for the source node (0), which is initialized to 0."
                                        },
                                        {
                                            "hint": "Process the nodes in topological order, updating the shortest distances for all adjacent nodes using edge relaxation:dist[v]=min(dist[v],dist[u]+weight[uv]). If a node remains unreachable (inf distance), return -1 for that node"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, since there are no cycles, negative weights do not create infinite loops like in Dijkstras algorithm. However, if the graph had cycles, we would need Bellman-Ford to detect negative weight cycles.",
                                            "question": "Can this approach handle graphs with negative weights?"
                                        },
                                        {
                                            "answer": "Dijkstras Algorithm is best for graphs with arbitrary weights and cycles, using a priority queue (O(N + M log N)).\nTopological sorting for DAGs works in O(N + M), which is faster for acyclic graphs.",
                                            "question": "How does this compare to Dijkstras Algorithm?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Convert the problem into a longest path problem by negating all weights, applying the same topological sorting approach, and then reversing the result.",
                                            "question": "What if we needed to find the longest path instead?"
                                        },
                                        {
                                            "answer": "If cycles exist, we cannot use topological sorting. Instead, we must use Dijkstras Algorithm (if all weights are non-negative) or Bellman-Ford (if negative weights exist).",
                                            "question": "How would this solution change if the graph was not a DAG?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_wordladderi",
                                "problem_name": "Word ladder I",
                                "problem_slug": "word-ladder-i",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Etsy",
                                        "Chewy",
                                        "KPMG",
                                        "Shopify",
                                        "Bungie",
                                        "GE Healthcare",
                                        "Zynga",
                                        "Goldman Sachs",
                                        "Rockstar Games",
                                        "American Express",
                                        "PayPal",
                                        "Medtronic",
                                        "Roche",
                                        "Uber",
                                        "Instacart",
                                        "McKinsey & Company",
                                        "Rakuten",
                                        "HashiCorp",
                                        "Freshworks",
                                        "Bloomberg",
                                        "DoorDash",
                                        "Red Hat",
                                        "Dropbox",
                                        "Byju's",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is actually commonplace in natural language processing (NLP) and machine learning applications, specifically word ladder problems. A real-world application would be in the development of language-based games or language learning applications. For example, applications like Duolingo may use similar transformation sequence algorithms to create exercises that progressively change words by a single letter. Furthermore, the ability to change one word into another using minute transformations can also be used in text-detection algorithms and spelling correction systems, which is a key feature in most word processors and search engines.",
                                    "hints": [
                                        {
                                            "hint": "Insert all words from wordList into a set (for O(1) lookups). If targetWord is not in wordList, return 0 (since transformation is impossible). Use BFS starting from startWord, with each level representing a transformation step."
                                        },
                                        {
                                            "hint": "For each word at the front of the queue, generate all possible one-letter transformations and check if they exist in wordList. If a transformation leads to targetWord, return the current depth. If all possible transformations are exhausted and targetWord is not reached, return 0."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of checking all words in wordList, iterate over each character of the current word and replace it with all possible lowercase letters (a-z) to generate new words.",
                                            "question": "How do we generate valid word transformations efficiently?"
                                        },
                                        {
                                            "answer": "No, because BFS explores words based on their transformations, not their positions in wordList.",
                                            "question": "Does the order of words in wordList matter?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Instead of searching from startWord to targetWord, run two simultaneous BFS (one from startWord and another from targetWord). This approach halves the search space, improving performance from O(NM) to O(NM/2).",
                                            "question": "Can we optimize further using bidirectional BFS?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblems_wordladderii",
                                "problem_name": "Word ladder II",
                                "problem_slug": "word-ladder-ii",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "MongoDB",
                                        "eBay",
                                        "Instacart",
                                        "McKinsey & Company",
                                        "Oracle",
                                        "Twilio",
                                        "JPMorgan Chase",
                                        "Nutanix",
                                        "American Express",
                                        "Bain & Company",
                                        "Seagate Technology",
                                        "Ubisoft",
                                        "Airbnb",
                                        "Broadcom",
                                        "Robinhood",
                                        "Bloomberg",
                                        "PayPal",
                                        "NVIDIA",
                                        "Salesforce",
                                        "Databricks",
                                        "Cloudflare",
                                        "Zynga",
                                        "Ernst & Young",
                                        "Etsy",
                                        "Mastercard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is central in applications such as machine translation, autocorrect algorithms, or even text-based games. The ability to transform one word into another by changing letters, while still producing valid words, forms the foundation of such systems. The concept is known as Levenshtein distance or Edit distance in computer science, which measures the minimum number of operations (transformations) required to change one word into another. It is a popular algorithm in Natural Language Processing and Computational Linguistics.",
                                    "hints": [
                                        {
                                            "hint": "\"Bidirectional BFS is optimal, reducing the search space by simultaneously expanding from startWord and targetWord until they meet in the middle. Instead of storing only distances, we store parent mappings to track how each word was reached, allowing us to reconstruct all shortest paths efficiently.\""
                                        },
                                        {
                                            "hint": "\"After finding the shortest path depth using BFS, we use Depth-First Search (DFS) or backtracking to reconstruct all possible sequences. The parent mapping stores how each word was reached during BFS, and DFS reconstructs sequences by following this mapping back from targetWord to startWord.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The transformation can still begin from startWord if it can reach an existing word in wordList. If startWord cannot transform into any valid word, return an empty list.",
                                            "question": "What if startWord is not in wordList?"
                                        },
                                        {
                                            "answer": "BFS guarantees the shortest transformation sequence because it explores level by level. DFS does not guarantee this and may explore deeper paths unnecessarily.",
                                            "question": "Why use BFS instead of DFS for finding shortest paths?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If each word change had a different cost, Dijkstras Algorithm (shortest path with weighted edges) would be required instead of BFS.",
                                            "question": "How would you modify this approach if words had different transformation costs?"
                                        },
                                        {
                                            "answer": "Instead of using a fixed wordList, we could use a Trie or a HashMap-based dynamic structure to allow fast insertions/deletions and efficient search operations.",
                                            "question": "How would you handle dynamic word additions or deletions in wordList?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_shortestpathalgorithms",
                        "subcategory_name": "Shortest Path Algorithms",
                        "subcategory_slug": "shortest-path-algorithms",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_dijkstra'salgorithm",
                                "problem_name": "Dijkstra's algorithm",
                                "problem_slug": "dijkstra's-algorithm",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Texas Instruments",
                                        "Activision Blizzard",
                                        "Electronic Arts",
                                        "Bungie",
                                        "Ubisoft",
                                        "Western Digital",
                                        "Philips Healthcare",
                                        "Micron Technology",
                                        "Goldman Sachs",
                                        "Stripe",
                                        "Target",
                                        "Bain & Company",
                                        "Zoho",
                                        "Visa",
                                        "Snowflake",
                                        "Zomato",
                                        "AMD",
                                        "HCL Technologies",
                                        "Dropbox",
                                        "Epic Games",
                                        "IBM",
                                        "Square",
                                        "Splunk",
                                        "Byju's",
                                        "JPMorgan Chase",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept underlying this programming problem is used in the implementation of various routing algorithms in major navigation applications like Google Maps or Waze. For example, Dijkstras algorithm, which also finds the shortest path given a source node in a graph (which could represent cities, intersections etc.) with associated weights (distances, time or cost), enables these apps to provide users with the quickest or shortest route to their destination. This problem is fundamental to the field of Graph Theory that lays the foundation for network analysis and optimization in various domains including computer networks, operations research, and transportation.",
                                    "hints": [
                                        {
                                            "hint": " Initialize a distance array dist[] where dist[i] stores the shortest known distance from S to i. Set all distances to 10^9 (infinity) except dist[S] = 0. Use a Min-Heap (Priority Queue) to always expand the current closest node."
                                        },
                                        {
                                            "hint": "For each node, check all adjacent nodes and relax their distances (dist[v] = min(dist[v], dist[u] + weight)). Continue until all nodes are processed."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since it processes each node once, it assumes that once a node is processed, its shortest distance is finalized. Negative weights can lead to situations where a better path appears after processing, causing incorrect results.",
                                            "question": "Why does Dijkstras Algorithm not work with negative weights?"
                                        },
                                        {
                                            "answer": "The priority queue always picks the next closest node, ensuring that we process the shortest known path first, improving efficiency.",
                                            "question": "Why do we use a priority queue in Dijkstras Algorithm?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent array to track the previous node in the shortest path.\nAfter computing distances, backtrack from each node to reconstruct the path.",
                                            "question": "How would you modify this to return the actual shortest path, not just the distance?"
                                        },
                                        {
                                            "answer": "We would need to use Bellman-Ford Algorithm (O(VE)), which can handle negative weights but not negative cycles.",
                                            "question": "What if the graph had negative weight edges?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_printshortestpath",
                                "problem_name": "Print Shortest Path",
                                "problem_slug": "print-shortest-path-",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Western Digital",
                                        "Cerner",
                                        "Etsy",
                                        "Stripe",
                                        "Epic Systems",
                                        "Johnson & Johnson",
                                        "JPMorgan Chase",
                                        "Micron Technology",
                                        "Ernst & Young",
                                        "Teladoc Health",
                                        "Broadcom",
                                        "NVIDIA",
                                        "KPMG",
                                        "Zomato",
                                        "Lyft",
                                        "Electronic Arts",
                                        "Roche",
                                        "Unity Technologies",
                                        "Ubisoft",
                                        "Swiggy",
                                        "Freshworks",
                                        "Byju's",
                                        "American Express",
                                        "Docker",
                                        "Zoho",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The Weighted undirected graph problem is a crucial part of the Dijkstra's algorithm, which is a fundamental part of routing protocols that enables the internet to work effectively. These routing protocols, including Open Shortest Path First (OSPF) and Border Gateway Protocol (BGP), spin Dijkstra's algorithm continuously to determine the shortest path for routing data from one node to another. So, every time you use Google Maps for the shortest route or stream a Netflix video, you're indirectly using the principles of weighted graph problem!",
                                    "hints": [
                                        {
                                            "hint": "Construct the graph using an adjacency list representation. Maintain a priority queue (min-heap) to always expand the closest (smallest distance) node first. Maintain a distance array dist[], setting all distances to inf (infinity), except dist[1] = 0."
                                        },
                                        {
                                            "hint": "Maintain a parent array parent[] to reconstruct the path. If n is unreachable, return [-1]. Otherwise, backtrack using parent[] to reconstruct the shortest path sequence."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Maintain a parent[] array to track the predecessor of each node in the shortest path.\nOnce we reach n, backtrack using parent[] to reconstruct the path.",
                                            "question": "How do we ensure we return the actual shortest path, not just the distance?"
                                        },
                                        {
                                            "answer": "Bellman-Ford works for graphs with negative weight edges, but it runs in O(nm), which is slower than Dijkstras O((n + m) log n) for large graphs.",
                                            "question": "Can we use Bellman-Ford Algorithm instead?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, by using a Fibonacci Heap, we can reduce the complexity from O((n + m) log n) to O(n log n + m).",
                                            "question": "Can we optimize Dijkstras performance further?"
                                        },
                                        {
                                            "answer": "We would need to use Bellman-Ford Algorithm instead of Dijkstras, since Dijkstras cannot handle negative weights.",
                                            "question": "What if the graph contained negative weight edges?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_shortestpathwithminimumeffort",
                                "problem_name": "Shortest Distance in a Binary Maze",
                                "problem_slug": "shortest-path-with-minimum-effort",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Seagate Technology",
                                        "Oracle",
                                        "Texas Instruments",
                                        "Robinhood",
                                        "Deloitte",
                                        "Riot Games",
                                        "Etsy",
                                        "Intel",
                                        "Electronic Arts",
                                        "Walmart",
                                        "NVIDIA",
                                        "Teladoc Health",
                                        "Instacart",
                                        "Siemens Healthineers",
                                        "Reddit",
                                        "Salesforce",
                                        "Western Digital",
                                        "Twilio",
                                        "Johnson & Johnson",
                                        "Snowflake",
                                        "Morgan Stanley",
                                        "McKinsey & Company",
                                        "Alibaba",
                                        "Red Hat",
                                        "American Express",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Check if either the source or destination cell is 0. If so, return -1 (impossible to reach). Use a queue for BFS traversal, storing (row, col, distance). Maintain a visited matrix to prevent cycles."
                                        },
                                        {
                                            "hint": "Process each cell, exploring its 4 valid neighbors (up, down, left, right), and update their distances if they are not visited and have value 1. If we reach the destination cell, return the current distance. If the queue is exhausted and the destination is not reached, return -1."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since all moves have the same weight (1), BFS is optimal. Dijkstras is required only when edge weights vary.",
                                            "question": "Can we use Dijkstras Algorithm instead of BFS?"
                                        },
                                        {
                                            "answer": "BFS naturally finds one of the shortest paths, but if all paths are required, additional backtracking from the destination would be needed.",
                                            "question": "What if multiple shortest paths exist?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This would require a modified Dijkstras Algorithm, where removing obstacles adds weight to certain paths.",
                                            "question": "What if obstacles could be removed at a cost?"
                                        },
                                        {
                                            "answer": "Use multi-source BFS, initializing the queue with all sources simultaneously.",
                                            "question": "What if multiple sources and multiple destinations existed?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_pathwithminimumeffort",
                                "problem_name": "Path with minimum effort",
                                "problem_slug": "path-with-minimum-effort",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "PwC",
                                        "PayPal",
                                        "Snowflake",
                                        "Zomato",
                                        "NVIDIA",
                                        "Salesforce",
                                        "Uber",
                                        "McKinsey & Company",
                                        "MongoDB",
                                        "Visa",
                                        "Airbnb",
                                        "OYO Rooms",
                                        "Red Hat",
                                        "Oracle",
                                        "IBM",
                                        "Bloomberg",
                                        "Etsy",
                                        "Unity Technologies",
                                        "Bungie",
                                        "Johnson & Johnson",
                                        "Pinterest",
                                        "Texas Instruments",
                                        "Robinhood",
                                        "Splunk",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept underlying this problem is similar to the logic used in routing and navigation software, such as Google Maps or Waze. In these applications, the idea is to find the shortest or least effort route between two points. But instead of considering differences in heights, they use factors such as distance, traffic, and road conditions to decide what the 'effort' of a potential route would be. In fact, this programming problem essentially models what is known as 'cost-based pathfinding,' which is a common problem in computer science for designing intelligent routing systems in various domains, not just geospatial navigation!",
                                    "hints": [
                                        {
                                            "hint": "Use a min-heap (priority queue) where each entry contains (effort, row, col), prioritizing smaller efforts. Maintain a minEffort[][] matrix initialized to , where minEffort[r][c] stores the smallest effort required to reach cell (r, c)."
                                        },
                                        {
                                            "hint": "\"Start at (0,0) with effort 0, and use Dijkstras relaxation technique to update neighboring cells, pushing valid lower-effort paths into the heap. Once (rows-1, columns-1) is reached, return the minimum possible effort required. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BFS is optimal for unweighted shortest path problems, but here, paths have varying efforts (weights).\nBFS does not consider the minimum effort constraint optimally, making it inefficient for this problem.",
                                            "question": "Why cant we use BFS directly?"
                                        },
                                        {
                                            "answer": "Instead of computing the shortest path directly, Binary Search finds the smallest effort where a valid path exists.\nBFS/DFS is used to verify whether an effort limit is feasible.",
                                            "question": "How does Binary Search + BFS/DFS work?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Using Fibonacci Heap, the time complexity can be improved to O(mn log log (mn)).",
                                            "question": "Can we optimize Dijkstras approach further?"
                                        },
                                        {
                                            "answer": "The adjacency condition would change to include diagonal neighbors, but the algorithm remains the same.",
                                            "question": "What if diagonal movements were allowed?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_cheapestflightwithinkstops",
                                "problem_name": "Cheapest flight within K stops",
                                "problem_slug": "cheapest-flight-within-k-stops",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "OYO Rooms",
                                        "Cerner",
                                        "AMD",
                                        "Cloudflare",
                                        "HCL Technologies",
                                        "Zomato",
                                        "Walmart",
                                        "Pinterest",
                                        "Twilio",
                                        "PwC",
                                        "JPMorgan Chase",
                                        "Ubisoft",
                                        "eBay",
                                        "Bungie",
                                        "Freshworks",
                                        "Roche",
                                        "Instacart",
                                        "McKinsey & Company",
                                        "IBM",
                                        "Deloitte",
                                        "Intel",
                                        "Mastercard",
                                        "Teladoc Health",
                                        "NVIDIA",
                                        "Epic Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem underpins the fundamental operations of various travel and accommodation booking apps such as Expedia, Skyscanner, or Google Flights. These platforms utilize algorithms rooted in graph theory to find the cheapest or most convenient routes between locations by considering factors such as price, transit cities (stops), and directness of the route. The problem is essentially a variant of the shortest path problem with a constraint on the number of edges, which translates to the maximum number of stops in a flight journey in applications.",
                                    "hints": [
                                        {
                                            "hint": "Since we must limit the number of stops (k), a BFS-like approach with a priority queue (similar to Dijkstras) is ideal. Instead of using a standard dist[] array (which tracks the shortest path without considering stops), we use a tuple (cost, node, stops) in a min-heap (priority queue)."
                                        },
                                        {
                                            "hint": "If we reach dst within k+1 levels (since k refers to intermediate stops, not total edges), return the cost."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A min-heap (priority queue) allows us to always expand the cheapest flight path first, ensuring we find the optimal solution faster.",
                                            "question": "Why use a priority queue instead of a simple queue (BFS)?"
                                        },
                                        {
                                            "answer": "The number of stops constraint makes it different from classical shortest path problems, requiring BFS-style expansion or Bellman-Ford modifications.",
                                            "question": "How does this problem compare to the standard shortest path problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The graph would require multiple weight components (cost + time), needing multi-objective optimization techniques.",
                                            "question": "What if additional constraints were introduced, such as layover time between flights?"
                                        },
                                        {
                                            "answer": "Negative weights dont make sense in flight prices, but if they did, we would need Bellman-Ford to detect negative cycles.",
                                            "question": "What if flights had negative costs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_minimummultiplicationstoreachend",
                                "problem_name": "Minimum multiplications to reach end",
                                "problem_slug": "minimum-multiplications-to-reach-end",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Rakuten",
                                        "eBay",
                                        "HCL Technologies",
                                        "Etsy",
                                        "Ernst & Young",
                                        "American Express",
                                        "Philips Healthcare",
                                        "McKinsey & Company",
                                        "Cerner",
                                        "GE Healthcare",
                                        "Deloitte",
                                        "Oracle",
                                        "Target",
                                        "Johnson & Johnson",
                                        "Unity Technologies",
                                        "HashiCorp",
                                        "OYO Rooms",
                                        "Lyft",
                                        "Texas Instruments",
                                        "AMD",
                                        "Cloudflare",
                                        "Stripe",
                                        "Pinterest",
                                        "Walmart",
                                        "Activision Blizzard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This sort of optimization problem, where one seeks to achieve a certain result in the fewest steps or the lowest cost, finds broad application in logistic optimisation in the software industry. An example can be seen in supply chain software, where this kind of problem is routinely solved to optimize transportation routes or inventory maintenance in order to reduce costs and increase efficiency. Here, the \"start\" and \"end\" might represent inventory levels at two different locations, and the numbers in the array could represent efficiencies of various transport options or suppliers.",
                                    "hints": [
                                        {
                                            "hint": "Use a queue where each entry contains (current_value, steps_taken). Maintain a visited set (or boolean array of size 100000) to avoid cycles."
                                        },
                                        {
                                            "hint": "Process each number, generate new numbers (current * num) % 100000 for each num in arr, and enqueue them if they haven't been visited. If end is reached, return the number of steps. If the queue is exhausted, return -1."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "BFS guarantees finding the minimum steps first, as it explores all numbers at step k before moving to step k+1.",
                                            "question": "Why does BFS work best for this problem?"
                                        },
                                        {
                                            "answer": "The modulo ensures numbers stay bounded within 0-99999, preventing overflow and keeping the graph finite.",
                                            "question": "Why do we take modulo 100000?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The graph would contain both multiplication and division edges, requiring careful handling of non-integer results.",
                                            "question": "What if we allowed division (/ operation) along with multiplication?"
                                        },
                                        {
                                            "answer": "No, because this is a shortest path search problem, not an optimization problem with overlapping subproblems.",
                                            "question": "Can this be solved using Dynamic Programming?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_numberofwaystoarriveatdestination",
                                "problem_name": "Number of ways to arrive at destination",
                                "problem_slug": "number-of-ways-to-arrive-at-destination",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "Western Digital",
                                        "Electronic Arts",
                                        "Cloudflare",
                                        "JPMorgan Chase",
                                        "ARM",
                                        "Roblox",
                                        "Riot Games",
                                        "HCL Technologies",
                                        "Goldman Sachs",
                                        "Zomato",
                                        "Walmart",
                                        "IBM",
                                        "Ernst & Young",
                                        "Alibaba",
                                        "Databricks",
                                        "GE Healthcare",
                                        "Siemens Healthineers",
                                        "Boston Consulting Group",
                                        "Epic Games",
                                        "Snowflake",
                                        "Oracle",
                                        "Philips Healthcare",
                                        "MongoDB",
                                        "Docker",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This programming problem resembles the widespread real life applications in route optimization, which is one of the key tasks handled by GPS and mapping services like Google Maps, Uber, and Lyft, etc. Their algorithms not only have to calculate the fastest route from point A to point B, but also provide alternatives in case the initial route is blocked or traffic conditions change. A high-level solution to this problem often involves the usage of Dijkstra's algorithm or Bellman Ford's algorithm for finding the shortest path in a graph, seen regularly in logistics, supply chain management and transport industries. The concept of finding the number of ways to reach a destination in the shortest time can be beneficial in providing multiple optimal route recommendations.",
                                    "hints": [
                                        {
                                            "hint": "Use Dijkstras Algorithm with a priority queue (min-heap). Maintain a distance array (dist[]) initialized to infinity () for all intersections except dist[0] = 0."
                                        },
                                        {
                                            "hint": "Maintain a ways array (ways[]), where ways[i] stores the number of ways to reach intersection i using the shortest path. Initialize ways[0] = 1. Process nodes in priority queue (smallest travel time first). For each neighbor v of u, If dist[v] > dist[u] + time, update dist[v] and reset ways[v] = ways[u] and If dist[v] == dist[u] + time, increment ways[v] += ways[u] (since a new shortest path to v is found)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If a new shorter path is found, reset ways[v] = ways[u].\nIf an equally short path is found, add ways[u] to ways[v].",
                                            "question": "How do we handle multiple shortest paths to a node?"
                                        },
                                        {
                                            "answer": "BFS works for unweighted graphs, but here roads have varying travel times, requiring weighted shortest path algorithms.",
                                            "question": "Why use Dijkstras Algorithm instead of BFS?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent list to reconstruct paths via backtracking.",
                                            "question": "How would you modify the algorithm to return all actual paths instead of just the count?"
                                        },
                                        {
                                            "answer": "Floyd-Warshall finds shortest paths between all pairs (O(n)), while Dijkstras is efficient for single-source shortest paths (O((n + m) log n)).",
                                            "question": "How does this compare to Floyd-Warshall?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_bellmanfordalgorithm",
                                "problem_name": "Bellman ford algorithm",
                                "problem_slug": "bellman-ford-algorithm",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "Pinterest",
                                        "JPMorgan Chase",
                                        "Ubisoft",
                                        "HashiCorp",
                                        "DoorDash",
                                        "Cloudflare",
                                        "MongoDB",
                                        "Unity Technologies",
                                        "American Express",
                                        "Rockstar Games",
                                        "Stripe",
                                        "Lyft",
                                        "Roblox",
                                        "KPMG",
                                        "Salesforce",
                                        "Electronic Arts",
                                        "Teladoc Health",
                                        "Twilio",
                                        "Red Hat",
                                        "Ernst & Young",
                                        "Micron Technology",
                                        "Walmart",
                                        "Intel",
                                        "Texas Instruments",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem of finding the shortest path in a weighted, directed graph is a fundamental component of many practical applications in software development. For instance, it forms the backbone of routing protocols used in GPS systems or mapping software (like Google Maps), allowing them to calculate the shortest or fastest route between two points. In these routing systems, vertices can represent intersections or waypoints, while weights can represent distance or travel time. Detecting a negative cycle can be useful as it can represent a routing error or \"time paradox\" in scheduling or network applications where travel or processing time is represented.",
                                    "hints": [
                                        {
                                            "hint": "If any distance further decreases on the Vth iteration, a negative weight cycle exists, so return -1. Return the dist[] array with distances for all vertices, replacing unreachable nodes with 10^9."
                                        },
                                        {
                                            "hint": "Initialize a dist[] array with infinity (10^9) for all vertices except dist[S] = 0. Relax all edges V-1 times (since the shortest path in a graph with V nodes requires at most V-1 edges)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Dijkstras Algorithm does not work with negative weights, whereas Bellman-Ford handles negative weights and detects cycles.",
                                            "question": "Why use Bellman-Ford instead of Dijkstras Algorithm?"
                                        },
                                        {
                                            "answer": "Yes, using early stopping: If no distance updates occur in an iteration, we can terminate early.",
                                            "question": "Can we optimize Bellman-Ford?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Using the SPFA Algorithm (Shortest Path Faster Algorithm), which is an optimized queue-based Bellman-Ford, improving efficiency for sparse graphs.",
                                            "question": "Can we improve performance further?"
                                        },
                                        {
                                            "answer": "Maintain a parent array to track the previous node in the shortest path and reconstruct it via backtracking.",
                                            "question": "How would you modify the algorithm to return the actual shortest path, not just distances?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_floydwarshallalgorithm",
                                "problem_name": "Floyd warshall algorithm",
                                "problem_slug": "floyd-warshall-algorithm",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Robinhood",
                                        "Ubisoft",
                                        "AMD",
                                        "Zynga",
                                        "Airbnb",
                                        "Oracle",
                                        "Shopify",
                                        "NVIDIA",
                                        "Johnson & Johnson",
                                        "PwC",
                                        "Bloomberg",
                                        "Bungie",
                                        "Stripe",
                                        "Dropbox",
                                        "Unity Technologies",
                                        "Qualcomm",
                                        "Zoho",
                                        "JPMorgan Chase",
                                        "Byju's",
                                        "Riot Games",
                                        "Databricks",
                                        "Square",
                                        "Wayfair",
                                        "Zomato",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a direct application of the Floyd-Warshall algorithm, a core concept utilized in the field of routing and navigation. Software applications like Google Maps, GPS systems, and various shipping and logistics platforms often use variations of this algorithm to calculate and suggest the shortest path from one location to another. This not only saves time but is also essential for enhancing the route efficiency of autonomous vehicles, drones and robotic systems.",
                                    "hints": [
                                        {
                                            "hint": "\" Initialize a dist[][] matrix: If matrix[i][j] != -1, set dist[i][j] = matrix[i][j]. If i == j, set dist[i][i] = 0. If matrix[i][j] == -1, set dist[i][j] =  (indicating no direct path).\""
                                        },
                                        {
                                            "hint": "\"Run three nested loops (O(V)): Use each vertex k as an intermediate node and check if going through k provides a shorter path and Detect negative weight cycles.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Floyd-Warshall computes all-pairs shortest paths in O(V), whereas Dijkstras needs O(V log V + VE), making it inefficient for dense graphs.",
                                            "question": "Why use Floyd-Warshall instead of Dijkstras Algorithm?"
                                        },
                                        {
                                            "answer": "Floyd-Warshall (O(V)) is ideal for dense graphs.\nBellman-Ford (O(VE)) is more useful for sparse graphs with negative weights.",
                                            "question": "How does Floyd-Warshall compare to Bellman-Ford?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent matrix (next[][]), updating it during relaxation to track the intermediate vertices.",
                                            "question": "What if we needed to reconstruct the shortest paths, not just distances?"
                                        },
                                        {
                                            "answer": "Floyd-Warshall is infeasible; instead, use Johnsons Algorithm (O(V log V + VE)), which combines Dijkstras and Bellman-Ford for better efficiency.",
                                            "question": "What if the graph was very large (V > 10^4)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_shortestpathalgorithms_findthecitywiththesmallestnumberofneighbors",
                                "problem_name": "Find the city with the smallest number of neighbors",
                                "problem_slug": "find-the-city-with-the-smallest-number-of-neighbors",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "Alibaba",
                                        "GE Healthcare",
                                        "Boston Consulting Group",
                                        "Goldman Sachs",
                                        "Qualcomm",
                                        "Mastercard",
                                        "Siemens Healthineers",
                                        "Philips Healthcare",
                                        "Airbnb",
                                        "Broadcom",
                                        "Seagate Technology",
                                        "Optum",
                                        "Epic Systems",
                                        "McKinsey & Company",
                                        "Stripe",
                                        "Zoho",
                                        "Rakuten",
                                        "PayPal",
                                        "Robinhood",
                                        "Morgan Stanley",
                                        "Epic Games",
                                        "Roblox",
                                        "Micron Technology",
                                        "HCL Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem mimics the core concept of routing in the field of computer networks and telecommunications. In real world, think of these cities as 'nodes' and the connections between them as 'edges'. This type of problem is solved using algorithms like Dijkstra's or the Floyd-Warshall algorithm in the design of routing protocols for networks, where it is crucial to determine the nearest or least-cost path from one node to another. While it's not about finding a city with the smallest number of reachable cities, the method to find shortest paths in a network is definitely a practical application of this problem. It's a routine part of the functionality of essential tech parts, such as Internet routers, Google Maps, GPS systems, and more.",
                                    "hints": [
                                        {
                                            "hint": "Construct an adjacency matrix dist[][] and Run Floyd-Warshall Algorithm (O(n)) to compute the shortest distance between all pairs of cities."
                                        },
                                        {
                                            "hint": "For each city, count the number of reachable cities within the given Threshold distance. Identify the city with the fewest reachable cities. If theres a tie, return the city with the highest index."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If so, use the minimum weight among them when constructing the adjacency matrix.",
                                            "question": "Can there be multiple roads between the same cities?"
                                        },
                                        {
                                            "answer": "If dist[i][j] > Threshold, city j is not considered reachable from i.",
                                            "question": "How do we handle cities that are unreachable?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Bellman-Ford (O(nm)) would be needed for negative weights, as Floyd-Warshall does not work with negative cycles.",
                                            "question": "What if edges had negative weights?"
                                        },
                                        {
                                            "answer": "Use Dijkstras Algorithm on demand instead of recomputing all-pairs shortest paths.",
                                            "question": "How would we handle dynamic graph changes (adding/removing edges)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_minimumspanningtree",
                        "subcategory_name": "Minimum Spanning Tree",
                        "subcategory_slug": "minimum-spanning-tree",
                        "subcategory_rank": 6,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_minimumspanningtree_msttheory",
                                "problem_name": "MST theory",
                                "problem_slug": "mst-theory",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "JPMorgan Chase",
                                        "Morgan Stanley",
                                        "Goldman Sachs",
                                        "Salesforce",
                                        "Optum",
                                        "Riot Games",
                                        "Splunk",
                                        "Etsy",
                                        "Seagate Technology",
                                        "Electronic Arts",
                                        "Deloitte",
                                        "American Express",
                                        "Databricks",
                                        "OYO Rooms",
                                        "Red Hat",
                                        "Uber",
                                        "Lyft",
                                        "Robinhood",
                                        "HCL Technologies",
                                        "Epic Systems",
                                        "Instacart",
                                        "Activision Blizzard",
                                        "Zomato",
                                        "Texas Instruments",
                                        "Ubisoft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            },
                            {
                                "problem_id": "graphs_graphs_minimumspanningtree_disjointset",
                                "problem_name": "Disjoint Set",
                                "problem_slug": "disjoint-set-",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Alibaba",
                                        "Riot Games",
                                        "PayPal",
                                        "Walmart",
                                        "Ernst & Young",
                                        "Docker",
                                        "NVIDIA",
                                        "Medtronic",
                                        "Reddit",
                                        "Siemens Healthineers",
                                        "Etsy",
                                        "Rakuten",
                                        "Intel",
                                        "Salesforce",
                                        "HCL Technologies",
                                        "Target",
                                        "Broadcom",
                                        "Databricks",
                                        "Optum",
                                        "Red Hat",
                                        "Chewy",
                                        "Electronic Arts",
                                        "PwC",
                                        "Splunk",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The union-find data structure, or the disjoint set, is specifically designed for efficient handling of the equivalence relation problem. It plays a fundamental part in some very popular real-world applications. For example, it is a key component in Kruskal's algorithm, which is a widely used algorithm to find the minimum spanning tree in a graph. The minimum spanning tree has plenty of utilities, from designing the efficient networking in telecom industry to powering the recommendation engines in apps like Netflix, where it's used to cluster users based on their viewing patterns. The rank and size heuristics are used to optimize the efficiency of the union-find operations, making these applications even more performant in solving real-world problems.",
                                    "hints": [
                                        {
                                            "hint": "When calling find(), update the parent pointer to the root, making future lookups O(1). "
                                        },
                                        {
                                            "hint": "\"Attach the smaller height tree to the larger height tree to keep the structure balanced.  Attach the smaller set to the larger set to keep set sizes balanced.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Without it, finding the root takes O(n) in the worst case. Path compression flattens the structure, making future lookups nearly O(1).",
                                            "question": "Why does Union-Find need Path Compression?"
                                        },
                                        {
                                            "answer": "No, we should only use one heuristic at a time. Using both would reduce effectiveness because size-based merging does not directly track tree height.",
                                            "question": "Can we use Union by Rank and Union by Size together?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Extend parent[] and rank[]/size[] dynamically using a hash map instead of fixed arrays.",
                                            "question": "How would this change if nodes were added dynamically?"
                                        },
                                        {
                                            "answer": "Maintain a list of elements in each component and update it during union().",
                                            "question": "What if we wanted to track the actual connected components?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_minimumspanningtree_findthemstweight",
                                "problem_name": "Find the MST weight",
                                "problem_slug": "find-the-mst-weight",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Texas Instruments",
                                        "Optum",
                                        "American Express",
                                        "Deloitte",
                                        "Bungie",
                                        "Walmart",
                                        "Rakuten",
                                        "Docker",
                                        "Instacart",
                                        "Freshworks",
                                        "Seagate Technology",
                                        "Unity Technologies",
                                        "Visa",
                                        "Qualcomm",
                                        "Airbnb",
                                        "Micron Technology",
                                        "Alibaba",
                                        "Splunk",
                                        "IBM",
                                        "Broadcom",
                                        "Square",
                                        "Activision Blizzard",
                                        "Philips Healthcare",
                                        "Roblox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of a Minimum Spanning Tree, as outlined in the problem statement, is a fundamental algorithm used within network design. It plays a key role in practical applications such as the design of computer, telecommunication, and transportation networks. In any such network, it is crucial to connect all nodes with the minimum possible cost, hence the need for an MST. Its also used in data clustering algorithms (like hierarchical clustering) in machine learning, and image segmentation in computer vision.",
                                    "hints": [
                                        {
                                            "hint": "Sort edges in ascending order of weight. Use Disjoint Set (Union-Find with Path Compression & Union by Rank) to keep track of connected components. Iterate over sorted edges. If an edge does not form a cycle, include it in the MST and merge the components. If V-1 edges have been included, stop (MST is complete). Return the sum of MST edge weights."
                                        },
                                        {
                                            "hint": "Use a priority queue (min-heap) to always expand the lightest edge connected to the MST. Maintain a visited set and a cost array to track the cheapest edge connecting each vertex to the MST. Extract the minimum-weight edge and expand the MST iteratively until all vertices are included. Return the sum of MST edge weights."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If weights are not unique, multiple valid MSTs can exist, but their total weight is always the same.",
                                            "question": "What if multiple MSTs exist?"
                                        },
                                        {
                                            "answer": "A tree with V nodes always has V-1 edges, ensuring minimal connectivity without cycles.",
                                            "question": "Why does an MST always have exactly V-1 edges?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store edges in a result list during MST construction.",
                                            "question": "How would we modify the algorithm to return the actual MST edges, not just the weight sum?"
                                        },
                                        {
                                            "answer": "MST algorithms work even with negative weights as long as the graph is connected.",
                                            "question": "What if the graph had negative weights?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_hardproblemsii",
                        "subcategory_name": "Hard Problems II",
                        "subcategory_slug": "hard-problems-ii",
                        "subcategory_rank": 7,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_hardproblemsii_numberofoperationstomakenetworkconnected",
                                "problem_name": "Number of operations to make network connected",
                                "problem_slug": "number-of-operations-to-make-network-connected",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Cerner",
                                        "Visa",
                                        "IBM",
                                        "Riot Games",
                                        "Bloomberg",
                                        "Boston Consulting Group",
                                        "MongoDB",
                                        "Docker",
                                        "AMD",
                                        "Wayfair",
                                        "JPMorgan Chase",
                                        "PayPal",
                                        "eBay",
                                        "Western Digital",
                                        "Micron Technology",
                                        "Shopify",
                                        "Dropbox",
                                        "GE Healthcare",
                                        "Teladoc Health",
                                        "Freshworks",
                                        "KPMG",
                                        "ARM",
                                        "Robinhood",
                                        "Instacart",
                                        "Databricks",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem involves the concept of Graph Theory, which is widely used in numerous fields including software development. A practical example is in network design, specifically the design of minimum spanning trees in telecommunication networks, to ensure every node is connected while minimizing the total length of wires used. Additionally, social networking platforms utilize similar principles to suggest the \"shortest\" path to connect two individuals based on their mutual connections. Hence, ensuring connectivity while minimizing operations echoes the graph optimization algorithms used in software and network design.",
                                    "hints": [
                                        {
                                            "hint": "\"The problem can be solved using Disjoint Set Union (DSU) / Union-Find: Find the number of connected components. If we have c components, at least c-1 edge moves are needed to connect them.\""
                                        },
                                        {
                                            "hint": "\"Initialize a Union-Find data structure for n nodes. Union all edges and track the number of connected components. Count the number of extra edges that can be moved. If the number of extra edges is at least c-1, return c-1; otherwise, return -1.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A tree with n nodes has exactly n-1 edges.\nAny graph with fewer than n-1 edges must be disconnected.",
                                            "question": "Why must there be at least n-1 edges to connect the graph?"
                                        },
                                        {
                                            "answer": "An extra edge is one that does not contribute to merging components, meaning the two vertices it connects are already in the same set",
                                            "question": "How do we count \"extra edges\"?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Kruskals also uses Union-Find, but instead of merging extra edges, it selects minimum weight edges.",
                                            "question": "How does this compare to Kruskals Algorithm for Minimum Spanning Trees?"
                                        },
                                        {
                                            "answer": "This would turn into a Minimum Cost Spanning Tree (MCST) problem, solvable with Prims or Kruskals Algorithm.",
                                            "question": "What if adding new edges had a cost associated with them?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblemsii_accountsmerge",
                                "problem_name": "Accounts merge",
                                "problem_slug": "accounts-merge",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "OYO Rooms",
                                        "Electronic Arts",
                                        "Snowflake",
                                        "Zynga",
                                        "Epic Systems",
                                        "Qualcomm",
                                        "Airbnb",
                                        "Optum",
                                        "DoorDash",
                                        "Ernst & Young",
                                        "Shopify",
                                        "Micron Technology",
                                        "McKinsey & Company",
                                        "Wayfair",
                                        "Bain & Company",
                                        "PayPal",
                                        "GE Healthcare",
                                        "Flipkart",
                                        "Stripe",
                                        "Walmart",
                                        "Cloudflare",
                                        "Red Hat",
                                        "Broadcom",
                                        "HashiCorp",
                                        "Seagate Technology",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is actually a critical part of many modern communication apps and customer relationship management (CRM) systems. These systems often need to process thousands of accounts or user profiles from various sources and merge duplicates to ensure consistency and accuracy in managing user or customer data. This process, called deduplication, is an everyday problem, especially where data is sourced from multiple inputs, like social media, customer feedback, emails etc. An efficient algorithm to solve this in real-time can significantly improve the UX for customer support systems and data analytics tasks.",
                                    "hints": [
                                        {
                                            "hint": "Map each email to a unique identifier (index) using Union-Find. Merge emails that belong to the same account by performing Union operations on them."
                                        },
                                        {
                                            "hint": "\"Group all emails by their root parent and store them under the correct name. Sort and format the result to match the required output. \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Union-Find is more efficient (O(N log N)) compared to DFS/BFS (O(N)) for merging components.",
                                            "question": "Why use Union-Find instead of DFS/BFS?"
                                        },
                                        {
                                            "answer": "No, since we need to track email relationships, we need extra space for Union-Find and email mappings.",
                                            "question": "Can we merge accounts in-place without extra storage?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This would require a bipartite graph representation rather than Union-Find.",
                                            "question": "How would this change if emails had multiple owners?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblemsii_numberofislandsii",
                                "problem_name": "Number of islands II",
                                "problem_slug": "number-of-islands-ii",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Visa",
                                        "Byju's",
                                        "Zomato",
                                        "Walmart",
                                        "Wayfair",
                                        "Stripe",
                                        "Zynga",
                                        "PayPal",
                                        "Dropbox",
                                        "Splunk",
                                        "McKinsey & Company",
                                        "Roblox",
                                        "Rockstar Games",
                                        "Etsy",
                                        "Red Hat",
                                        "JPMorgan Chase",
                                        "Reddit",
                                        "Uber",
                                        "Siemens Healthineers",
                                        "Activision Blizzard",
                                        "American Express",
                                        "IBM",
                                        "Riot Games",
                                        "Swiggy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a perfect representation of how geographical information systems (GIS) work. In GIS software, they constantly deal with similar situations. Land mass configuration, changes over time, and pinpointing particular areas on the maps are an everyday task for them. Watershed modeling, environmental changes, town planning, or even video games that deal with terrain generation could use an algorithm that solves this problem.",
                                    "hints": [
                                        {
                                            "hint": "The optimal way to track connected components is using Disjoint Set Union (DSU) (also called Union-Find)."
                                        },
                                        {
                                            "hint": "\"Treat each land cell as a node in a disjoint set. When a cell (r, c) is converted into land. It initially forms a new island. Check its four neighbors (up, down, left, right). If any neighbor is also land (1), merge them using Union-Find. Step 3: After each operation, return the current number of distinct islands\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Union-Find efficiently handles incremental merging in O((nm)) (near constant time), whereas DFS/BFS (O(nm)) would re-traverse the grid repeatedly.",
                                            "question": "Why use Union-Find instead of BFS/DFS?"
                                        },
                                        {
                                            "answer": "Path Compression ensures nearly constant-time (O((nm))) find operations.\nUnion by Rank/Size keeps the DSU structure balanced.",
                                            "question": "How does Union-Find efficiently track islands?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a hashmap-based Union-Find instead of a fixed n x m matrix.",
                                            "question": "How would this change if the grid was dynamic (infinite expansion allowed)?"
                                        },
                                        {
                                            "answer": "Yes, using a hashmap for DSU operations instead of a static parent[] array.",
                                            "question": "Can we optimize this further?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblemsii_makingalargeisland",
                                "problem_name": "Making a large island",
                                "problem_slug": "making-a-large-island",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "Freshworks",
                                        "Micron Technology",
                                        "Epic Systems",
                                        "Instacart",
                                        "IBM",
                                        "PwC",
                                        "Red Hat",
                                        "American Express",
                                        "Teladoc Health",
                                        "PayPal",
                                        "Intel",
                                        "Oracle",
                                        "Ernst & Young",
                                        "MongoDB",
                                        "Activision Blizzard",
                                        "Etsy",
                                        "NVIDIA",
                                        "Zynga",
                                        "Robinhood",
                                        "Boston Consulting Group",
                                        "Snowflake",
                                        "Databricks",
                                        "Swiggy",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The underlying concept of this programming problem is extensively used in image processing applications and computer vision. Specifically, these applications use morphological operations which can include expanding the area of a unique color (akin to changing a 0 to a 1 in the problem) and then determining the size of the largest connected component (or the largest island). This can help in identifying and tracking objects or features in an image or video stream. This technique can be used in a variety of industries such as surveillance systems, autonomous vehicle systems, medical imaging processing, and more!",
                                    "hints": [
                                        {
                                            "hint": "\"Label each island with a unique index using DFS and store its size in a hashmap {island_id: size}. For every 0 in the grid, check its adjacent 1s (up, down, left, right). The answer is the maximum size of any modified island. \""
                                        },
                                        {
                                            "hint": "\"Instead of running DFS/BFS for every possible 0 flip, we precompute all islands first and store their sizes. Each 0 can be flipped into 1, and we check how many distinct islands it connects to. The goal is to find a 0 that maximizes the total merged island size.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Precomputing island sizes allows checking in O(1) per 0, instead of repeatedly running DFS/BFS.",
                                            "question": "Why do we store islands separately instead of checking dynamically?"
                                        },
                                        {
                                            "answer": "Use a set to track unique island IDs around a 0 before summing their sizes.",
                                            "question": "How do we ensure we dont double-count islands when flipping 0 to 1?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Its similar, but here we precompute islands instead of dynamically exploring them.",
                                            "question": "How does this compare to flood-fill problems?"
                                        },
                                        {
                                            "answer": "Use Disjoint Set Union (DSU) for merging islands dynamically instead of DFS-based labeling.",
                                            "question": "Can we optimize further?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_hardproblemsii_moststonesremovedwithsameroworcolumn",
                                "problem_name": "Most stones removed with same row or column",
                                "problem_slug": "most-stones-removed-with-same-row-or-column",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Shopify",
                                        "IBM",
                                        "Bungie",
                                        "Epic Systems",
                                        "Pinterest",
                                        "MongoDB",
                                        "Ernst & Young",
                                        "Intel",
                                        "Wayfair",
                                        "Goldman Sachs",
                                        "PwC",
                                        "McKinsey & Company",
                                        "AMD",
                                        "Morgan Stanley",
                                        "Broadcom",
                                        "Twilio",
                                        "OYO Rooms",
                                        "Uber",
                                        "Unity Technologies",
                                        "eBay",
                                        "Bloomberg",
                                        "Freshworks",
                                        "Visa",
                                        "Cerner",
                                        "HCL Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is useful in the domain of game development, computational geometry, and artificial intelligence. For instance, in strategy games like Go or Chess where stone (or piece) removal based on certain conditions is part of the game logic. The underlying concept can also be applied in spatial data processing, such as Geographic Information Systems (GIS) on tasks where you might want to remove some duplicate points from the same latitudes or longitudes. This problem helps program those types of scenarios effectively and efficiently.",
                                    "hints": [
                                        {
                                            "hint": "\"reat each row and column as a node and stones as edges connecting them. Merge stones that share the same row or column using Union-Find. If there are C connected components, at least C stones must remain. The maximum stones that can be removed is n - C.\""
                                        },
                                        {
                                            "hint": "\"Build a graph where each stone is a node. Perform DFS/BFS to count connected components. The maximum removals is again n - C.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Union-Find efficiently tracks connected components in O(n log n), whereas naive sorting takes O(n).",
                                            "question": "Why use Union-Find instead of sorting and iterating?"
                                        },
                                        {
                                            "answer": "Stones are merged by row or column into a single component using path compression and union by rank.",
                                            "question": "How does merging stones work in Union-Find?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, using rank-based optimizations and path compression to ensure near O(1) operations.",
                                            "question": "Can we optimize Union-Find further?"
                                        },
                                        {
                                            "answer": "Use graph traversal techniques to determine the best batch removals.",
                                            "question": "What if multiple removals were allowed in one step?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_additionalalgorithms",
                        "subcategory_name": "Additional Algorithms",
                        "subcategory_slug": "additional-algorithms",
                        "subcategory_rank": 8,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "graphs_graphs_additionalalgorithms_kosaraju'salgorithm",
                                "problem_name": "Kosaraju's algorithm",
                                "problem_slug": "kosaraju's-algorithm",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Lyft",
                                        "Goldman Sachs",
                                        "Airbnb",
                                        "Bain & Company",
                                        "Dropbox",
                                        "Johnson & Johnson",
                                        "HCL Technologies",
                                        "Intel",
                                        "Byju's",
                                        "JPMorgan Chase",
                                        "Zomato",
                                        "Freshworks",
                                        "Ernst & Young",
                                        "Epic Games",
                                        "MongoDB",
                                        "Visa",
                                        "Nutanix",
                                        "Pinterest",
                                        "AMD",
                                        "NVIDIA",
                                        "Philips Healthcare",
                                        "Qualcomm",
                                        "Rakuten",
                                        "Optum",
                                        "DoorDash",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of finding strongly connected components in a directed graph has real-world applications in many fields like social media, search engines, and recommendation systems. Did you know, in social media, it is used to identify tightly-knit community structures? For example, one where everyone is friends with everyone else or everyone follows everyone else. It also helps in analyzing web pages, where each page is a vertex and hyperlinks are directed edges. By finding the strongly connected components, search engines can identify groups of pages that are highly interlinked, improving search results. So, next time when you see groups in your social media or clustered search results remember, it's derived from this graph problem!",
                                    "hints": [
                                        {
                                            "hint": " Perform DFS in normal order, storing nodes in a stack based on their finishing time (Topological Sort)."
                                        },
                                        {
                                            "hint": "Reverse the graph (transpose the edges) and process nodes in stack order, counting SCCs using another DFS."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A stack ensures correct DFS finish order, which is necessary for SCC detection.",
                                            "question": "Why use a stack instead of directly processing nodes in reverse order?"
                                        },
                                        {
                                            "answer": "It ensures that when DFS runs on the transposed graph, we never jump between SCCs.",
                                            "question": "Why does processing nodes in decreasing finish time guarantee SCCs?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Each disconnected component is treated separately, and SCCs are identified normally.",
                                            "question": "How does Kosarajus Algorithm handle disconnected graphs?"
                                        },
                                        {
                                            "answer": "In an undirected graph, SCCs become connected components, and we can use a simple DFS/BFS.",
                                            "question": "What if the graph was undirected?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_additionalalgorithms_bridgesingraph",
                                "problem_name": "Bridges in graph",
                                "problem_slug": "bridges-in-graph",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Ernst & Young",
                                        "ARM",
                                        "Dropbox",
                                        "Epic Systems",
                                        "Deloitte",
                                        "HCL Technologies",
                                        "Splunk",
                                        "AMD",
                                        "Pinterest",
                                        "Chewy",
                                        "Western Digital",
                                        "Snowflake",
                                        "PayPal",
                                        "Goldman Sachs",
                                        "Flipkart",
                                        "Johnson & Johnson",
                                        "Red Hat",
                                        "Zynga",
                                        "Ubisoft",
                                        "Freshworks",
                                        "Roche",
                                        "Intel",
                                        "Target",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of finding \"bridges\" in a graph is central to network reliability analysis in software-defined networking (SDN). In such networks, nodes represent devices and edges represent connections between them. A bridge node or edge is a critical point that, if failed, could interrupt the entire network communication. Identifying these bridges helps network engineers to design more reliable systems and take necessary precautions to prevent network failure. It's also used in power grid management and social network analysis to identify individuals or connections crucial to the network's overall cohesion.",
                                    "hints": [
                                        {
                                            "hint": "Perform a DFS traversal, tracking discovery time (disc[]) and lowest reachable vertex (low[]) for each node."
                                        },
                                        {
                                            "hint": "If low[v] > disc[u] for an edge (u, v), it means there is no alternative path to reach u from v, making (u, v) a bridge. If low[v] > disc[u], it means v cannot reach back to u without (u, v), confirming a bridge."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A naive approach would remove each edge one by one and check connectivity (O(E * (V + E))), which is too slow.\nTarjans Algorithm finds all bridges in O(V + E) efficiently.",
                                            "question": "Why not use simple DFS to find bridges?"
                                        },
                                        {
                                            "answer": "low[] helps identify whether a subtree has an alternate back edge, preventing false bridge detection.",
                                            "question": "Why use low[] instead of just tracking parent-child relationships?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Bridges exist in simple graphs; parallel edges mean removing one does not disconnect the graph.",
                                            "question": "What if the graph had duplicate edges?"
                                        },
                                        {
                                            "answer": "Yes! Articulation points are found using a similar DFS approach with low[] values.",
                                            "question": "Can we modify the algorithm to find articulation points (cut vertices)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "graphs_graphs_additionalalgorithms_articulationpointingraph",
                                "problem_name": "Articulation point in graph",
                                "problem_slug": "articulation-point-in-graph",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "MongoDB",
                                        "Philips Healthcare",
                                        "Boston Consulting Group",
                                        "Siemens Healthineers",
                                        "GE Healthcare",
                                        "Morgan Stanley",
                                        "IBM",
                                        "Snowflake",
                                        "Oracle",
                                        "Deloitte",
                                        "Teladoc Health",
                                        "Rakuten",
                                        "OYO Rooms",
                                        "eBay",
                                        "Intel",
                                        "ARM",
                                        "NVIDIA",
                                        "Twilio",
                                        "Cloudflare",
                                        "Seagate Technology",
                                        "Johnson & Johnson",
                                        "Epic Systems",
                                        "Ubisoft",
                                        "Flipkart",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem involves finding \"articulation points\" or \"cut vertices\" in a network - which is critical in designing and maintaining efficient and resilient networks. For instance, failure of such points in internet networks can cause a complete shutdown of data transfer across different regions. Similar scenarios can be seen in social networks and power grids where one failure can lead to the disconnection of entire sections. Understanding these points allows for improved network robustness and better disaster recovery strategies.",
                                    "hints": [
                                        {
                                            "hint": "Perform DFS traversal, tracking discovery time (disc[]) and lowest reachable vertex (low[]) for each node."
                                        },
                                        {
                                            "hint": "A vertex u is an articulation point if, It is the root of DFS and has two or more independent children. It is not the root, but some subtree cannot reach an ancestor (i.e., low[v]  disc[u])."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "low[] efficiently tracks whether a subtree has an alternate back edge, ensuring accurate articulation point detection.",
                                            "question": "Why use low[] values instead of tracking parent-child relationships?"
                                        },
                                        {
                                            "answer": "Self-loops do not affect articulation points since they do not contribute to connectivity.",
                                            "question": "How do we handle self-loops or duplicate edges?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Bridges remove edges, while articulation points remove vertices.\nBoth use Tarjans DFS-based approach.",
                                            "question": "How does this relate to finding bridges in a graph?"
                                        },
                                        {
                                            "answer": "Run Tarjans DFS separately for each component.",
                                            "question": "What if we needed to return articulation points in multiple disconnected components?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "graphs_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest-graphs",
                        "subcategory_rank": 9,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "farthest_empty_plot_from_buildings",
                                "problem_name": "Furthest Empty Plot From Buildings",
                                "problem_slug": "furthest-empty-plot-from-buildings",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "find_all_possible_tasks",
                                "problem_name": "Find All Possible Tasks",
                                "problem_slug": "find-all-possible-tasks",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "reachable_nodes_before_destruction",
                                "problem_name": "Reachable Nodes Before Destruction",
                                "problem_slug": "reachable-nodes-before-destruction",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "dynamicprogramming",
                "category_name": "Dynamic Programming",
                "category_slug": "dynamic-programming",
                "category_rank": 15,
                "subcategories": [
                    {
                        "subcategory_id": "dynamicprogramming_introduction",
                        "subcategory_name": "Introduction",
                        "subcategory_slug": "introduction",
                        "subcategory_rank": 0,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_introduction_introductiontodp",
                                "problem_name": "Introduction to DP",
                                "problem_slug": "introduction-to-dp",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA-NOIDE",
                                "hasIDE": false
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_1ddp",
                        "subcategory_name": "1D DP",
                        "subcategory_slug": "1d-dp",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_1ddp_climbingstairs",
                                "problem_name": "Climbing stairs",
                                "problem_slug": "climbing-stairs",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "Electronic Arts",
                                        "Salesforce",
                                        "Texas Instruments",
                                        "Databricks",
                                        "ARM",
                                        "Etsy",
                                        "GE Healthcare",
                                        "Pinterest",
                                        "Morgan Stanley",
                                        "Broadcom",
                                        "Twilio",
                                        "Seagate Technology",
                                        "Ernst & Young",
                                        "Dropbox",
                                        "Optum",
                                        "Target",
                                        "Shopify",
                                        "KPMG",
                                        "Micron Technology",
                                        "Lyft",
                                        "NVIDIA",
                                        "Red Hat",
                                        "Robinhood",
                                        "Alibaba",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The underlying concept of this problem is used extensively in routing and navigation software applications such as Google Maps and Waze. These applications use dynamic programming algorithms to calculate the shortest or most efficient path from one location to another by considering all possible routes. This problem can be seen as a simplified, linear version of such a navigation issue, where instead of just 1 or 2 steps, the \"steps\" can be different roads or paths that diverge and converge, leading towards the destination.",
                                    "hints": [
                                        {
                                            "hint": "To solve this problem, consider the last step before reaching n. You could have arrived at step n either from n-1 (by taking a 1-step move) or from n-2 (by taking a 2-step move). Thus, the number of ways to reach step n is the sum of the ways to reach n-1 and n-2. "
                                        },
                                        {
                                            "hint": "A naive recursive approach results in exponential time complexity (O(2^n)) due to repeated computations. Instead, we can use memoization (top-down) or dynamic programming (bottom-up) to compute results efficiently in O(n) time and O(n) space."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The recurrence relation f(n) = f(n-1) + f(n-2) follows the same pattern as the Fibonacci series because each step depends on the sum of the previous two step counts.",
                                            "question": "Why is the Fibonacci sequence relevant here?"
                                        },
                                        {
                                            "answer": "The recurrence relation changes to f(n) = f(n-1) + f(n-2) + f(n-3), increasing the number of ways exponentially.",
                                            "question": "What if we allow jumps of 3 steps instead of just 1 or 2?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Using a bottom-up approach with a loop to compute f(n) from f(0) to f(n), storing only the last two computed values (O(1) space).",
                                            "question": "How can this problem be solved iteratively instead of recursively?"
                                        },
                                        {
                                            "answer": "The problem then transforms into counting paths in a matrix, where dp[i][j] = dp[i-1][j] + dp[i][j-1] to move right or down.",
                                            "question": "How would you modify this problem for a 2D grid, where you can move right or down instead of just forward?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_1ddp_frogjump",
                                "problem_name": "Frog Jump",
                                "problem_slug": "frog-jump",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Zoho",
                                        "MongoDB",
                                        "Cloudflare",
                                        "Zynga",
                                        "Epic Systems",
                                        "AMD",
                                        "Cerner",
                                        "Alibaba",
                                        "Snowflake",
                                        "Etsy",
                                        "eBay",
                                        "Swiggy",
                                        "KPMG",
                                        "OYO Rooms",
                                        "Target",
                                        "Docker",
                                        "Nutanix",
                                        "Wayfair",
                                        "Roche",
                                        "American Express",
                                        "Lyft",
                                        "Ubisoft",
                                        "Dropbox",
                                        "Freshworks",
                                        "Rakuten",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"At each step i, the frog has two choices:  Jump from i-1 to i (cost: abs(heights[i] - heights[i-1])). Jump from i-2 to i (cost: abs(heights[i] - heights[i-2]), if i-2 exists).\""
                                        },
                                        {
                                            "hint": "A recursive approach with memoization avoids recomputing overlapping subproblems but still has O(n) space complexity. Instead, we can use an iterative bottom-up dynamic programming (DP) approach in O(n) time while reducing space to O(1) by keeping track of only the last two computed values."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The recurrence depends on the minimum of two previous states, similar to the staircase problem but with variable costs instead of fixed increments.",
                                            "question": "Why does the recurrence relation resemble the Fibonacci sequence structure?"
                                        },
                                        {
                                            "answer": "The frog will always prefer to take two-step jumps when possible since the energy cost is lower in a downward jump.",
                                            "question": "What happens if the heights are in decreasing order?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the recurrence to allow jumps from any previous step where a jump is allowed, similar to the unbounded knapsack problem.",
                                            "question": "How would you modify this if the frog could take variable jumps given in an array?"
                                        },
                                        {
                                            "answer": "Use a weighted graph approach with Dijkstras algorithm instead of DP, since the cost is no longer based on relative height differences.",
                                            "question": "What if jumping costs were different, not based on height but on predefined energy values per step?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_1ddp_frogjumpwithkdistances",
                                "problem_name": "Frog jump with K distances",
                                "problem_slug": "frog-jump-with-k-distances",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Pinterest",
                                        "Bungie",
                                        "Philips Healthcare",
                                        "Splunk",
                                        "OYO Rooms",
                                        "Intel",
                                        "Siemens Healthineers",
                                        "Seagate Technology",
                                        "Alibaba",
                                        "Electronic Arts",
                                        "Zoho",
                                        "Oracle",
                                        "Unity Technologies",
                                        "Cerner",
                                        "Johnson & Johnson",
                                        "Snowflake",
                                        "American Express",
                                        "McKinsey & Company",
                                        "Etsy",
                                        "Freshworks",
                                        "HCL Technologies",
                                        "Qualcomm",
                                        "Epic Systems",
                                        "ARM",
                                        "Lyft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem can be seen as an example of Dynamic Programming and Graph Theory implemented in routing and network analysis. In fact, it mimics real-world scenarios like Google Maps' task of finding the shortest or least energy-consuming path from one location to another. Google has to take into account various factors such as path lengths, transportation modes, or even varying altitudes (if you're biking or walking) - just as our frog needs the lowest energy path to reach its goal!",
                                    "hints": [
                                        {
                                            "hint": "At each step i, the frog can jump to any step in the range [i+1, i+k], as long as that step exists. This means that to determine the minimum energy required at step i, we check all previous steps up to k steps back and select the minimum energy path."
                                        },
                                        {
                                            "hint": "A brute-force recursive approach would try all possible paths, resulting in an exponential time complexity. Instead, we can use dynamic programming (DP) to compute results iteratively in O(n*k) time and O(n) space. "
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since the frog can jump anywhere within [i-k, i-1], we need to evaluate all possible jumps and pick the one that requires the least energy.",
                                            "question": "Why is the recurrence dp[i] = min(dp[j] + |heights[i] - heights[j]|) necessary?"
                                        },
                                        {
                                            "answer": "The recurrence must be modified so that at every step i, the allowed jump range is [i+1, i+k[i]], where k[i] is an array representing the allowed jump size at step i.",
                                            "question": "How does this problem change if k becomes dynamic (i.e., k changes at every step)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of finding the minimum energy required, we must check if dp[n-1] <= budget, turning it into a bounded DP problem.",
                                            "question": "What if there was an additional constraint that the frog had a limited energy budget?"
                                        },
                                        {
                                            "answer": "No, a greedy approach fails because choosing the lowest energy jump at each step does not guarantee the global minimum.",
                                            "question": "Can this problem be solved using a greedy approach instead of DP?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_1ddp_maximumsumofnonadjacentelements",
                                "problem_name": "Maximum sum of non adjacent elements",
                                "problem_slug": "maximum-sum-of-non-adjacent-elements",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Seagate Technology",
                                        "Zomato",
                                        "Salesforce",
                                        "eBay",
                                        "Zoho",
                                        "Flipkart",
                                        "NVIDIA",
                                        "Red Hat",
                                        "Activision Blizzard",
                                        "Oracle",
                                        "HCL Technologies",
                                        "Qualcomm",
                                        "MongoDB",
                                        "Alibaba",
                                        "McKinsey & Company",
                                        "Visa",
                                        "Mastercard",
                                        "Byju's",
                                        "Rockstar Games",
                                        "Ubisoft",
                                        "Chewy",
                                        "Cerner",
                                        "Snowflake",
                                        "ARM",
                                        "Bungie",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem demonstrates the concept of dynamic programming, which is a method for solving problems by breaking them down into simpler subproblems, and storing the solutions of these subproblems to avoid solving them repeatedly. In real-world applications, dynamic programming is extensively used in optimization problems. One popular example is Google Maps, where dynamic programming algorithms are used to find the shortest path between two locations, maximizing the efficiency of the route while minimizing travel time.",
                                    "hints": [
                                        {
                                            "hint": "\"Consider the two choices at each step i: Take nums[i]  Add nums[i] to the sum and skip the next element (i+1). Skip nums[i]  Move to the next element (i+1) without adding anything.\""
                                        },
                                        {
                                            "hint": "\"Using dynamic programming (O(n)), we store the dp[] values to avoid redundant calculations. Further optimization reduces space complexity from O(n) to O(1), using two variables to track dp[i-1] and dp[i-2].\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "No, a greedy approach (always taking the largest available element) fails because it doesnt consider future consequences (e.g., picking a large element might force skipping multiple good elements).",
                                            "question": "Can we solve this problem using a greedy approach?"
                                        },
                                        {
                                            "answer": "If we include nums[i], we must take dp[i-2] to ensure no adjacent elements are included.\nIf we exclude nums[i], we take dp[i-1] to get the best sum without nums[i].",
                                            "question": "Why is the recurrence relation based on dp[i-1] and dp[i-2]?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of considering all elements, apply the same DP approach only to even numbers.",
                                            "question": "What if there was an additional constraint that elements can only be picked if their value is even?"
                                        },
                                        {
                                            "answer": "This modifies the problem into the circular house robber problem, where we solve for two cases:\nExclude the first element and solve normally.\nExclude the last element and solve normally.\nReturn the maximum of both cases.",
                                            "question": "What if the elements were arranged in a circular array (first and last elements are adjacent)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_1ddp_houserobber",
                                "problem_name": "House robber",
                                "problem_slug": "house-robber",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "American Express",
                                        "Docker",
                                        "OYO Rooms",
                                        "Lyft",
                                        "Walmart",
                                        "Wayfair",
                                        "Etsy",
                                        "Goldman Sachs",
                                        "Zoho",
                                        "McKinsey & Company",
                                        "Unity Technologies",
                                        "Electronic Arts",
                                        "Stripe",
                                        "PayPal",
                                        "KPMG",
                                        "Instacart",
                                        "Alibaba",
                                        "Cerner",
                                        "Bungie",
                                        "Riot Games",
                                        "Cloudflare",
                                        "NVIDIA",
                                        "Boston Consulting Group",
                                        "Optum",
                                        "HashiCorp",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem statement is a classic example of the Dynamic Programming technique used often in software development to enhance efficiency. In practical terms, it is similar to resource allocation problems where companies try to maximize outputs (like profits, productivity, etc.) without violating some set rules. Suppose a company with branches distributed around the world (circular manner) wants to implement a data sync operation. To avoid network congestion, the rule is that two adjacent branches can't perform the sync operation simultaneously. The solution to our robbery problem can help to schedule these operations to ensure maximum data synchronisation without violating the network rule.",
                                    "hints": [
                                        {
                                            "hint": "\"Since house 1 and house n are adjacent, we must solve the problem in two separate cases: Exclude the first house and rob from houses [1:n]. Exclude the last house and rob from houses [0:n-1]. This ensures that we never pick both the first and last houses together.\""
                                        },
                                        {
                                            "hint": "\"Using dynamic programming (O(n)), we store the results in a dp[] array to avoid redundant calculations. Further optimization reduces space complexity from O(n) to O(1), by storing only the last two computed values.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If we allow robbing all houses normally, the robber could pick both first and last houses, violating the circular constraint.",
                                            "question": "Why do we need to consider two cases (exclude first and exclude last)?"
                                        },
                                        {
                                            "answer": "The robber picks alternate houses for the highest total sum, ensuring no two adjacent houses are robbed.",
                                            "question": "What happens if all houses contain the same value?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The recurrence relation changes to: dp[i]=max(dp[i1],dp[i2]+money[i],,dp[ik]+money[i])\nA sliding window approach optimizes this to O(n).",
                                            "question": "What if the robber could skip at most k houses instead of 1?"
                                        },
                                        {
                                            "answer": "Instead of a dp[] array (O(n) space), use two rolling variables (O(1)) to store only the last two computed values.",
                                            "question": "How can we optimize this for extremely large inputs (n > 10^6)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_2ddp",
                        "subcategory_name": "2D DP",
                        "subcategory_slug": "2d-dp",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_2ddp_ninja'straining",
                                "problem_name": "Ninja's training",
                                "problem_slug": "ninja's-training",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Salesforce",
                                        "Qualcomm",
                                        "PwC",
                                        "Seagate Technology",
                                        "HCL Technologies",
                                        "Activision Blizzard",
                                        "Twilio",
                                        "Ernst & Young",
                                        "DoorDash",
                                        "OYO Rooms",
                                        "Zomato",
                                        "American Express",
                                        "Robinhood",
                                        "Optum",
                                        "Walmart",
                                        "Square",
                                        "Philips Healthcare",
                                        "Roblox",
                                        "NVIDIA",
                                        "Siemens Healthineers",
                                        "Teladoc Health",
                                        "Stripe",
                                        "Rakuten",
                                        "MongoDB",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is an example of dynamic programming, a commonly used problem-solving approach in software development. The concept of maximizing merit points over a range of choices without repeating the same activity, is similar to the real-world challenges that software like Google Calendar or Apple Health face. These apps need to suggest optimal fitness or productivity schedules based on a user's availability and preferences, ensuring a range of activities are covered without repetition on consecutive days. Such problems are solved using dynamic programming algorithms, just like this ninja training schedule problem.",
                                    "hints": [
                                        {
                                            "hint": "\"Let dp[i][j] be the maximum merit points possible on day i if the ninja performs activity j (j  {0,1,2}). The ninja must pick an activity different from the previous day's to maximize points. The final answer is the maximum value from the last row of dp\""
                                        },
                                        {
                                            "hint": "\"A recursive approach without memoization leads to exponential complexity (O(3^n)) since we explore all choices. Using dynamic programming (O(n)), we store computed results in dp[][] to avoid redundant calculations.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of a full dp[][] table (O(n * 3) space), maintain three variables tracking the last day's results (O(1)).",
                                            "question": "What is the most optimized approach?"
                                        },
                                        {
                                            "answer": "Extend the recurrence relation to exclude the previously chosen activity: dp[i][j]=max(dp[i1][k]+matrix[i][j])k=j\nThis increases time complexity to O(n * m) for m activities.",
                                            "question": "What if there are more than three activities?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the recurrence to ensure that an activity cannot be picked if it was chosen in the last k days.",
                                            "question": "How would this change if each activity had a cooldown period of k days before being reused?"
                                        },
                                        {
                                            "answer": "Yes, a segment tree allows efficient queries and updates to maximize dynamic merit point allocations.",
                                            "question": "Can this problem be solved using a segment tree for updates in a large dataset?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_dpongrids",
                        "subcategory_name": "DP on grids",
                        "subcategory_slug": "dp-on-grids",
                        "subcategory_rank": 3,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dpongrids_griduniquepaths",
                                "problem_name": "Grid unique paths",
                                "problem_slug": "grid-unique-paths",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Visa",
                                        "Dropbox",
                                        "Cloudflare",
                                        "Electronic Arts",
                                        "Twilio",
                                        "eBay",
                                        "Teladoc Health",
                                        "Ubisoft",
                                        "DoorDash",
                                        "Johnson & Johnson",
                                        "Seagate Technology",
                                        "American Express",
                                        "Airbnb",
                                        "AMD",
                                        "Flipkart",
                                        "Pinterest",
                                        "Optum",
                                        "Uber",
                                        "Instacart",
                                        "Target",
                                        "Epic Systems",
                                        "JPMorgan Chase",
                                        "Ernst & Young",
                                        "PwC",
                                        "Chewy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem corresponds to a well-known algorithmic concept used in pathfinding - giving rise to techniques like Dijkstra's or A* algorithms. These are extensively used in the software industry, notably in GPS software for finding shortest routes, in game development for enabling characters to navigate through a game map, or in logistics and supply chain softwares for optimizing routes. Specifically, such a \"unique ways\" problem introduces the concepts of grid-based pathfinding and combinatorial counting, foundational for these advanced navigational systems.",
                                    "hints": [
                                        {
                                            "hint": "\"The number of ways to reach a cell depends on how you got there: From the left (matrix[i][j-1]) From the top (matrix[i-1][j])\""
                                        },
                                        {
                                            "hint": "\"A recursive approach without memoization results in exponential time complexity (O(2^{m+n})), making it inefficient for large grids. Using dynamic programming (O(m*n)), we store results in a dp[][] table to avoid redundant calculations.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The combinatorial approach (O(1)) is the best, as it avoids unnecessary computations.",
                                            "question": "What is the best approach for large m and n values?"
                                        },
                                        {
                                            "answer": "Unlike Dijkstras algorithm, there are no weightsjust counting paths without obstacles.",
                                            "question": "How does this problem compare to other shortest path problems?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, we can model this as a graph traversal problem, using BFS for unweighted shortest paths.",
                                            "question": "Can this be solved using graph-based algorithms?"
                                        },
                                        {
                                            "answer": "We modify dp[][] to store previous cell choices, then use backtracking to reconstruct the paths.",
                                            "question": "What if we wanted to find the actual paths instead of just counting them?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dpongrids_uniquepathsii",
                                "problem_name": "Unique paths II",
                                "problem_slug": "unique-paths-ii",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "Siemens Healthineers",
                                        "Intel",
                                        "Red Hat",
                                        "DoorDash",
                                        "Alibaba",
                                        "Johnson & Johnson",
                                        "JPMorgan Chase",
                                        "Swiggy",
                                        "Docker",
                                        "Ernst & Young",
                                        "Visa",
                                        "Pinterest",
                                        "Airbnb",
                                        "IBM",
                                        "ARM",
                                        "GE Healthcare",
                                        "Byju's",
                                        "Splunk",
                                        "Mastercard",
                                        "Western Digital",
                                        "Target",
                                        "Epic Games",
                                        "Bungie",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The underlying concept of this problem is extensively used in navigation and mapping services like Google Maps and GPS devices. Algorithms that solve similar pathfinding problems, like the A* algorithm, are designed to calculate the shortest route between two points. They consider obstacles (like blocked roads or traffic) by using a similar concept as the \"1s\" in the provided problem. Essentially, these algorithms navigate through a complex 2D grid very similar to this problem's matrix, but on a much larger and intricate scale.",
                                    "hints": [
                                        {
                                            "hint": "\"Let dp[i][j] represent the number of ways to reach cell (i, j). If matrix[i][j] == 1, the cell is blocked, so dp[i][j] = 0.\""
                                        },
                                        {
                                            "hint": "\"A recursive approach without memoization results in exponential time complexity (O(2^{m+n})), making it inefficient for large grids. Using dynamic programming (O(m*n)), we store computed results in dp[][] to avoid redundant calculations.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "No, because choosing the right or down direction optimally at each step does not guarantee a globally optimal path.",
                                            "question": "Can a greedy approach work?"
                                        },
                                        {
                                            "answer": "No, because obstacles break the uniform structure, making combinatorial formulas ineffective.",
                                            "question": "Can we use the combinatorial approach (O(1)) like in the standard unique paths problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use Dijkstras algorithm or Bellman-Ford algorithm to find the shortest path cost.",
                                            "question": "How would you modify this for a grid with negative weight penalties instead of binary blocks?"
                                        },
                                        {
                                            "answer": "Modify dp[i][j] to track jumps, incorporating teleportation paths dynamically.",
                                            "question": "What if the grid had teleportation cells (T) that allowed instant movement?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dpongrids_minimumpathsumingrid",
                                "problem_name": "Minimum path sum in grid",
                                "problem_slug": "minimum-path-sum-in-grid",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Pinterest",
                                        "Robinhood",
                                        "NVIDIA",
                                        "Goldman Sachs",
                                        "ARM",
                                        "Instacart",
                                        "Airbnb",
                                        "Philips Healthcare",
                                        "Johnson & Johnson",
                                        "Snowflake",
                                        "Cerner",
                                        "HashiCorp",
                                        "eBay",
                                        "Red Hat",
                                        "Etsy",
                                        "Reddit",
                                        "Intel",
                                        "Rakuten",
                                        "Teladoc Health",
                                        "Nutanix",
                                        "Seagate Technology",
                                        "PayPal",
                                        "Epic Systems",
                                        "Wayfair",
                                        "KPMG",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is a typical example of dynamic programming and is practically used in routing and navigation systems in maps. For instance, Google Maps or GPS systems finding the shortest or least congested path from one point to another uses similar concepts. The cells in the matrix can correspond to different routes, and the integer values can be considered as the cost, time or distance of traveling through that route.",
                                    "hints": [
                                        {
                                            "hint": "Let dp[i][j] be the minimum path sum to reach cell (i, j). The answer is the minimum value in the last row:min(dp[m1][0],dp[m1][1],...,dp[m1][n1])"
                                        },
                                        {
                                            "hint": "\"A recursive approach results in exponential time complexity (O(3^m)) due to overlapping subproblems. Using dynamic programming (O(m * n)), store results in a dp[][] table to avoid redundant calculations.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Because the ninja can move down, down-left, or down-right, the optimal path is determined by the minimum sum among these three choices.",
                                            "question": "Why do we take the min() of three possible previous values?"
                                        },
                                        {
                                            "answer": "This is a variant of the weighted shortest path problem, where Dijkstras Algorithm could be used with a priority queue to find the minimum path sum.",
                                            "question": "How does this problem relate to shortest path algorithms?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store parent pointers in dp[][] and backtrack from the minimum cell in the last row.",
                                            "question": "What if we wanted to return the path itself, not just the minimum sum?"
                                        },
                                        {
                                            "answer": "Modify dp[i][j] =  for blocked cells and ensure paths avoid them.",
                                            "question": "What if some cells were blocked (-1 values), making movement impossible?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dpongrids_triangle",
                                "problem_name": "Triangle",
                                "problem_slug": "triangle",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Roche",
                                        "Micron Technology",
                                        "Swiggy",
                                        "Shopify",
                                        "Etsy",
                                        "OYO Rooms",
                                        "Rockstar Games",
                                        "Deloitte",
                                        "Twilio",
                                        "Dropbox",
                                        "McKinsey & Company",
                                        "Cloudflare",
                                        "Instacart",
                                        "Morgan Stanley",
                                        "AMD",
                                        "Epic Systems",
                                        "Goldman Sachs",
                                        "Pinterest",
                                        "JPMorgan Chase",
                                        "Reddit",
                                        "Flipkart",
                                        "Zoho",
                                        "NVIDIA",
                                        "PayPal",
                                        "Texas Instruments",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, also known as the 'Minimum Path Sum in a Triangle', has fundamental relevance in graph theory and network routing. It is used in practical cases such as network routing, where the goal is to find the path of least resistance (or in this case, the least sum). This algorithm is essential for tasks such as Google Maps or other GPS navigation systems to calculate and suggest the shortest or fastest route to a destination.",
                                    "hints": [
                                        {
                                            "hint": "\"Each cells minimum falling path sum depends on the minimum of its reachable previous row elements. dp[i][j]=triangle[i][j]+min(dp[i1][j],dp[i1][j1]) This ensures we accumulate the smallest possible sum while moving downward.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "By solving subproblems from the last row upward, we ensure each subproblem has already been computed, making it an efficient overlapping subproblem approach.",
                                            "question": "Why does the bottom-up approach work best?"
                                        },
                                        {
                                            "answer": "Yes, by treating each transition as a graph traversal, but it would be inefficient (O(n log n)) due to priority queue usage.",
                                            "question": "Can this be solved using a queue-based BFS approach?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, but it would no longer be a DP problem and would require graph traversal techniques like BFS or Dijkstras Algorithm.",
                                            "question": "Can this problem be extended to allow movement in four directions?"
                                        },
                                        {
                                            "answer": "Maintain a parent tracking array to backtrack from the minimum sum path.",
                                            "question": "What if we needed to return the actual path, not just the sum?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dpongrids_cherrypickupii",
                                "problem_name": "Cherry pickup II",
                                "problem_slug": "cherry-pickup-ii",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Chewy",
                                        "Roblox",
                                        "Ubisoft",
                                        "IBM",
                                        "Seagate Technology",
                                        "Medtronic",
                                        "Philips Healthcare",
                                        "Rakuten",
                                        "Robinhood",
                                        "Qualcomm",
                                        "DoorDash",
                                        "Airbnb",
                                        "Square",
                                        "Alibaba",
                                        "PwC",
                                        "Etsy",
                                        "Red Hat",
                                        "Shopify",
                                        "GE Healthcare",
                                        "Texas Instruments",
                                        "Broadcom",
                                        "OYO Rooms",
                                        "eBay",
                                        "Ernst & Young",
                                        "Zomato",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem and its underlying algorithm concepts can find use in real-world applications like video games and robotics. In a gaming scenario, this problem can be used to program artificial intelligence for characters in grid-based turn strategy games, ensuring each character gathers the most resources or points while avoiding collision. In robotics, this might be a real scenario where two robots are tasked to collect items from a given space and the optimized path needs to be calculated to collect maximum items without both robots reaching the same point at the same time. This coordination and optimization problem requires advanced algorithms for efficiency and is a fundamental challenge in multi-robot systems.",
                                    "hints": [
                                        {
                                            "hint": "A recursive approach with memoization is a natural way to solve this problem. Define a function that represents the maximum cherries collected when both robots are at specific positions in a given row. The function should consider all valid moves for both robots and return the optimal value. "
                                        },
                                        {
                                            "hint": "To optimize further, an iterative bottom-up DP approach can be used. Instead of computing values recursively, maintain a DP table where each entry stores the best possible number of cherries collected when the robots are in specific positions. Start from the last row and work upward, simulating the robots' movement constraints."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A greedy approach might seem tempting, such as always moving both robots toward the highest cherry cell in the next row. However, this does not guarantee an optimal solution because it does not account for long-term outcomes. A locally optimal choice may lead to a suboptimal overall collection in later steps.",
                                            "question": "Why cant we solve this problem using a simple greedy approach?"
                                        },
                                        {
                                            "answer": "Since the robots can move diagonally, they may attempt to move beyond the leftmost or rightmost columns. These cases should be handled explicitly in the DP state transition by ignoring moves that place a robot outside the valid column range.",
                                            "question": "What happens if one of the robots goes out of bounds?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "For k robots, the DP state would expand to track k different positions per row instead of just two. The state transition would require iterating over all possible k robot moves, leading to a time complexity of O(n  m^k). While feasible for small k, further optimizations like state compression or heuristic pruning might be needed.",
                                            "question": "How would you modify this problem if there were k robots instead of two?"
                                        },
                                        {
                                            "answer": "Yes! We can model the matrix as a graph where each (i, j) is a node, and edges exist between valid robot moves. A Dijkstra-like algorithm with a priority queue (min-heap or max-heap) can be used to explore the best path efficiently.",
                                            "question": "Can we solve this problem using graph traversal techniques?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_dponstocks",
                        "subcategory_name": "DP on stocks",
                        "subcategory_slug": "dp-on-stocks",
                        "subcategory_rank": 4,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstocks_besttimetobuyandsellstoc",
                                "problem_name": "Best time to buy and sell stock",
                                "problem_slug": "best-time-to-buy-and-sell-stock",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Walmart",
                                        "Intel",
                                        "AMD",
                                        "Etsy",
                                        "MongoDB",
                                        "Boston Consulting Group",
                                        "Zoho",
                                        "Medtronic",
                                        "ARM",
                                        "Target",
                                        "NVIDIA",
                                        "Activision Blizzard",
                                        "Qualcomm",
                                        "IBM",
                                        "Lyft",
                                        "Electronic Arts",
                                        "GE Healthcare",
                                        "Salesforce",
                                        "Reddit",
                                        "PayPal",
                                        "Twilio",
                                        "Robinhood",
                                        "Chewy",
                                        "Snowflake",
                                        "Alibaba",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "While this problem is a simplified version, the concept is used in the development of algorithmic trading software. These software tools use complex algorithms, often based on this kind of problem, to automatically execute trades when certain conditions are met (like when it's most profitable to buy or sell a stock). High-frequency trading, a type of algorithmic trading that places a large number of trades very quickly, often relies on this type of decision-making logic.",
                                    "hints": [
                                        {
                                            "hint": "A naive brute-force approach would check all pairs (buy, sell), iterating over all possible purchase and sale days, resulting in an O(n) time complexity. "
                                        },
                                        {
                                            "hint": "\"A more optimal O(n) solution involves a single traversal with two variables:  min_price: Tracks the lowest price seen so far. max_profit: Tracks the highest profit achievable at each step.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A two-pointer approach isnt suitable here since we must track the minimum price seen so far rather than maintaining a left and right pointer comparison. A single pass with tracking variables is more efficient.",
                                            "question": "Can we use a two-pointer approach to solve this problem?"
                                        },
                                        {
                                            "answer": "When multiple transactions are allowed, the approach changes. Instead of finding a single global maximum, we need to track multiple increasing segments and sum up all profitable transactions.",
                                            "question": " How does this solution differ from the case where multiple transactions are allowed?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A dynamic programming solution would be required. We maintain two transactions, tracking the best buy-sell pairs using two arrays (left_profit and right_profit), or optimize it using a state machine approach.",
                                            "question": "How would the approach change if we were allowed at most two transactions?"
                                        },
                                        {
                                            "answer": "Not efficiently. A monotonic queue or sliding window is more useful when dealing with constraints on consecutive elements. Here, we need a global minimum tracking approach, which is best achieved with a single pass.",
                                            "question": "Can this problem be solved using a sliding window or queue?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstocks_besttimetobuyandsellstockii",
                                "problem_name": "Best time to buy and sell stock II",
                                "problem_slug": "best-time-to-buy-and-sell-stock-ii",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Walmart",
                                        "Flipkart",
                                        "Pinterest",
                                        "Mastercard",
                                        "Visa",
                                        "Broadcom",
                                        "Bloomberg",
                                        "Teladoc Health",
                                        "Morgan Stanley",
                                        "Salesforce",
                                        "DoorDash",
                                        "Deloitte",
                                        "Bungie",
                                        "Medtronic",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Splunk",
                                        "Oracle",
                                        "Nutanix",
                                        "Unity Technologies",
                                        "Rakuten",
                                        "HashiCorp",
                                        "Goldman Sachs",
                                        "Zynga",
                                        "Swiggy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a classic example of a scenario in algorithmic trading software, which is extensively used in finance and investment fields. Such software helps make data-driven decisions and automate multiple trades; they can execute more efficient trades than a human trader. The ability to detect and leverage profit-making opportunities like the one described in this problem is a critical function in these systems. The problem is essentially defining the peak-valley approach, a common practice in trend-following trading strategies. Algorithmic trading systems use similar logic but on a much more complex and vast scale. They often include elements like volatility prediction, pattern recognition, and high-frequency trading.",
                                    "hints": [
                                        {
                                            "hint": "\"Define the DP states as follows:  dp[i][0]  Maximum profit on the i-th day without holding a stock. dp[i][1]  Maximum profit on the i-th day while holding a stock.\""
                                        },
                                        {
                                            "hint": "Since dp[i] only depends on dp[i-1], we can reduce space complexity from O(n) to O(1) by maintaining only two variables instead of an entire DP table."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The -arr[i] accounts for the cost of buying the stock. When transitioning from a \"not holding\" state to a \"holding\" state, we deduct the stock price to reflect the expense.",
                                            "question": "Why is there a -arr[i] in the dp[i][1] transition?"
                                        },
                                        {
                                            "answer": "With only one transaction, we only track the minimum price seen so far and compute the maximum profit in one pass. With multiple transactions, we must explicitly track when to buy and sell repeatedly, which requires DP.",
                                            "question": "How does this differ from the case where we can only make one transaction?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If k transactions are allowed, we extend the DP state to dp[i][j][0] and dp[i][j][1], where j represents the number of transactions used. This leads to a DP table with O(n  k) complexity, often optimized using a rolling array or Kadane-like approach.",
                                            "question": "How would the solution change if we were allowed at most k transactions?"
                                        },
                                        {
                                            "answer": "Yes! The problem can be modeled as a graph, where each node represents a state (holding or not), and edges correspond to buying/selling actions. A shortest path algorithm can then determine the optimal sequence of trades.",
                                            "question": "Can we solve this problem using a graph-based approach?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstocks_besttimetobuyandsellstockiii",
                                "problem_name": "Best time to buy and sell stock III",
                                "problem_slug": "best-time-to-buy-and-sell-stock-iii",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Oracle",
                                        "Docker",
                                        "Seagate Technology",
                                        "Dropbox",
                                        "eBay",
                                        "Instacart",
                                        "Broadcom",
                                        "Zomato",
                                        "IBM",
                                        "Robinhood",
                                        "Micron Technology",
                                        "Salesforce",
                                        "Rakuten",
                                        "Ernst & Young",
                                        "Nutanix",
                                        "Airbnb",
                                        "Databricks",
                                        "Zynga",
                                        "Chewy",
                                        "PayPal",
                                        "Goldman Sachs",
                                        "Shopify",
                                        "Qualcomm",
                                        "AMD",
                                        "Ubisoft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is helpful in simulating the decision-making process of trading algorithms used in fintech applications and robo-advisers. By answering this problem, developers can enhance their understanding of dynamic programming, which is useful in creating algorithms that can analyze historical market data, trace multiple trading scenarios, and devise optimal selling & buying strategy to maximize profits. This forms the backbone of several stock market forecasting software and automated trading systems, which aim to provide the most profitable trades by considering the frequency and timing of transactions.",
                                    "hints": [
                                        {
                                            "hint": "\"We define four states:  first_buy  The maximum profit after the first buy. first_sell  The maximum profit after the first sell. second_buy  The maximum profit after the second buy. second_sell  The maximum profit after the second sell.\""
                                        },
                                        {
                                            "hint": "\"For each day's stock price arr[i], update the states as follows:  first_buy = max(first_buy, -arr[i]). first_sell = max(first_sell, first_buy + arr[i]) second_buy = max(second_buy, first_sell - arr[i]) second_sell = max(second_sell, second_buy + arr[i])\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Unlike problems where we can trade infinitely, here we are limited to two transactions. Tracking second_buy ensures we properly deduct the cost of the second purchase while maximizing the total profit.",
                                            "question": "Why do we need second_buy and second_sell states?"
                                        },
                                        {
                                            "answer": "A DP table (dp[i][k]) could be used, where i represents the day and k represents the number of transactions. However, since k is fixed at 2, we can optimize space to O(1) instead of O(n  k) by using just four variables.",
                                            "question": "Why dont we use a DP table for this problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A monotonic queue isnt useful here because transactions depend on past profits rather than just local min/max values. DP efficiently captures the required dependencies.",
                                            "question": "Can we solve this problem using a stack or monotonic queue?"
                                        },
                                        {
                                            "answer": "For streaming prices, we must maintain a rolling sliding window approach, updating profits dynamically as new prices arrive.",
                                            "question": "What if the input was streamed (i.e., prices arrive in real-time instead of an array)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstocks_besttimetobuyandsellstockiv",
                                "problem_name": "Best time to buy and sell stock IV",
                                "problem_slug": "best-time-to-buy-and-sell-stock-iv",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "eBay",
                                        "Bloomberg",
                                        "Zomato",
                                        "Splunk",
                                        "Philips Healthcare",
                                        "Lyft",
                                        "Zoho",
                                        "HCL Technologies",
                                        "Riot Games",
                                        "Wayfair",
                                        "Texas Instruments",
                                        "Rakuten",
                                        "Broadcom",
                                        "Electronic Arts",
                                        "AMD",
                                        "DoorDash",
                                        "NVIDIA",
                                        "OYO Rooms",
                                        "JPMorgan Chase",
                                        "McKinsey & Company",
                                        "Salesforce",
                                        "Chewy",
                                        "Instacart",
                                        "IBM",
                                        "Cerner",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem and its solutions form the core logic behind many financial and trading software systems, especially algorithmic trading and robo-advisors. These applications aim to make profit through efficient and intelligent buying and selling of shares. They use similar dynamics to stipulate how many transactions can be executed, based on which stocks to hold, and for how long, in order to achieve maximum profit. They use such algorithms to gather, analyze and implement strategic trading decisions based on the changing market scenarios.",
                                    "hints": [
                                        {
                                            "hint": "\"We define a DP table where:  dp[i][j]  The maximum profit achievable using at most j transactions on the i-th day. The core transition formula: dp[i][j] = max(dp[i-1][j], max(arr[i] - arr[m] + dp[m][j-1]) for m in range(0, i))\""
                                        },
                                        {
                                            "hint": "\"Instead of iterating over all possible buy days (m), we can track the best time to buy dynamically:  Maintain max_diff = max(max_diff, dp[i-1][j-1] - arr[i-1]) Update the transition equation: dp[i][j] = max(dp[i-1][j], arr[i] + max_diff)\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A greedy approach works only when unlimited transactions are allowed. When transactions are limited (k), we must carefully plan buy/sell operations to maximize total profit.",
                                            "question": "Why is a DP approach necessary instead of a greedy approach?"
                                        },
                                        {
                                            "answer": "Yes! Instead of a full DP table, we can use two arrays (prev and curr) to maintain only the last two rows, reducing space to O(k) instead of O(n  k).",
                                            "question": "Can we reduce the space complexity from O(n  k)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "If short selling is allowed, then holding negative shares would be possible, meaning we need to modify the DP state to allow negative holdings.",
                                            "question": "How would you solve this problem if short selling were allowed?"
                                        },
                                        {
                                            "answer": "ML models such as Reinforcement Learning (RL) or Recurrent Neural Networks (RNNs) can analyze historical data to predict price movements beyond simple DP-based decision-making.",
                                            "question": "How can machine learning be used to optimize trading decisions based on this model?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstocks_besttimetobuyandsellstockwithcooldownandtransactionfees",
                                "problem_name": "Best time to buy and sell stock with transaction fees",
                                "problem_slug": "best-time-to-buy-and-sell-stock-with-cooldown-and-transaction-fees",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "HashiCorp",
                                        "Alibaba",
                                        "Seagate Technology",
                                        "Broadcom",
                                        "Shopify",
                                        "Ernst & Young",
                                        "Target",
                                        "Pinterest",
                                        "Red Hat",
                                        "Robinhood",
                                        "Bungie",
                                        "Cloudflare",
                                        "NVIDIA",
                                        "Siemens Healthineers",
                                        "OYO Rooms",
                                        "Oracle",
                                        "Square",
                                        "Morgan Stanley",
                                        "Zynga",
                                        "Epic Systems",
                                        "eBay",
                                        "MongoDB",
                                        "Flipkart",
                                        "Micron Technology",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem mimics real-world challenges encountered in the development of financial software, automated trading systems, or robo-advisors which use algorithms to optimize trading strategies. For example, these solutions might need to decide when to buy or sell stocks based on data from previous days, while also considering transaction fees. Additionally, some financial markets enforce regulations similar to the 'cooldown' constraint, to prevent high frequency trading abuses. Thus, the principles behind solving this problem are crucial in the FinTech sector.",
                                    "hints": [
                                        {
                                            "hint": "\"We use DP to track two states: hold  Maximum profit when holding a stock. not_hold  Maximum profit when not holding a stock.\""
                                        },
                                        {
                                            "hint": "If we hold a stock on day i, we either Keep holding it or Buy it today. If we do not hold a stock on day i, we either Keep not holding or Sell it today and pay the transaction fee "
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Medium",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The transaction fee is only deducted when selling, not buying. Deducting it during the buy phase would cause an unnecessary reduction in profit.",
                                            "question": "Why does the hold state track dp[i-1][0] - arr[i] instead of dp[i-1][0] - arr[i] - fee?"
                                        },
                                        {
                                            "answer": "If no transaction yields a profit greater than the fee, then no transactions should be made, and the answer is 0.",
                                            "question": "What if the transaction fee is larger than the maximum price difference?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This would require modifying the DP state transitions to ensure at least one-day separation between buy and sell.",
                                            "question": "What if buying and selling on the same day were not allowed?"
                                        },
                                        {
                                            "answer": "With a transaction limit, we need a DP table dp[i][j][0] and dp[i][j][1], where j represents the number of transactions used so far.",
                                            "question": "How would the solution change if k transactions were allowed instead of unlimited?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_dponsubsequences",
                        "subcategory_name": "DP on subsequences",
                        "subcategory_slug": "dp-on-subsequences",
                        "subcategory_rank": 5,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_subsetsumequalstotarget",
                                "problem_name": "Subset sum equals to target",
                                "problem_slug": "subset-sum-equals-to-target",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Uber",
                                        "Ernst & Young",
                                        "Intel",
                                        "Bloomberg",
                                        "PayPal",
                                        "Stripe",
                                        "Teladoc Health",
                                        "Roblox",
                                        "IBM",
                                        "Epic Systems",
                                        "Twilio",
                                        "OYO Rooms",
                                        "Western Digital",
                                        "Bungie",
                                        "Roche",
                                        "Visa",
                                        "Wayfair",
                                        "Rockstar Games",
                                        "Goldman Sachs",
                                        "ARM",
                                        "Snowflake",
                                        "Square",
                                        "Airbnb",
                                        "Broadcom",
                                        "Medtronic",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is often used in financial software or apps where it's crucial to match transactions or set of numbers to specific totalsin fraud check algorithms, for instance, or split payments. It's also known as the subset-sum problem and is a common example of the 'knapsack problem' which has various applications in cryptography, complexity theory, and computer networks.",
                                    "hints": [
                                        {
                                            "hint": "\"A DP approach optimally solves this problem using a boolean DP table (dp[i][j]), where:  dp[i][j] represents whether a subset of the first i elements has a sum equal to j.\""
                                        },
                                        {
                                            "hint": "\"If we exclude arr[i], the result depends on dp[i-1][j]. If we include arr[i], the result depends on dp[i-1][j - arr[i]]. If either case is True, then dp[i][j] = True. Thus, the recurrence relation is:  dp[i][j] = dp[i-1][j] OR dp[i-1][j - arr[i]] (if j >= arr[i]).\""
                                        },
                                        {
                                            "hint": "\"Instead of a dp[n][target] table, we can use a single 1D array (dp[target]), updating from right to left to avoid overwriting values.  dp[j] = dp[j] OR dp[j - arr[i]]\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Processing from right to left ensures that each element is considered only once per row update, preventing duplicate inclusion.",
                                            "question": "Why do we process dp[j] from right to left in the space-optimized approach?"
                                        },
                                        {
                                            "answer": "Subset Sum is a special case of 0/1 Knapsack, where each element has a value equal to its weight, and the goal is to exactly fill the knapsack.",
                                            "question": "How is this problem related to the Knapsack problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of a boolean table, maintain a backtracking path (dp[i][j] storing previous elements) to reconstruct the subset.",
                                            "question": "How would you modify this problem if you needed to return the subset itself?"
                                        },
                                        {
                                            "answer": "Using a bitset, update possible sums efficiently via dp |= (dp << arr[i]).",
                                            "question": "How would you solve this problem in O(n  target / 2) using bit manipulation?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_partitionequalsubsetsum",
                                "problem_name": "Partition equal subset sum",
                                "problem_slug": "partition-equal-subset-sum",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "JPMorgan Chase",
                                        "Intel",
                                        "Dropbox",
                                        "Snowflake",
                                        "HashiCorp",
                                        "Unity Technologies",
                                        "Wayfair",
                                        "Medtronic",
                                        "Roblox",
                                        "Teladoc Health",
                                        "OYO Rooms",
                                        "Epic Games",
                                        "Stripe",
                                        "Instacart",
                                        "Texas Instruments",
                                        "eBay",
                                        "AMD",
                                        "Goldman Sachs",
                                        "Riot Games",
                                        "Cloudflare",
                                        "Rakuten",
                                        "Optum",
                                        "Databricks",
                                        "Seagate Technology",
                                        "Broadcom",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a classic example of the Subset Sum Problem, a concept used in various real-world applications. One interesting use case is in cloud computing in the field of resource allocation. In cloud systems, resources like CPU, memory, and storage need to be divided among various tasks. The problem of optimally splitting these resources between different tasks, such that the sum usage of all resources is the same for all subsets, is similar to this partitioning problem. Efficient solutions to this problem ensure that all cloud-based applications and services run smoothly without overusing or underusing any resources.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][j] where: dp[i][j]  True if there exists a subset of the first i elements whose sum is j. Recurrence Relation: dp[i][j] = dp[i-1][j] OR dp[i-1][j - arr[i]] (if j >= arr[i])\""
                                        },
                                        {
                                            "hint": "\"Since the DP table only depends on the previous row, we can use a 1D array (dp[target]) updated from right to left:  dp[j] = dp[j] OR dp[j - arr[i]] (processed in reverse order to prevent overwriting).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If the total sum is odd, it is impossible to split into two equal subsets.",
                                            "question": "Why do we check sum(arr) % 2 == 0 first?"
                                        },
                                        {
                                            "answer": "Use a modified DP approach tracking sums within the [S/2 - d, S/2 + d] range.",
                                            "question": "What if we wanted to partition into subsets such that their sums differ by at most d?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify the DP table to store which elements contributed to each subset, then backtrack to reconstruct the subsets.",
                                            "question": "How would you modify this problem to return the actual partitions instead of just True/False?"
                                        },
                                        {
                                            "answer": "Use a bitset DP, where dp |= (dp << arr[i]) efficiently computes all possible subset sums.",
                                            "question": "How would you solve this problem using bit manipulation?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_partitionasetintotwosubsetswithminimumabsolutesumdifference",
                                "problem_name": "Partition a set into two subsets with minimum absolute sum difference",
                                "problem_slug": "partition-a-set-into-two-subsets-with-minimum-absolute-sum-difference",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "AMD",
                                        "Teladoc Health",
                                        "Bloomberg",
                                        "Chewy",
                                        "Square",
                                        "NVIDIA",
                                        "Seagate Technology",
                                        "Nutanix",
                                        "Medtronic",
                                        "Zoho",
                                        "Bain & Company",
                                        "Roblox",
                                        "Cloudflare",
                                        "Target",
                                        "Boston Consulting Group",
                                        "Epic Systems",
                                        "Flipkart",
                                        "IBM",
                                        "Bungie",
                                        "Zynga",
                                        "Unity Technologies",
                                        "Morgan Stanley",
                                        "Walmart",
                                        "HCL Technologies",
                                        "PwC",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem can be challenging but it's also interesting because it's a form of 'Partitioning Problem', which is a key part of many real-world applications, such as load balancing in distributed systems or databases. Developers often need to partition data among different machines or database tables to balance the load and achieve maximum performance. The minimization of the absolute difference in sums is analogous to minimizing the difference in load between the most and least loaded machines or tables.",
                                    "hints": [
                                        {
                                            "hint": "\"Define DP state: dp[j] = True if there exists a subset with sum j (similar to the subset sum problem). Find the closest sum to S/2. The minimized difference is |S - 2 * j|.\""
                                        },
                                        {
                                            "hint": "\"Since each DP state depends only on the previous row, we can optimize to O(S/2) space:  Use a 1D DP array (dp[target]) updated from right to left to prevent overwriting values.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Partition Equal Subset Sum requires an exact S/2 sum, whereas here we find the closest possible sum  S/2.",
                                            "question": "How does this differ from the Partition Equal Subset Sum problem?"
                                        },
                                        {
                                            "answer": "If we find a subset sum S1 closest to S/2, then S2 = S - S1, minimizing |S1 - S2|.",
                                            "question": "Why do we aim for S/2?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "This becomes Partition into k Subsets, a NP-hard problem requiring backtracking with memoization.",
                                            "question": "How would this problem change if we wanted to partition into k subsets with minimum sum difference?"
                                        },
                                        {
                                            "answer": "The problem can be modeled as a graph, where each subset sum is a node, and edges represent adding elements.\n",
                                            "question": " How would this problem be solved using graph-based techniques?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_countsubsetswithsumk",
                                "problem_name": "Count subsets with sum K",
                                "problem_slug": "count-subsets-with-sum-k",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "Target",
                                        "HashiCorp",
                                        "Alibaba",
                                        "Epic Games",
                                        "GE Healthcare",
                                        "Robinhood",
                                        "Etsy",
                                        "OYO Rooms",
                                        "Instacart",
                                        "Ernst & Young",
                                        "Swiggy",
                                        "Deloitte",
                                        "Visa",
                                        "Oracle",
                                        "Byju's",
                                        "Lyft",
                                        "KPMG",
                                        "Riot Games",
                                        "Uber",
                                        "Zynga",
                                        "Seagate Technology",
                                        "Activision Blizzard",
                                        "Databricks",
                                        "Chewy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "An interesting real-world application of this problem can be found in the development of algorithms for financial portfolio management systems. These systems must often identify subsets of stocks (from a larger pool) that sum to a specific target value. This allows fund managers to balance their portfolios for risk and return. Counting the number of such subsets can be a part of the process to identify multiple possibilities for optimal portfolio constructions based on different risk-return preferences.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][j] as the number of ways to form sum j using the first i elements of arr. If we exclude arr[i], then dp[i][j] = dp[i-1][j]. If we include arr[i], then dp[i][j] = dp[i-1][j - arr[i]] (if j  arr[i]).\""
                                        },
                                        {
                                            "hint": "\"ince dp[i][j] depends only on dp[i-1][j] and dp[i-1][j - arr[i]], we can optimize to O(K) space by using a 1D DP array (dp[K]) updated from right to left: dp[j]=(dp[j]+dp[jarr[i]])mod(10^9+7)\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "No, because a greedy approach fails when elements must be selected in a specific order.",
                                            "question": "Can a greedy approach work instead of DP?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a backtracking path (dp[i][j] storing contributing elements) to reconstruct subsets.",
                                            "question": "How would you modify this problem to return the actual subsets instead of just counting them?"
                                        },
                                        {
                                            "answer": "If elements can be used multiple times, modify DP as: dp[j]=dp[j]+dp[jarr[i]]",
                                            "question": "How does this problem relate to subset sum with multiplicity?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_countpartitionswithgivendifference",
                                "problem_name": "Count partitions with given difference",
                                "problem_slug": "count-partitions-with-given-difference",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Zoho",
                                        "Teladoc Health",
                                        "Ernst & Young",
                                        "Roblox",
                                        "KPMG",
                                        "Epic Games",
                                        "Databricks",
                                        "Deloitte",
                                        "Instacart",
                                        "Intel",
                                        "Seagate Technology",
                                        "Micron Technology",
                                        "Electronic Arts",
                                        "Docker",
                                        "Rakuten",
                                        "Goldman Sachs",
                                        "Snowflake",
                                        "Medtronic",
                                        "Philips Healthcare",
                                        "JPMorgan Chase",
                                        "Unity Technologies",
                                        "Boston Consulting Group",
                                        "Ubisoft",
                                        "Walmart",
                                        "Square",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem and its underlying concept of dynamic programming is a fundamental part of many algorithms used in machine learning and data analysis. For instance, these types of partitioning problems are often used in dividing datasets for testing and training purposes, in a way that a certain condition is met - be it the difference between sums of subsets, or maximizing the similarity of data within each subset. Additionally, it is also common in load balancing problems where tasks are distributed across different servers in a way that the workload difference between any two servers is minimum.",
                                    "hints": [
                                        {
                                            "hint": "\"the problem reduces to finding the number of subsets whose sum is S1.  If S + diff is odd, no valid partition exists  return 0. Otherwise, find count of subsets that sum to S1 using Subset Sum Count DP.\""
                                        },
                                        {
                                            "hint": "We use a 1D DP array (dp[j]) where dp[j] represents the number of ways to achieve sum j. We iterate in reverse (j = S1 to arr[i]) to avoid duplicate counting."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A subset sum S1 must be integer-valued. If S + diff is odd, no valid integer S1 exists.",
                                            "question": "Why do we check S + diff for evenness?"
                                        },
                                        {
                                            "answer": "Yes! We can use a bitset DP, shifting bits left by arr[i] to track possible sums efficiently.",
                                            "question": "Can we solve this problem using bit manipulation?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a backtracking path (dp[i][j] storing contributing elements) to reconstruct subsets.",
                                            "question": "How would you modify this problem to return the actual subsets instead of just counting them?"
                                        },
                                        {
                                            "answer": "The problem can be modeled as a graph, where each subset sum is a node, and edges represent adding elements.",
                                            "question": "How would this problem be solved using graph-based techniques?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_0and1knapsack",
                                "problem_name": "0 and 1 Knapsack",
                                "problem_slug": "0-and-1-knapsack",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Medtronic",
                                        "Ubisoft",
                                        "Nutanix",
                                        "Cerner",
                                        "Walmart",
                                        "Bungie",
                                        "Cloudflare",
                                        "Western Digital",
                                        "Qualcomm",
                                        "HCL Technologies",
                                        "Etsy",
                                        "Unity Technologies",
                                        "Philips Healthcare",
                                        "Visa",
                                        "Ernst & Young",
                                        "Rakuten",
                                        "Instacart",
                                        "Morgan Stanley",
                                        "Shopify",
                                        "Wayfair",
                                        "Stripe",
                                        "Roblox",
                                        "Siemens Healthineers",
                                        "Broadcom",
                                        "Pinterest",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept behind this knapsack problem is practically used in Resource Allocation and Load Balancing in Cloud Computing. In cloud computing, resources (like processing power, storage, etc.) are finite and there's a need to optimize. The knapsack problem revolves around optimizing the value of items that can fit in a limited-size knapsack, making it a perfect model for allocating finite resources. Choices must be made about which virtual machines or jobs to allocate to each server, so that server capacity (weight limit in knapsack) isn't exceeded and efficiency or performance (value in knapsack) is maximized. It's a key aspect in determining how to distribute loads in order to get the maximal utility.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][w] as the maximum value achievable using the first i items with a knapsack capacity of w. the recurrence relation is: dp[i][w]=max(dp[i1][w],dp[i1][wwt[i]]+val[i])(ifwt[i]w) \""
                                        },
                                        {
                                            "hint": "\"Instead of a full dp[n][W] table, we can use a 1D array (dp[W]) and iterate backward (right to left): dp[w]=max(dp[w],dp[wwt[i]]+val[i]) We iterate from W down to wt[i] to prevent overwriting values.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "In standard knapsack problems, we assume weights are positive. If weight is 0, an item can be selected infinitely, making it an unbounded knapsack.",
                                            "question": "What if an items weight is 0 but has a positive value?"
                                        },
                                        {
                                            "answer": "No, because a greedy approach fails when item values dont align proportionally with their weights.",
                                            "question": "Can we use a greedy approach instead of DP?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a 3D DP table (dp[i][w][c]), where c tracks the count of times an item is used.",
                                            "question": "What if we had a limit on the number of times each item can be picked (Bounded Knapsack)?"
                                        },
                                        {
                                            "answer": "Define knapsack(i,w)=max(knapsack(i1,w),knapsack(i1,wwt[i])+val[i]). Use top-down memoization (O(N  W) complexity).",
                                            "question": "How can this problem be solved using recursion with memoization?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_minimumcoings",
                                "problem_name": "Minimum coins",
                                "problem_slug": "minimum-coins",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Ubisoft",
                                        "Wayfair",
                                        "Instacart",
                                        "Mastercard",
                                        "Ernst & Young",
                                        "DoorDash",
                                        "Lyft",
                                        "Texas Instruments",
                                        "Roche",
                                        "Activision Blizzard",
                                        "HCL Technologies",
                                        "Databricks",
                                        "Twilio",
                                        "Rockstar Games",
                                        "Intel",
                                        "McKinsey & Company",
                                        "Dropbox",
                                        "Siemens Healthineers",
                                        "Robinhood",
                                        "Alibaba",
                                        "Bungie",
                                        "Byju's",
                                        "Zynga",
                                        "Zoho",
                                        "Etsy",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem concept forms the foundation of many optimization algorithms in software development, especially in fields like logistics and inventory management. A practical example is in Change-Making Machines, common in supermarkets or large businesses. These machines are basically designed to solve this problem: provide change using the fewest number of coins. Another area is in resource or budget allocation in cloud computing and finance. Software tools, such as those used for project management, utilize this kind of algorithm to distribute resources efficiently.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i] as the minimum number of coins needed to make up amount i. the recurrence relation is: dp[i]=min(dp[i],dp[icoin]+1)foreachcoin\""
                                        },
                                        {
                                            "hint": "Since dp[i] only depends on smaller values, we only need a 1D DP array (dp[amount]) instead of O(n  amount)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "We start with an impossible state () to ensure that min(dp[i], dp[i - coin] + 1) correctly selects the smallest number of coins.",
                                            "question": "Why do we initialize dp[i] = ?"
                                        },
                                        {
                                            "answer": "Iterating over coins first ensures that each amount is updated optimally, allowing each coin to contribute to smaller values before reaching larger ones.",
                                            "question": "Why do we iterate over coins first instead of amount?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Change dp[i] = min(dp[i], dp[i - coin] + 1) to summation: dp[i]+=dp[icoin]",
                                            "question": "How would you modify the problem if you needed the total number of ways to make amount instead of the minimum coins?"
                                        },
                                        {
                                            "answer": "Yes! Model the problem as a graph where each node is an amount and edges represent valid coin choices. A BFS (shortest path) approach finds the minimum steps.",
                                            "question": "Can this problem be solved efficiently using graph-based techniques?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_targetsum",
                                "problem_name": "Target sum",
                                "problem_slug": "target-sum",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Bungie",
                                        "Bloomberg",
                                        "Chewy",
                                        "Epic Systems",
                                        "Siemens Healthineers",
                                        "Etsy",
                                        "Morgan Stanley",
                                        "DoorDash",
                                        "Snowflake",
                                        "Flipkart",
                                        "IBM",
                                        "Visa",
                                        "Unity Technologies",
                                        "Zomato",
                                        "Western Digital",
                                        "Riot Games",
                                        "Optum",
                                        "Medtronic",
                                        "Square",
                                        "Rakuten",
                                        "Target",
                                        "PayPal",
                                        "Activision Blizzard",
                                        "ARM",
                                        "GE Healthcare",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is fundamentally a problem about dynamic programming and subset sum, both of which have wide applications in real-world scenarios. One practical application of this problem that has been used in the software industry is in the development of financial or budgeting software. For instance, these systems may need to calculate the number of possible ways to achieve a particular financial target, using different combinations of expenses or revenues which are represented by the '+'' or '-' signs. The modulo operation is also frequently used in cryptographic algorithms which are a critical part of secure communication in software applications.",
                                    "hints": [
                                        {
                                            "hint": "\"We define the sum of all elements in nums as S. We need to partition the array into two subsets S1 and S2, where S1S2=target. the problem reduces to counting the number of subsets whose sum is S1. \""
                                        },
                                        {
                                            "hint": "We define dp[j] as the number of ways to achieve sum j. the recurrence relation is:dp[j]=(dp[j]+dp[jnums[i]])mod(10^9+7)"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A subset sum S1 must be integer-valued. If S + target is odd, no valid integer S1 exists.",
                                            "question": "Why do we check if (S + target) is even?"
                                        },
                                        {
                                            "answer": "This is a modified Subset Sum Count, where we count ways to sum to S1 = (S + target) / 2.",
                                            "question": "How is this problem related to Subset Sum Count?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a backtracking path (dp[i][j] storing contributing elements) to reconstruct expressions.",
                                            "question": "How would you modify this problem to return the actual expressions instead of just counting them?"
                                        },
                                        {
                                            "answer": "This becomes K-Partition Sum, an NP-hard problem requiring backtracking with memoization.",
                                            "question": "How would you modify this problem for k subsets with a fixed sum difference?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_coinchangeii",
                                "problem_name": "Coin change II",
                                "problem_slug": "coin-change-ii",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Electronic Arts",
                                        "Deloitte",
                                        "Snowflake",
                                        "Cerner",
                                        "Instacart",
                                        "ARM",
                                        "IBM",
                                        "Bungie",
                                        "KPMG",
                                        "Philips Healthcare",
                                        "Johnson & Johnson",
                                        "Salesforce",
                                        "Morgan Stanley",
                                        "Zoho",
                                        "OYO Rooms",
                                        "Chewy",
                                        "Wayfair",
                                        "Airbnb",
                                        "Docker",
                                        "Epic Systems",
                                        "Dropbox",
                                        "Siemens Healthineers",
                                        "Texas Instruments",
                                        "Oracle",
                                        "Red Hat",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem, referred to as a variation of the \"coin change\" or \"knapsack\" problem, is commonly used in many popular software systems. One real-world application is in financial technology. For example, this algorithm could be used in ATM software to efficiently determine the smallest number of banknotes and coins to dispense that add up to a given withdrawal amount. Additionally, online shopping platforms could use it to suggest combinations of products that total a given amount. Furthermore, it's used in dynamic programming learning resources and cryptography.",
                                    "hints": [
                                        {
                                            "hint": "We define dp[i] as the number of ways to achieve sum i using the given coins. the recurrence relation is: dp[i]=(dp[i]+dp[icoin])mod(10^9+7)"
                                        },
                                        {
                                            "hint": "\"We iterate over coins first, ensuring that the order doesnt affect the number of ways. We process dp[i] from left to right, ensuring each coin is considered an unlimited number of times.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Iterating over coins first ensures that each amount is updated optimally, allowing each coin to contribute to smaller values before reaching larger ones.",
                                            "question": "Why do we iterate over coins first instead of amount?"
                                        },
                                        {
                                            "answer": "Coins with 0 value should be ignored since they can be used infinitely, leading to infinite loops.",
                                            "question": "What happens if there are coins of 0 value?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a bitset DP, where dp |= (dp << coin) efficiently tracks possible sums.",
                                            "question": "How can this problem be solved efficiently using bit manipulation?"
                                        },
                                        {
                                            "answer": "Yes! Model the problem as a graph where each node is an amount and edges represent valid coin choices. A BFS (shortest path) approach finds the minimum steps.",
                                            "question": "Can this problem be solved efficiently using graph-based techniques?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_unboundedknapsack",
                                "problem_name": "Unbounded knapsack",
                                "problem_slug": "unbounded-knapsack",
                                "problem_rank": 10,
                                "misc": {
                                    "tags": [
                                        "IBM",
                                        "Salesforce",
                                        "AMD",
                                        "Byju's",
                                        "Micron Technology",
                                        "Unity Technologies",
                                        "Zynga",
                                        "Cloudflare",
                                        "Bungie",
                                        "Broadcom",
                                        "American Express",
                                        "Visa",
                                        "GE Healthcare",
                                        "Walmart",
                                        "Snowflake",
                                        "Goldman Sachs",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Optum",
                                        "DoorDash",
                                        "Mastercard",
                                        "NVIDIA",
                                        "Ubisoft",
                                        "eBay",
                                        "Lyft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The knapsack problem is fundamental in resource allocation tasks and is widely applicable across numerous industries for decision making. A fun, practical example is in the world of video game design. In games where characters have limited carrying capacity, designers use the knapsack problem to create algorithms that help players automatically select the best items to carry for optimal game outcomes. Moreover, this problem is also used in file storage and network data packet transmission to achieve maximum efficiency within certain capacity constraints.",
                                    "hints": [
                                        {
                                            "hint": "We define dp[w] as the maximum value achievable using items with a knapsack capacity of w. the recurrence relation is: dp[w]=max(dp[w],dp[wwt[i]]+val[i])"
                                        },
                                        {
                                            "hint": "Since dp[w] only depends on smaller values, we only need a 1D DP array (dp[W]) instead of O(N  W)."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Iterating items first ensures that each item can be used multiple times, allowing optimal selection.",
                                            "question": "Why do we iterate over items first instead of W?"
                                        },
                                        {
                                            "answer": "Since we can pick unlimited items, updating from left to right ensures each item can be used multiple times.",
                                            "question": "Why do we update dp[w] from left to right instead of right to left?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use a 3D DP table (dp[i][w][c]), where c tracks the count of times an item is used.",
                                            "question": "What if we had a limit on the number of times each item can be picked (Bounded Knapsack)?"
                                        },
                                        {
                                            "answer": "Define knapsack(i,w)=max(knapsack(i,wwt[i])+val[i],knapsack(i1,w))\nUse top-down memoization (O(N  W) complexity).",
                                            "question": "How can this problem be solved using recursion with memoization?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponsubsequences_rodcuttingproblem",
                                "problem_name": "Rod cutting problem",
                                "problem_slug": "rod-cutting-problem",
                                "problem_rank": 11,
                                "misc": {
                                    "tags": [
                                        "Johnson & Johnson",
                                        "Zynga",
                                        "Boston Consulting Group",
                                        "Epic Systems",
                                        "eBay",
                                        "Seagate Technology",
                                        "Oracle",
                                        "Bungie",
                                        "Epic Games",
                                        "Teladoc Health",
                                        "HashiCorp",
                                        "Unity Technologies",
                                        "Morgan Stanley",
                                        "AMD",
                                        "Micron Technology",
                                        "Roblox",
                                        "DoorDash",
                                        "Shopify",
                                        "Red Hat",
                                        "Snowflake",
                                        "Deloitte",
                                        "Instacart",
                                        "McKinsey & Company",
                                        "Walmart",
                                        "Texas Instruments",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This algorithm, also known as Rod Cutting Problem, is a classic example of Dynamic Programming. It's a practical real-world issue utilized in industries like manufacturing and construction, where the efficient use of resources is crucial. For example, it could be used in a steel plant to determine the best way to cut steel rods to minimize waste while maximizing profit. Similarly, in software development, it is used in resource allocation problems, optimizing network routing, or even in managing cloud resources to lower costs by optimizing the way the resources are used.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i] as the maximum profit obtainable for a rod of length i. the recurrence relation is:dp[i]=max(dp[i],dp[ij]+price[j1])"
                                        },
                                        {
                                            "hint": "Instead of a full 2D DP table, we use a 1D DP array (dp[N])."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes! Define rodCut(n)=max(price[i]+rodCut(ni))in\nUse top-down memoization (O(N) complexity).",
                                            "question": "Can we solve this problem using recursion with memoization?"
                                        },
                                        {
                                            "answer": "In 0/1 Knapsack, each item (cut) can be used only once, whereas here, cuts can be repeated.",
                                            "question": " How does this differ from the 0/1 Knapsack problem?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Subtract a fixed cost C from each cut: dp[i]=max(dp[i],dp[ij]+price[j1]C)",
                                            "question": "How would you modify the problem if each cut had a fixed cost?"
                                        },
                                        {
                                            "answer": "Modify price[i]  price[i] * probability[i], optimizing expected value.",
                                            "question": "How would you solve this problem if the rod segments had different selling probabilities?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "lis",
                        "subcategory_name": "LIS",
                        "subcategory_slug": "lis-dp",
                        "subcategory_rank": 6,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "longest_increasing_subsequence",
                                "problem_name": "Longest Increasing Subsequence",
                                "problem_slug": "longest-increasing-subsequence",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i] as the length of the longest increasing subsequence ending at index i. the recurrence relation is: dp[i]=max(dp[i],dp[j]+1)forallj<iandnums[j]<nums[i] \""
                                        },
                                        {
                                            "hint": "\"Instead of using dp[i], maintain a sorted array (sub) where:  Each element in sub represents the smallest ending element of an increasing subsequence of a certain length. Use Binary Search (lower_bound in sub) to find the position where nums[i] should replace an element in sub.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It helps efficiently find the position to replace an element in the subsequence.",
                                            "question": "Why do we use binary search in O(n log n) approach?"
                                        },
                                        {
                                            "answer": "Yes, but it leads to O(n) complexity, which is not optimal for large inputs.",
                                            "question": "Can this problem be solved using recursion with memoization?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use Fenwick Tree for range maximum queries.",
                                            "question": "How would you solve this problem in O(n log n) using Fenwick Tree or Segment Tree?"
                                        },
                                        {
                                            "answer": "This becomes LIS with at most k removals, requiring graph-based DP.",
                                            "question": "Can we modify this problem to allow at most k decreases?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "print_longest_increasing_subsequence",
                                "problem_name": "Print Longest Increasing Subsequence",
                                "problem_slug": "print-longest-increasing-subsequence",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i] as the length of the LIS ending at arr[i]. Define parent[i] to track the previous element in the LIS path. Find the maximum LIS length. Backtrack using parent[i] to reconstruct the sequence. \""
                                        },
                                        {
                                            "hint": "\"Instead of using dp[i], maintain a sorted array (sub) where:  Each element in sub represents the smallest ending element of an increasing subsequence of a certain length. Use Binary Search (lower_bound) to find the position where arr[i] should replace an element in sub.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The array sub doesnt store the actual LIS but ensures its length is correct.",
                                            "question": "Why does sub store potential LIS elements instead of the actual LIS sequence?"
                                        },
                                        {
                                            "answer": "It helps reconstruct the lexicographically smallest sequence after finding LIS.",
                                            "question": "Why do we track parent[i]?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use non-strict increasing subsequence (<= instead of <).",
                                            "question": "What if arr contained duplicate elements?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "largest_divisible_subset",
                                "problem_name": "Largest Divisible Subset",
                                "problem_slug": "largest-divisible-subset",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A Dynamic Programming (DP) approach efficiently solves this problem by Sorting nums in ascending order ensures that if nums[j] divides nums[i], then nums[i] is always greater than nums[j]."
                                        },
                                        {
                                            "hint": "\"Using DP (dp[i]) to track the size of the largest divisible subset ending at index i. Maintaining a parent[] array to reconstruct the subset efficiently.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Both problems track the longest sequence following specific conditions. LIS requires elements to be strictly increasing, while this problem requires elements to be multiples of each other. Instead of dp[i] representing an increasing subsequence length, here it represents the largest divisible subset ending at nums[i].",
                                            "question": "Why is the problem similar to LIS?"
                                        },
                                        {
                                            "answer": "No, because checking divisibility conditions efficiently requires O(n) complexity unless we sort nums first. Sorting ensures a greedy-like structure where smaller numbers appear first, reducing unnecessary checks.\n",
                                            "question": "Can we use a hash set instead of sorting?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of checking every pair (j, i), use a HashMap (dp[i]) and TreeSet (binary search) to efficiently track divisibility relations. We can optimize subset construction by only storing the smallest valid previous element.\n",
                                            "question": "How would you solve this problem in O(n log n) instead of O(n)?"
                                        },
                                        {
                                            "answer": "Yes! Treat nums as nodes and add edges where a % b == 0. The longest path in this directed graph gives the largest subset.",
                                            "question": "Can this problem be solved using a graph-based approach?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "longest_string_chain",
                                "problem_name": "Longest String Chain",
                                "problem_slug": "longest-string-chain",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A Dynamic Programming (DP) approach efficiently solves this problem by Sorting words[] by length ensures that every word comes after all potential predecessors."
                                        },
                                        {
                                            "hint": "\"Using a DP array (dp[word]) to store the longest chain ending at each word. Iterating through each word and checking all possible predecessors by removing one character at a time.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures that when processing words[i], all potential shorter predecessors are already considered. This allows bottom-up DP processing to track valid chains efficiently.",
                                            "question": "Why do we sort words[] by length?"
                                        },
                                        {
                                            "answer": "This problem can be modeled as a Directed Acyclic Graph (DAG) where an edge exists from prev  curr if prev is a valid predecessor. The longest path in this DAG gives the answer.",
                                            "question": "Why is this similar to DAG longest path?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent map where parent[word] = previous_word for the longest chain found. Start from the word with the highest dp[word] and backtrack.",
                                            "question": " How would you reconstruct the actual longest string chain instead of just its length?"
                                        },
                                        {
                                            "answer": "This becomes the Edit Distance Problem instead of a Predecessor Chain Problem, requiring dynamic programming with three operations.",
                                            "question": "What if insertions, deletions, and replacements were allowed?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "longest_bitonic_subsequence",
                                "problem_name": "Longest Bitonic Subsequence",
                                "problem_slug": "longest-bitonic-subsequence",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "Instead of just tracking the increasing part, we also track the Longest Decreasing Subsequence (LDS) from each point."
                                        },
                                        {
                                            "hint": "\"Compute LIS[i] for every i  The length of the longest increasing subsequence ending at i. Compute LDS[i] for every i  The length of the longest decreasing subsequence starting at i. Find the maximum value of LIS[i] + LDS[i] - 1, since i is counted twice.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Compute LIS[i] for every i  The length of the longest increasing subsequence ending at i.\nCompute LDS[i] for every i  The length of the longest decreasing subsequence starting at i.\n",
                                            "question": "Find the maximum value of LIS[i] + LDS[i] - 1, since i is counted twice."
                                        },
                                        {
                                            "answer": "Yes, a purely increasing or purely decreasing sequence is trivially bitonic, with either LIS or LDS contributing fully.",
                                            "question": "Can a strictly increasing or decreasing sequence be considered bitonic?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes! Construct a directed acyclic graph (DAG) where edges exist for increasing and decreasing relationships, then compute the longest path.",
                                            "question": "Can this problem be solved using graph-based techniques?"
                                        },
                                        {
                                            "answer": "Instead of maintaining a single peak, track alternating increasing and decreasing segments using DP",
                                            "question": "How would you modify this problem to allow k fluctuations instead of just one peak?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "number_of_longest_increasing_subsequences",
                                "problem_name": "Number of Longest Increasing Subsequences",
                                "problem_slug": "number-of-longest-increasing-subsequences",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "\"We solve this using Dynamic Programming (DP) with two arrays: dp[i]  The length of the longest increasing subsequence ending at index i. count[i]  The number of LIS ending at index i.\""
                                        },
                                        {
                                            "hint": "\"For each index i, iterate over all j < i:  If nums[j] < nums[i]: If dp[j] + 1 > dp[i], update dp[i] and reset count[i] = count[j]. If dp[j] + 1 == dp[i], add count[j] to count[i]. Finally, sum up all count[i] where dp[i] equals the maximum LIS length.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "dp[] finds the longest increasing subsequence length.\ncount[] keeps track of how many ways we can form LIS of that length.",
                                            "question": "Why do we need two arrays (dp[] and count[])?"
                                        },
                                        {
                                            "answer": "The total number of LIS is the sum of all subsequences that reach the maximum LIS length.",
                                            "question": "Why do we sum count[i] for all indices where dp[i] == max_length?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use parent tracking to store LIS paths and backtrack to find sequences.",
                                            "question": "How would you reconstruct the actual LIS sequences instead of just counting them?"
                                        },
                                        {
                                            "answer": "Yes! Treat nums[] as nodes, with edges where nums[j] < nums[i], and compute longest paths in a DAG.\n",
                                            "question": "Can this problem be solved using a graph-based approach?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_dponstrings",
                        "subcategory_name": "DP on strings",
                        "subcategory_slug": "dp-on-strings",
                        "subcategory_rank": 7,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_longestcommonsubsequence",
                                "problem_name": "Longest common subsequence",
                                "problem_slug": "longest-common-subsequence",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Goldman Sachs",
                                        "OYO Rooms",
                                        "Swiggy",
                                        "IBM",
                                        "Byju's",
                                        "Databricks",
                                        "Instacart",
                                        "Bain & Company",
                                        "Dropbox",
                                        "Walmart",
                                        "Broadcom",
                                        "Zomato",
                                        "KPMG",
                                        "Square",
                                        "Rakuten",
                                        "Pinterest",
                                        "Zynga",
                                        "Nutanix",
                                        "Bungie",
                                        "JPMorgan Chase",
                                        "Etsy",
                                        "Epic Systems",
                                        "PwC",
                                        "GE Healthcare",
                                        "McKinsey & Company",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, often known as the Longest Common Subsequence (LCS) problem, underlies the logic of many diff utilities and version control systems like Git. The diff tools use this problem to compare different versions of code or text files, and find the minimum number of changes needed to transform one version to another. This allows developers to efficiently track and manage changes in their projects over time.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as the length of the LCS of the first i characters of str1 and the first j characters of str2."
                                        },
                                        {
                                            "hint": "If str1[i-1] == str2[j-1], the LCS extends dp[i][j]=1+dp[i1][j1]. Otherwise, we take the maximum LCS found by excluding either character dp[i][j]=max(dp[i1][j],dp[i][j1])"
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Each dp[i][j] depends on both dp[i-1][j] and dp[i][j-1], so we need to store LCS values for every prefix of str1 and str2.",
                                            "question": "Why do we need a 2D DP table instead of a 1D DP array?"
                                        },
                                        {
                                            "answer": "Since dp[i][j] only depends on the previous row, we can use two rolling arrays (prev[] and curr[]), reducing space to O(min(n, m)).",
                                            "question": "How can we optimize space from O(n  m) to O(min(n, m))?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use bit masking (compressed DP) to track states efficiently.",
                                            "question": "What if str1 and str2 were large, but had small alphabets?"
                                        },
                                        {
                                            "answer": "Use Binary Search + Patience Sorting if the alphabet is limited.",
                                            "question": "How can we optimize this problem to O(n log m) instead of O(n  m)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_longestcommonsubstring",
                                "problem_name": "Longest common substring",
                                "problem_slug": "longest-common-substring",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Flipkart",
                                        "Databricks",
                                        "Cloudflare",
                                        "Bain & Company",
                                        "Roche",
                                        "Instacart",
                                        "Bloomberg",
                                        "Zynga",
                                        "Micron Technology",
                                        "Optum",
                                        "Docker",
                                        "Swiggy",
                                        "Etsy",
                                        "Dropbox",
                                        "Airbnb",
                                        "Cerner",
                                        "Johnson & Johnson",
                                        "Stripe",
                                        "Rakuten",
                                        "Alibaba",
                                        "Oracle",
                                        "Uber",
                                        "Activision Blizzard",
                                        "DoorDash",
                                        "Robinhood",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem is the core concept behind the functionality of many diff tools, version control systems like Git, or text comparison software, where it's essential to quickly and accurately determine the longest common substring for effective file comparison and tracking changes between different versions of a document or source code. It is also widely used in DNA sequence alignment in bioinformatics.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as the length of the longest common substring ending at str1[i-1] and str2[j-1]."
                                        },
                                        {
                                            "hint": "\"If str1[i-1] == str2[j-1]: dp[i][j]=dp[i1][j1]+1 Otherwise, reset dp[i][j] = 0 (since a substring must be contiguous). \""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "LCS allows characters to be non-contiguous, whereas Longest Common Substring (LCS) requires contiguous matches.\nExample:\nstr1 = \"abcde\", str2 = \"ace\"  LCS = \"ace\" (length 3).\nstr1 = \"abcde\", str2 = \"cde\"  LCS (Substring) = \"cde\" (length 3).",
                                            "question": "How is this different from Longest Common Subsequence (LCS)?"
                                        },
                                        {
                                            "answer": "The longest substring can end anywhere in str1 or str2. Thus, we must store the maximum encountered.",
                                            "question": "Why do we need to track the maximum value separately?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store end_index, then extract the substring using str1[end_index - max_length : end_index].",
                                            "question": "How would you reconstruct the actual longest common substring instead of just its length?"
                                        },
                                        {
                                            "answer": "Yes! Suffix trees can efficiently find the longest common substring in O(n + m) time.",
                                            "question": "Can this problem be solved using a suffix tree?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_longestpalindromicsubsequence",
                                "problem_name": "Longest palindromic subsequence",
                                "problem_slug": "longest-palindromic-subsequence",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Bungie",
                                        "Mastercard",
                                        "Rakuten",
                                        "Wayfair",
                                        "Johnson & Johnson",
                                        "Siemens Healthineers",
                                        "Morgan Stanley",
                                        "Roche",
                                        "Dropbox",
                                        "AMD",
                                        "DoorDash",
                                        "Unity Technologies",
                                        "McKinsey & Company",
                                        "Target",
                                        "Boston Consulting Group",
                                        "Pinterest",
                                        "American Express",
                                        "OYO Rooms",
                                        "Square",
                                        "Etsy",
                                        "Activision Blizzard",
                                        "Cerner",
                                        "ARM",
                                        "Salesforce",
                                        "IBM",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem's underlying concept is usually used in data analysis, natural language processing, and data validation. For instance, in DNA or RNA sequence analysis, to ensure the palindromic sequences (which are vital for some biological functions), the concept of minimum insertions to make a palindrome is applied. In Natural Language Processing, text-based user interfaces and chatbots might use it to generate 'palindromic sentences', which could be a fun feature or a useful tool for linguistic studies. Also, it teaches us about dynamic programming, a Method used throughout programming for optimizing problems by breaking them down into simpler subproblems.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][j] as the length of the longest palindromic subsequence in s[i:j]. Recurrence Relation: If s[i] == s[j]: dp[i][j]=dp[i+1][j1]+2 Otherwise, remove one character and take the maximum LPS found: dp[i][j]=max(dp[i+1][j],dp[i][j1])\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If we reverse s and compute LCS between s and reverse(s), the result is the LPS.\nThis works because a palindrome remains the same when reversed, so the longest common sequence between s and reverse(s) is the longest palindromic subsequence.",
                                            "question": "Why does this problem resemble the Longest Common Subsequence (LCS)?"
                                        },
                                        {
                                            "answer": "Removing either s[i] or s[j] provides two possible subsequences.\nWe take the maximum LPS from both choices.",
                                            "question": "Why do we take max(dp[i+1][j], dp[i][j-1]) when s[i]  s[j]?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store parent indices while computing dp[], then backtrack to reconstruct the sequence.",
                                            "question": "How would you reconstruct the actual longest palindromic subsequence instead of just its length?"
                                        },
                                        {
                                            "answer": "Compute LPS(s), then insert missing characters from s to match the palindrome.",
                                            "question": "What if we wanted the shortest sequence that becomes a palindrome after insertions?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_minimuminsertionstomakestringpalindroms",
                                "problem_name": "Minimum insertions to make string palindrome",
                                "problem_slug": "minimum-insertions-to-make-string-palindrome",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Boston Consulting Group",
                                        "Deloitte",
                                        "Western Digital",
                                        "Rakuten",
                                        "Red Hat",
                                        "Epic Systems",
                                        "Seagate Technology",
                                        "Splunk",
                                        "Oracle",
                                        "Target",
                                        "Freshworks",
                                        "NVIDIA",
                                        "Square",
                                        "Rockstar Games",
                                        "PayPal",
                                        "Wayfair",
                                        "Philips Healthcare",
                                        "Riot Games",
                                        "Walmart",
                                        "Morgan Stanley",
                                        "Swiggy",
                                        "IBM",
                                        "Mastercard",
                                        "Snowflake",
                                        "Goldman Sachs",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept for this problem is extensively used in bioinformatics, especially in the development of various genome sequence alignment algorithms. In the context of the software industry, methods to examine and create palindromes are heavily used in data validation, error checking, and text analysis tools. Additionally, these concepts are used to create all kinds of puzzles and games that enhance mental skills and are found in many educational apps.",
                                    "hints": [
                                        {
                                            "hint": "\"The minimum insertions required to make s a palindrome is the number of characters not already part of the longest palindromic subsequence (LPS). MinInsertions=LengthofsLengthofLPS(s)\""
                                        },
                                        {
                                            "hint": "\"Compute LCS(s, reverse(s)) using Dynamic Programming (DP). The LCS of s and reverse(s) gives the LPS of s because a palindrome reads the same forward and backward.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since a palindrome is symmetric, the extra characters needed to make s symmetric are those not already part of the LPS.",
                                            "question": "Why does Min Insertions = len(s) - LPS(s)?"
                                        },
                                        {
                                            "answer": "The LCS between s and reverse(s) finds the longest sequence of characters that are already in a palindrome order.\nThis eliminates the need for checking all subsequences manually.",
                                            "question": "Why do we compute LPS using LCS instead of a direct DP approach?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Compute Longest Palindromic Subsequence (LPS) and use: MinDeletions=len(s)LPS(s)",
                                            "question": "How would you modify this problem to allow k deletions instead of insertions?"
                                        },
                                        {
                                            "answer": "The smallest palindrome that contains s as a subsequence is built by inserting missing characters.",
                                            "question": "How does this relate to the Shortest Palindromic Supersequence?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_minimuminsertionsordeletionstoconvertstringatob",
                                "problem_name": "Minimum insertions or deletions to convert string A to B",
                                "problem_slug": "minimum-insertions-or-deletions-to-convert-string-a-to-b",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Bloomberg",
                                        "PwC",
                                        "Nutanix",
                                        "Docker",
                                        "Salesforce",
                                        "Snowflake",
                                        "Pinterest",
                                        "Micron Technology",
                                        "Databricks",
                                        "HCL Technologies",
                                        "Byju's",
                                        "Lyft",
                                        "NVIDIA",
                                        "Rockstar Games",
                                        "Splunk",
                                        "KPMG",
                                        "AMD",
                                        "Western Digital",
                                        "Epic Systems",
                                        "Wayfair",
                                        "Flipkart",
                                        "Visa",
                                        "Deloitte",
                                        "Unity Technologies",
                                        "Target",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One practical application of this problem in the software industry is in the realm of Version Control Systems like Git. When making changes to code, Git determines the differences (or 'diff') between two files. This involves determining the minimum number of changes that need to be made to transform one file into another, very similar to this problem. This function allows developers to easier identify, review, and understand changes made to the codebase.",
                                    "hints": [
                                        {
                                            "hint": "\"Instead of transforming str1 into str2 directly, find their Longest Common Subsequence (LCS). The LCS represents the common part that should remain unchanged. The rest of the characters in str1 must be deleted, and the missing characters from str2 must be inserted.\""
                                        },
                                        {
                                            "hint": "\"MinDeletions=len(str1)LCS(str1,str2) MinInsertions=len(str2)LCS(str1,str2)  TotalOperations=MinInsertions+MinDeletions\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Since LCS represents the common part that should remain unchanged, the remaining characters in str1 must be deleted.",
                                            "question": "Why does Min Deletions = len(str1) - LCS(str1, str2)?"
                                        },
                                        {
                                            "answer": "Yes! Represent str1 and str2 as nodes and find the shortest transformation path.",
                                            "question": "Can this problem be solved using a graph-based approach?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent pointer in dp[] and backtrack to generate edit steps.",
                                            "question": "How would you reconstruct the actual sequence of insertions and deletions?"
                                        },
                                        {
                                            "answer": "Convert the problem to Edit Distance DP, where:\nInsert = 1, Delete = 1, Replace = 1.",
                                            "question": "How would you modify this problem to allow k substitutions as well?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_shortestcommonsupersequence",
                                "problem_name": "Shortest common supersequence",
                                "problem_slug": "shortest-common-supersequence",
                                "problem_rank": 6,
                                "misc": {
                                    "tags": [
                                        "Stripe",
                                        "Deloitte",
                                        "eBay",
                                        "Byju's",
                                        "Rockstar Games",
                                        "Twilio",
                                        "Dropbox",
                                        "Freshworks",
                                        "Boston Consulting Group",
                                        "Qualcomm",
                                        "Bloomberg",
                                        "Zynga",
                                        "Texas Instruments",
                                        "Rakuten",
                                        "Ubisoft",
                                        "OYO Rooms",
                                        "Robinhood",
                                        "Flipkart",
                                        "Oracle",
                                        "Airbnb",
                                        "MongoDB",
                                        "Bungie",
                                        "Electronic Arts",
                                        "Salesforce",
                                        "HashiCorp",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of finding the shortest common supersequence, as this problem explores, has applications in the field of bioinformatics. It is used in DNA sequence alignment, which is a way of arranging the sequences of DNA, RNA, or protein to identify regions of similarity. These methods are used to explore functional, structural, or evolutionary relationships between the sequences. In software development, algorithms solving this problem are used in applications that aim to align, compare, and analyze genetic material.",
                                    "hints": [
                                        {
                                            "hint": "\"The Shortest Common Supersequence (SCS) must contain both str1 and str2 as subsequences. The LCS of str1 and str2 represents the common part that appears only once in the SCS. The extra characters in str1 and str2 (not in the LCS) must be included.\""
                                        },
                                        {
                                            "hint": "\"SCSLength=len(str1)+len(str2)LCS(str1,str2)  Compute LCS(str1, str2). Use it to construct the SCS string.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Use LCS-based backtracking:\nIf str1[i-1] == str2[j-1], add it to SCS.\nOtherwise, append the character from str1 or str2 that leads to the LCS.",
                                            "question": "How do we construct the actual Shortest Common Supersequence?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use Generalized LCS DP to find the common subsequence across k strings, then construct the SCS.",
                                            "question": "How would you extend this problem for k strings instead of just two?"
                                        },
                                        {
                                            "answer": "Track multiple paths in dp[], then backtrack to generate all possible sequences.",
                                            "question": "How would you modify the problem to allow multiple optimal SCS outputs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_distinctsubsequences",
                                "problem_name": "Distinct subsequences",
                                "problem_slug": "distinct-subsequences",
                                "problem_rank": 7,
                                "misc": {
                                    "tags": [
                                        "Target",
                                        "Riot Games",
                                        "Swiggy",
                                        "Byju's",
                                        "AMD",
                                        "Bungie",
                                        "Databricks",
                                        "Johnson & Johnson",
                                        "PayPal",
                                        "Siemens Healthineers",
                                        "McKinsey & Company",
                                        "Stripe",
                                        "Bloomberg",
                                        "ARM",
                                        "Nutanix",
                                        "Etsy",
                                        "Optum",
                                        "Twilio",
                                        "Texas Instruments",
                                        "GE Healthcare",
                                        "Seagate Technology",
                                        "Pinterest",
                                        "Visa",
                                        "Western Digital",
                                        "Zomato",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem concept is actually widely used in the field of Natural Language Processing (NLP), a subfield of artificial intelligence. In particular, it can be utilized in applications like text completion, correction, and even autocomplete. When processing user input, the software can compute possible subsequences from a pre-defined dictionary of words and phrases, and provide autocorrect or autocomplete suggestions that match the user's typed string, improving the user's experience by reducing the effort required to type long or complex phrases.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as the number of ways to form t[0:j] using s[0:i]."
                                        },
                                        {
                                            "hint": "\"If s[i-1] == t[j-1], we can either: Use s[i-1] to match t[j-1] (dp[i-1][j-1]). Ignore s[i-1] and continue matching (dp[i-1][j]) and If s[i-1]  t[j-1], we must ignore s[i-1].\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "This accounts for cases where we include s[i-1] in forming t.",
                                            "question": " Why do we add dp[i-1][j-1] when characters match?"
                                        },
                                        {
                                            "answer": "If they match, we can either use or skip s[i-1] while forming t.",
                                            "question": "Why do we need to check s[i-1] == t[j-1]?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent pointer in dp[], then backtrack to generate all valid subsequences.",
                                            "question": "How would you reconstruct the actual subsequences instead of just counting them?"
                                        },
                                        {
                                            "answer": "Modify the recurrence relation to allow universal matches when t[j-1] == '?'.",
                                            "question": "How would this problem change if t contained wildcards (?) that can match any character in s?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_editdistance",
                                "problem_name": "Edit distance",
                                "problem_slug": "edit-distance",
                                "problem_rank": 8,
                                "misc": {
                                    "tags": [
                                        "Freshworks",
                                        "Databricks",
                                        "Texas Instruments",
                                        "Swiggy",
                                        "American Express",
                                        "Siemens Healthineers",
                                        "Etsy",
                                        "Shopify",
                                        "Dropbox",
                                        "Deloitte",
                                        "PwC",
                                        "Salesforce",
                                        "Snowflake",
                                        "Unity Technologies",
                                        "Walmart",
                                        "Nutanix",
                                        "Optum",
                                        "Qualcomm",
                                        "Cloudflare",
                                        "Johnson & Johnson",
                                        "Epic Systems",
                                        "IBM",
                                        "McKinsey & Company",
                                        "Bloomberg",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "One practical real-world application of this problem is in spell-checking and auto-correction algorithms in text editing software and various applications like Google Docs, MS Word, or even your smartphone's keyboard. The underlying concept is known as Levenshtein distance, which defines the minimum number of single-character edits required to change one word into another. The fewer the changes required, the higher the probability that the words are similar or related, which can be used to suggest corrections or alterations for misspelled words or for predictive text functionality.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as the minimum number of operations required to convert start[0:i] into target[0:j]."
                                        },
                                        {
                                            "hint": "If start[i-1] == target[j-1], no operation is needed dp[i][j]=dp[i1][j1]. Otherwise, we can insert, delete and replace."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If target is empty, we must delete all characters from start.\nIf start is empty, we must insert all characters from target.",
                                            "question": "Why does dp[i][0] = i and dp[0][j] = j?"
                                        },
                                        {
                                            "answer": "Because we must choose the least costly operation at each step to reach target efficiently.",
                                            "question": "Why do we take min(insert, delete, replace)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Store a parent pointer while computing dp[], then backtrack to generate the full transformation sequence.",
                                            "question": "How would you reconstruct the actual edit operations instead of just the count?"
                                        },
                                        {
                                            "answer": "Adjust the cost function:\nInsert/Deletion = 1\nSubstitution = w > 1\n",
                                            "question": " How would you modify this problem if substitutions were more expensive than insertions and deletions?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_dponstrings_wildcardmatching",
                                "problem_name": "Wildcard matching",
                                "problem_slug": "wildcard-matching",
                                "problem_rank": 9,
                                "misc": {
                                    "tags": [
                                        "Qualcomm",
                                        "Texas Instruments",
                                        "PwC",
                                        "NVIDIA",
                                        "AMD",
                                        "Oracle",
                                        "Rockstar Games",
                                        "OYO Rooms",
                                        "Target",
                                        "Medtronic",
                                        "Lyft",
                                        "McKinsey & Company",
                                        "Docker",
                                        "Ubisoft",
                                        "JPMorgan Chase",
                                        "Uber",
                                        "ARM",
                                        "Red Hat",
                                        "Robinhood",
                                        "Siemens Healthineers",
                                        "MongoDB",
                                        "Stripe",
                                        "Epic Systems",
                                        "Zomato",
                                        "Intel",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This pattern matching problem forms the basis for one of the most essential functions in computer systems: file or text searching. The most basic example is wildcard searches in operating systems. In Windows, for instance, '?' is used to replace any single character and '*' is used to replace a string of character(s). Besides, Regular Expressions (regex), a common tool used in programming for string pattern searching and manipulation, also rely on this concept. Regex is used extensively in programming from simple string manipulation, data validation, data scraping to more complicated natural language processing tasks.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as True if str[0:i] matches pat[0:j], otherwise False."
                                        },
                                        {
                                            "hint": "\"If pat[j-1] == str[i-1] or pat[j-1] == '?', dp[i][j]=dp[i1][j1] If pat[j-1] == '*', dp[i][j]=dp[i1][j](use*asasequence) OR dp[i][j1](ignore*) Otherwise, dp[i][j] = False.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "dp[i-1][j]  Considers * as matching one or more characters.\ndp[i][j-1]  Considers * as matching zero characters.",
                                            "question": "Why do we check dp[i-1][j] and dp[i][j-1] when pat[j-1] == '*'?"
                                        },
                                        {
                                            "answer": "Yes! Since dp[i][j] only depends on the previous row, we use rolling arrays (prev[] and curr[]), reducing space to O(m).",
                                            "question": " Can we optimize space from O(n  m) to O(m)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent pointer while computing dp[], then backtrack to extract the matching substrings.",
                                            "question": "How would you modify this problem to return the actual matched substrings instead of just True/False?"
                                        },
                                        {
                                            "answer": "Regular Expression Matching allows . (single character match) and * (previous character match multiple times), while this problem allows ? (single character) and * (any sequence).",
                                            "question": "How does this relate to the Regular Expression Matching problem?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_mcmdp",
                        "subcategory_name": "MCM DP",
                        "subcategory_slug": "mcm-dp",
                        "subcategory_rank": 8,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_mcmdp_matrixchainmultiplication",
                                "problem_name": "Matrix chain multiplication",
                                "problem_slug": "matrix-chain-multiplication",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Swiggy",
                                        "Square",
                                        "HCL Technologies",
                                        "Docker",
                                        "PwC",
                                        "KPMG",
                                        "Activision Blizzard",
                                        "Salesforce",
                                        "Walmart",
                                        "Electronic Arts",
                                        "McKinsey & Company",
                                        "Bloomberg",
                                        "Twilio",
                                        "ARM",
                                        "OYO Rooms",
                                        "Target",
                                        "Seagate Technology",
                                        "Goldman Sachs",
                                        "Deloitte",
                                        "Johnson & Johnson",
                                        "Boston Consulting Group",
                                        "Western Digital",
                                        "American Express",
                                        "Cerner",
                                        "Unity Technologies",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "A fun fact about this problem's practical usage can be seen in the field of computer graphics. The stages of a 3D graphics pipeline often involve multiplication of matrices for transformations like scaling, rotation, translation, and shearing. Having an efficient way to multiply these matrices can make the graphics rendering faster and more efficient, significantly improving the performance and speed of video games, simulations, 3D modeling software, and more!",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][j] as the minimum number of scalar multiplications required to multiply matrices from Ai to Aj. The goal is to find optimal parenthesization that minimizes multiplications.\""
                                        },
                                        {
                                            "hint": "\"We try every possible split point k where Ai...Ak is multiplied first, followed by Ak+1...Aj. The cost of multiplying these two subchains, plus the cost of multiplying the resulting matrices, is: dp[i][j]=  ik<j min (dp[i][k]+dp[k+1][j]+nums[i1]nums[k]nums[j])\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Multiplying matrices A[i-1] x A[k] with A[k] x A[j] results in a matrix of size A[i-1] x A[j].\nThe cost of multiplication is the product of these dimensions.",
                                            "question": "Why do we use nums[i-1]  nums[k]  nums[j] in the cost calculation?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a bracket[][] array to store the split points and backtrack to construct the sequence.",
                                            "question": "How would you reconstruct the actual parenthesization of the optimal order?"
                                        },
                                        {
                                            "answer": "Use Dynamic Programming with DAG (Directed Acyclic Graph) representation to track possible sequences.",
                                            "question": "How would you modify this problem if matrix multiplication order was flexible (associative but not commutative)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_mcmdp_minimumcosttocutthestick",
                                "problem_name": "Minimum cost to cut the stick",
                                "problem_slug": "minimum-cost-to-cut-the-stick",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Morgan Stanley",
                                        "McKinsey & Company",
                                        "Activision Blizzard",
                                        "Cerner",
                                        "Target",
                                        "Swiggy",
                                        "Airbnb",
                                        "Pinterest",
                                        "Reddit",
                                        "Goldman Sachs",
                                        "Medtronic",
                                        "Splunk",
                                        "Docker",
                                        "Johnson & Johnson",
                                        "Instacart",
                                        "Roblox",
                                        "Uber",
                                        "Ubisoft",
                                        "Flipkart",
                                        "Databricks",
                                        "Robinhood",
                                        "GE Healthcare",
                                        "KPMG",
                                        "Wayfair",
                                        "Mastercard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem is a practical example of optimization algorithms used in different sectors of the software industry. One real-world application of this problem is in network routing and bandwidth allocation, where data packets (the equivalent of wooden stick segments in the problem) need to be efficiently distributed across the network. A network needs to be cut/divided (i.e., routes need to be opened/closed) to better distribute the data flow, but each cut (alteration to the network routes) carries a cost (both in system processing and potential slowdown of data transfer), so the development of routing or bandwidth allocation software needs to take into account how to optimize these cuts in order to achieve the best overall efficiency.",
                                    "hints": [
                                        {
                                            "hint": "\"Define dp[i][j] as the minimum cost to cut the stick between cuts[i] and cuts[j]. The goal is to minimize the sum of the stick lengths at each cut.\""
                                        },
                                        {
                                            "hint": "\"Sort cuts and add 0 (start) and n (end) to the array. For each subproblem (i, j), try every possible cut k between them: dp[i][j]= i<k<j min (dp[i][k]+dp[k][j]+(cuts[j]cuts[i])) The cost of cutting at cuts[k] is the length of the current stick (cuts[j] - cuts[i]). The subproblems dp[i][k] and dp[k][j] are computed first before using them in dp[i][j].\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Sorting ensures that cuts are considered in increasing order, allowing us to divide the stick into valid partitions.",
                                            "question": "Why do we sort cuts[] before using DP?"
                                        },
                                        {
                                            "answer": "The stick of length (cuts[j] - cuts[i]) must be cut at some k, which incurs a cost.\nThe recursive formula finds the optimal way to make cuts in (i, j).",
                                            "question": "Why does dp[i][j] = cuts[j] - cuts[i] + min(dp[i][k] + dp[k][j])?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, but without memoization, it becomes exponential.",
                                            "question": "Can this problem be solved using divide-and-conquer?"
                                        },
                                        {
                                            "answer": "Update dp[i][j] to account for extra cost per cut, adding weight-based values.",
                                            "question": "How would you modify this problem if some cuts had additional costs?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_mcmdp_burstballoons",
                                "problem_name": "Burst balloons",
                                "problem_slug": "burst-balloons",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Freshworks",
                                        "HCL Technologies",
                                        "Pinterest",
                                        "Roblox",
                                        "KPMG",
                                        "Optum",
                                        "Goldman Sachs",
                                        "IBM",
                                        "Seagate Technology",
                                        "Target",
                                        "Unity Technologies",
                                        "Byju's",
                                        "Databricks",
                                        "Zynga",
                                        "Broadcom",
                                        "Shopify",
                                        "Cerner",
                                        "Uber",
                                        "Salesforce",
                                        "JPMorgan Chase",
                                        "Square",
                                        "Stripe",
                                        "Robinhood",
                                        "Mastercard",
                                        "Red Hat",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This problem, dubbed as the \"Burst Balloons\" problem, embodies the concept of dynamic programming, an essential technique widely used in software industry to solve optimization problems. Its real-world application can be seen in resource allocation tasks where we need to make a sequence of interrelated decisions. For example, in network routing, a form of this problem could be used to determine the optimal path (balloons to burst) that would minimize cost (maximize coins) while transferring data from source to destination. It stands as a classic example showcasing the importance of decision optimization and state transition in programming.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i][j] as the maximum coins obtained by bursting balloons in the range [i, j]."
                                        },
                                        {
                                            "hint": "\"The final burst at k contributes nums[i-1] * nums[k] * nums[j+1] coins. Solve subproblems first, then use them to compute dp[i][j].\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Bursting in order creates dependencies on future states.\nIf we choose the last balloon to burst in a range, then only adjacent balloons remain, allowing clean DP transitions.",
                                            "question": " Why do we solve the problem in reverse (choosing the last balloon to burst)?"
                                        },
                                        {
                                            "answer": "The out-of-bounds multipliers act as 1, simplifying boundary calculations.",
                                            "question": "Why do we add 1 at both ends of nums?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Maintain a parent[][] array to store which balloon was burst last in dp[i][j], then backtrack to extract the sequence.",
                                            "question": "How would you reconstruct the actual order of bursting?"
                                        },
                                        {
                                            "answer": "This becomes a greedy scheduling problem, requiring a different strategy to decide the next balloon to burst.",
                                            "question": "What if the order of bursting mattered (not choosing the last burst dynamically)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_mcmdp_palindromepartitioningii",
                                "problem_name": "Palindrome partitioning II",
                                "problem_slug": "palindrome-partitioning-ii-",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Teladoc Health",
                                        "Philips Healthcare",
                                        "Pinterest",
                                        "Square",
                                        "Medtronic",
                                        "Unity Technologies",
                                        "Visa",
                                        "Cerner",
                                        "AMD",
                                        "Electronic Arts",
                                        "Uber",
                                        "Wayfair",
                                        "Stripe",
                                        "Epic Systems",
                                        "Swiggy",
                                        "Oracle",
                                        "Western Digital",
                                        "Boston Consulting Group",
                                        "Micron Technology",
                                        "Johnson & Johnson",
                                        "Texas Instruments",
                                        "IBM",
                                        "Ernst & Young",
                                        "Shopify",
                                        "Bain & Company",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This kind of problem or its underlying approach is often used in text processing software and algorithms, such as spell-checkers or text editors. Detecting palindromes or structuring information in a way that allows for efficient checks is crucial in natural language processing tasks. For example, similar strategies are used in auto-correct systems in modern smartphones and word processing software to suggest the smallest number of changes to make in order to turn a misspelled word into a correct one.",
                                    "hints": [
                                        {
                                            "hint": "Define dp[i] as the minimum number of cuts needed to partition s[0:i] into palindromes. Check all possible palindrome substrings ending at i."
                                        },
                                        {
                                            "hint": "\"Define isPalindrome[i][j] = True if s[i:j] is a palindrome. Use isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i+1][j-1]) for efficient checking.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "It ensures that the previous partition s[0:j] had the minimum cuts before the next valid palindrome.",
                                            "question": "Why does dp[i] = min(dp[j] + 1) work?"
                                        },
                                        {
                                            "answer": "A full palindrome requires zero cuts, so no further partitions are needed.",
                                            "question": "Why does dp[i] = 0 if s[0:i] is already a palindrome?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Track k partitions and extend DP to include a k constraint.",
                                            "question": "How would this problem change if we allowed k non-palindromic partitions?"
                                        },
                                        {
                                            "answer": "Use Multi-dimensional DP (dp[i][k]), ensuring exactly k partitions.",
                                            "question": "What if we needed to partition into exactly k palindromic substrings?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "dynamicprogramming_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "dp-contest-2",
                        "subcategory_rank": 9,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_contest_mexx",
                                "problem_name": "MEXX",
                                "problem_slug": "mexx",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "n = 10, nums = [1, 3, 2, 0, 1, 0, 2, 2, 2, 0]",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "dynamicprogramming_dynamicprogramming_contest_buyflowers",
                                "problem_name": "Buy Flowers",
                                "problem_slug": "buy-flowers",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [],
                                    "facts": "",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "tries",
                "category_name": "Tries",
                "category_slug": "tries",
                "category_rank": 16,
                "subcategories": [
                    {
                        "subcategory_id": "tries_triessubc",
                        "subcategory_name": "Theory",
                        "subcategory_slug": "triessubc",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "tries_tries_triessubc_trieimplementationandoperations",
                                "problem_name": "Trie Implementation and Operations",
                                "problem_slug": "trie-implementation-and-operations",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Databricks",
                                        "Dropbox",
                                        "Uber",
                                        "Epic Games",
                                        "Zynga",
                                        "Goldman Sachs",
                                        "Seagate Technology",
                                        "Medtronic",
                                        "Chewy",
                                        "Broadcom",
                                        "Rakuten",
                                        "Snowflake",
                                        "Robinhood",
                                        "McKinsey & Company",
                                        "American Express",
                                        "MongoDB",
                                        "Square",
                                        "Wayfair",
                                        "Electronic Arts",
                                        "Western Digital",
                                        "Cloudflare",
                                        "Unity Technologies",
                                        "Alibaba",
                                        "ARM",
                                        "Bloomberg",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun fact: The Trie data structure is a popular data structure used in many applications in the software industry, including autocomplete features on search engines and text editors. Whenever you type in a search query or a piece of code, the system makes use of Tries to suggest potential completions based on the prefix of your input. This ability to make fast prefix queries makes Tries highly efficient for these kinds of functions.",
                                    "hints": [
                                        {
                                            "hint": "Insertion is performed character by character, ensuring that each character has an associated node. If a character does not exist in the current nodes children, a new node is created. Traversal continues until the entire word is inserted. Searching follows a similar traversal approach, checking if each character exists along the path and verifying if the terminal node is reached."
                                        },
                                        {
                                            "hint": "The startsWith function is slightly different, as it only checks if a given prefix exists without requiring it to be a full word. This is useful for autocomplete and dictionary applications. A well-optimized Trie provides fast lookup and insertion, outperforming hash-based methods when handling large dictionaries with shared prefixes."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Unlike hash-based structures, a Trie allows prefix-based operations, making it ideal for problems like autocomplete or dictionary lookups. Additionally, Tries maintain lexicographical order, whereas hash-based structures do not.",
                                            "question": "Why use a Trie instead of a HashMap or Set?"
                                        },
                                        {
                                            "answer": "The structure remains the same, as duplicate words follow the same insertion path. However, the end-of-word marker ensures correct identification when searching.",
                                            "question": "What happens if we insert duplicate words into a Trie?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Wildcard searches require modifying the search operation to handle characters like ? or *. This typically involves using backtracking or DFS to explore multiple paths when encountering a wildcard.",
                                            "question": "How would you modify a Trie to support wildcard searches?"
                                        },
                                        {
                                            "answer": "A Suffix Tree is a compressed Trie storing all suffixes of a given string, making it useful for substring searches and pattern matching. It is more space-efficient for long strings with repeated substrings.",
                                            "question": "How does a Trie compare to a Suffix Tree?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "tries_tries_triessubc_trieimplementationandadvancedoperations",
                                "problem_name": "Trie Implementation and Advanced Operations",
                                "problem_slug": "trie-implementation-and-advanced-operations",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Docker",
                                        "Byju's",
                                        "Rockstar Games",
                                        "Instacart",
                                        "Freshworks",
                                        "Pinterest",
                                        "HCL Technologies",
                                        "Cerner",
                                        "Alibaba",
                                        "Riot Games",
                                        "Robinhood",
                                        "OYO Rooms",
                                        "Boston Consulting Group",
                                        "Databricks",
                                        "Micron Technology",
                                        "PwC",
                                        "Texas Instruments",
                                        "Activision Blizzard",
                                        "American Express",
                                        "Siemens Healthineers",
                                        "DoorDash",
                                        "Bloomberg",
                                        "Splunk",
                                        "Morgan Stanley",
                                        "Snowflake",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The Trie data structure, also known as a prefix tree, is incredibly useful in real-world applications, especially in scenarios where we need fast and efficient retrieval of words or data. For instance, it is the underlying data structure powering the auto-complete feature in your smartphone keyboard or search engine. When you start typing, it looks for words in its trie data structure that starts with the prefix you've typed and proposes the most probable completions. Similarly, spell-checking tools or predictive text technology in chatbots and AI-based customer service platforms make extensive use of Tries.",
                                    "hints": [
                                        {
                                            "hint": "Insertion follows a character-by-character traversal, incrementing both prefix_count for all traversed nodes and word_count at the last character node. Searching for exact words involves checking word_count, while prefix-based searches rely on prefix_count."
                                        },
                                        {
                                            "hint": "To efficiently erase a word, the word count is decremented at the last character node, and prefix_count values are reduced along the path. If word_count reaches zero but the prefix is still used by other words, the structure remains intact. However, if no words depend on a node, it can be deleted to free memory."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The word_count ensures that we track multiple occurrences of the same word, while prefix_count helps determine how many words share a given prefix. Without prefix_count, prefix-based queries would require a complete traversal of the subtree.",
                                            "question": "Why do we need word_count and prefix_count separately?"
                                        },
                                        {
                                            "answer": "If a word is removed but is a prefix for other words, only word_count is decremented, and the node is not deleted. Nodes are only removed when no other words depend on them.",
                                            "question": "How does erasing work when a word is a prefix for other words?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Erasing takes O(n) time in the worst case, as it follows the path of the word. Optimizations include lazy deletion (marking words as deleted but keeping nodes until cleanup) to avoid frequent memory reallocations.",
                                            "question": "How does erasing affect time complexity, and how can we optimize it?"
                                        },
                                        {
                                            "answer": "Converting all words to lowercase before insertion and search ensures uniform handling of uppercase and lowercase characters.",
                                            "question": "How would you modify this Trie to support case-insensitive searches?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "tries_problems",
                        "subcategory_name": "Problems",
                        "subcategory_slug": "problems",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "tries_tries_problems_longestwordwithallprefixes",
                                "problem_name": "Longest word with all prefixes",
                                "problem_slug": "longest-word-with-all-prefixes",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Nutanix",
                                        "AMD",
                                        "Rakuten",
                                        "IBM",
                                        "Chewy",
                                        "Seagate Technology",
                                        "Walmart",
                                        "Qualcomm",
                                        "Ernst & Young",
                                        "Etsy",
                                        "Goldman Sachs",
                                        "Red Hat",
                                        "Rockstar Games",
                                        "Byju's",
                                        "American Express",
                                        "Oracle",
                                        "Optum",
                                        "Ubisoft",
                                        "Databricks",
                                        "Bain & Company",
                                        "Lyft",
                                        "NVIDIA",
                                        "Dropbox",
                                        "GE Healthcare",
                                        "Roblox",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This programming problem employs a concept often used in search engine algorithms for keyword searching and for autocompletion features in user interface design. For instance, when typing in a search engine or web address in a browser, the system relies on similar logic to suggest lexicographically sorted completions based on previous input or commonly used phrases. The ability to efficiently solve this type of problem has real-world impacts on enhancing user experience and speeding up input tasks - something we take for granted every day!",
                                    "hints": [
                                        {
                                            "hint": "Build a Trie from the given array while marking the end of each word. Additionally, store a flag at each node to indicate whether this prefix exists in nums."
                                        },
                                        {
                                            "hint": "\"Find the longest complete string by iterating through nums and checking whether every prefix of a word exists in the Trie. Maintain a variable to track the longest valid string. If two strings have the same length, return the lexicographically smallest one.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "If multiple strings have the same length, we return the lexicographically smallest one. This can be handled by comparing strings whenever we find a new candidate.",
                                            "question": "What happens if there are multiple longest complete strings?"
                                        },
                                        {
                                            "answer": "No, insertion order does not affect the Tries structure. However, when finding the longest complete string, sorting nums lexicographically ensures we naturally select the smallest string when lengths are equal.",
                                            "question": "Does order of insertion matter in a Trie?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of tracking only the longest word, we would collect all words that satisfy the complete string condition and sort them before returning the result.\n",
                                            "question": "How would the solution change if we had to return all complete strings instead of just the longest one?"
                                        },
                                        {
                                            "answer": "Yes, by using a HashSet to store all words, we can iterate through nums, checking for every prefix in the set. However, this would require checking each prefix separately, making it less efficient than a Trie.",
                                            "question": "Can we solve this problem without a Trie?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "tries_tries_problems_numberofdistinctsubstringsinastring",
                                "problem_name": "Number of distinct substrings in a string",
                                "problem_slug": "number-of-distinct-substrings-in-a-string",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Databricks",
                                        "MongoDB",
                                        "OYO Rooms",
                                        "IBM",
                                        "Intel",
                                        "DoorDash",
                                        "Cloudflare",
                                        "McKinsey & Company",
                                        "Splunk",
                                        "Seagate Technology",
                                        "Wayfair",
                                        "Bloomberg",
                                        "JPMorgan Chase",
                                        "Texas Instruments",
                                        "Instacart",
                                        "Bain & Company",
                                        "Morgan Stanley",
                                        "Ubisoft",
                                        "Western Digital",
                                        "Unity Technologies",
                                        "Byju's",
                                        "HCL Technologies",
                                        "Boston Consulting Group",
                                        "Johnson & Johnson",
                                        "HashiCorp",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The concept of 'distinct substrings' is a fundamental in many applications across the software industry. For instance, in the fields of bioinformatics and DNA sequencing, this concept is utilized to analyze and identify unique patterns or sequences in the DNA. Moreover, in data mining and machine learning, finding distinct substrings often plays a pivotal role in text analysis, string matching, extraction of unique features and plagiarism detection systems. The efficiency and accuracy of such crucial applications are largely dependent on the implementation of algorithms that swiftly and accurately solve such problems.",
                                    "hints": [
                                        {
                                            "hint": "A Trie-based approach can be used by inserting all suffixes of s into a Trie and counting the total number of distinct substrings contributed by each suffix. However, this approach may be memory-intensive for long strings."
                                        },
                                        {
                                            "hint": "\"A more optimized approach is the Suffix Array + LCP (Longest Common Prefix) method: Construct a Suffix Array to sort all suffixes of s in lexicographical order. Compute the LCP array, which stores the longest common prefix between adjacent suffixes. The total number of distinct substrings is given by the sum of lengths of suffixes minus the LCP contributions.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, Rolling Hashing (Rabin-Karp) can be used to check substring uniqueness, but handling hash collisions requires additional techniques.",
                                            "question": "Can we use hashing to count distinct substrings?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "A Dynamic Programming (DP) approach is needed, as subsequences allow character deletions from anywhere, unlike substrings.",
                                            "question": "How can we modify this approach for distinct subsequences instead of substrings?"
                                        },
                                        {
                                            "answer": "Instead of counting all substrings, we could maintain a rolling hash (or Suffix Array) and filter only substrings of length k.",
                                            "question": "How would the solution change if we needed only distinct substrings of length k?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "tries_tries_problems_maximumxoroftwonumbersinanarray",
                                "problem_name": "Maximum XOR of two numbers in an array",
                                "problem_slug": "maximum-xor-of-two-numbers-in-an-array",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Activision Blizzard",
                                        "Johnson & Johnson",
                                        "Etsy",
                                        "Lyft",
                                        "Flipkart",
                                        "Stripe",
                                        "Wayfair",
                                        "Splunk",
                                        "Roche",
                                        "Shopify",
                                        "Cerner",
                                        "Snowflake",
                                        "Visa",
                                        "Oracle",
                                        "PwC",
                                        "KPMG",
                                        "Chewy",
                                        "Rockstar Games",
                                        "Seagate Technology",
                                        "HashiCorp",
                                        "Dropbox",
                                        "MongoDB",
                                        "Airbnb",
                                        "IBM",
                                        "PayPal",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: XOR operations are commonly used in cryptography, a crucial component of data security in software development. In cryptography, XOR is used for its properties of being able to toggle between states. By using the same key again, you can decrypt the data. Similarly, finding the maximum XOR value can be used to enhance cryptographic algorithms making them more secure and harder to crack. This problem might not directly apply to a specific real-world application, but the concepts and algorithms used to solve it are fundamental to many areas in the software industry.",
                                    "hints": [
                                        {
                                            "hint": "\"Insert all numbers into a binary Trie:  Each number is represented as a 32-bit binary string. Each Trie node represents a bit (0 or 1), storing paths for efficient lookups.\""
                                        },
                                        {
                                            "hint": "\"While checking each number, traverse the Trie to find the best complement that maximizes the XOR value. The best complement for a bit is its opposite (i.e., 0 prefers 1 and vice versa).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The Trie allows quick prefix matching, helping us choose the optimal bits for maximizing XOR at each step. If a bit is 1, the best complement is 0 (and vice versa).",
                                            "question": "How does the Trie help in finding the best XOR pair?"
                                        },
                                        {
                                            "answer": "Yes, using a HashSet and a greedy approach, we can maintain prefixes and attempt to build the highest XOR value iteratively.",
                                            "question": "Can we use bitwise tricks without a Trie?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Yes, we can modify the Trie traversal to maintain a max-heap tracking the top K values.",
                                            "question": "Can we extend this approach to find the top K maximum XOR pairs?"
                                        },
                                        {
                                            "answer": "While XOR maximization requires a Trie, AND/OR-based problems often use sorting or bitwise filtering for efficiency.",
                                            "question": "How does this compare to problems like \"Maximum AND Pair\" or \"Maximum OR Pair\"?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "tries_tries_problems_maximumxorwithanelementfromanarray",
                                "problem_name": "Maximum Xor with an element from an array",
                                "problem_slug": "maximum-xor-with-an-element-from-an-array",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Broadcom",
                                        "Philips Healthcare",
                                        "Flipkart",
                                        "Goldman Sachs",
                                        "Alibaba",
                                        "Dropbox",
                                        "Docker",
                                        "Boston Consulting Group",
                                        "KPMG",
                                        "Rakuten",
                                        "Qualcomm",
                                        "Intel",
                                        "Byju's",
                                        "Twilio",
                                        "Texas Instruments",
                                        "GE Healthcare",
                                        "Salesforce",
                                        "Freshworks",
                                        "Ubisoft",
                                        "HCL Technologies",
                                        "Ernst & Young",
                                        "Wayfair",
                                        "Micron Technology",
                                        "JPMorgan Chase",
                                        "Square",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The concept underlying this problem, which is bitwise operations, has practical applications in many areas of software development. For example, in cryptographic algorithms, bitwise operations like XOR are used for encryption and decryption because of their computational efficiency. Additionally, they provide a simple yet effective method of scrambling data, which is crucial in maintaining the security of data. Therefore, understanding how to use bitwise operations effectively can make you a more effective software engineer in cybersecurity space.",
                                    "hints": [
                                        {
                                            "hint": "\"Sort nums to enable efficient constraint handling ( mi). Use a Trie to store valid numbers dynamically while processing queries in increasing order of mi.\""
                                        },
                                        {
                                            "hint": "\"For each query [xi, mi], find the best possible XOR using the Trie. Traverse the Trie to maximize the XOR value bit-by-bit, preferring the opposite bits.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A HashSet allows direct lookup, but does not support efficient bitwise prefix searching, making it less effective for XOR maximization.",
                                            "question": "Can we use a HashSet instead of a Trie?"
                                        },
                                        {
                                            "answer": "Sorting enables efficient filtering of elements within the  mi range, allowing incremental Trie insertions.",
                                            "question": "Why do we sort nums before processing queries?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The main difference is the constraint mi, requiring an additional range filtering mechanism (sorting + Trie insertions).",
                                            "question": "How does this differ from the \"Maximum XOR of Two Numbers in an Array\" problem?"
                                        },
                                        {
                                            "answer": "Yes, but it would require a segment tree or sorted data structure (like ordered maps) for efficient multi-constraint filtering.",
                                            "question": "Can this be extended to multi-dimensional constraints (e.g., another condition on nums[j])?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "strings(advancedalgo)",
                "category_name": "Strings (Advanced Algo)",
                "category_slug": "strings--advanced-algo",
                "category_rank": 17,
                "subcategories": [
                    {
                        "subcategory_id": "strings(advancedalgo)_mediumproblems",
                        "subcategory_name": "Medium Problems",
                        "subcategory_slug": "medium-problems",
                        "subcategory_rank": 1,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_mediumproblems_reverseeverywordinastring",
                                "problem_name": "Reverse every word in a string",
                                "problem_slug": "reverse-every-word-in-a-string",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "McKinsey & Company",
                                        "Epic Systems",
                                        "IBM",
                                        "Bain & Company",
                                        "Uber",
                                        "Ernst & Young",
                                        "Walmart",
                                        "PayPal",
                                        "Ubisoft",
                                        "HashiCorp",
                                        "Micron Technology",
                                        "Teladoc Health",
                                        "Morgan Stanley",
                                        "Wayfair",
                                        "ARM",
                                        "Swiggy",
                                        "Freshworks",
                                        "Boston Consulting Group",
                                        "Activision Blizzard",
                                        "Nutanix",
                                        "Zomato",
                                        "Broadcom",
                                        "Chewy",
                                        "Reddit",
                                        "Target",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: This problem uses a fundamental concept called 'string manipulation', which is essential in developing search engines and web crawling tools. For instance, Google utilizes advanced string manipulation to analyze and index webpages effectively. Similarly, Twitter uses string manipulations for tweet processing and data analytics to figure out trending topics. This simple problem of reversing words in a string can thus be a stepping stone to understanding more complex string operations used in real-world applications.",
                                    "hints": [
                                        {
                                            "hint": "\"Splitting the string into words using split(), which automatically removes extra spaces. Reversing the list of words. Joining them back with a single space.\""
                                        },
                                        {
                                            "hint": "\"Iterating through the string in reverse, extracting words character-by-character, and storing them in a list. Reconstructing the sentence with spaces in between.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Spaces between words can be irregular, and using split() ensures that extra spaces are ignored when reversing.",
                                            "question": "Why do we need to handle multiple spaces separately?"
                                        },
                                        {
                                            "answer": "Yes, but it requires modifying the string by:\nReversing the entire string.\nReversing individual words while maintaining correct spacing.\nThis approach is useful for low-memory constraints.",
                                            "question": "Can we solve this in-place without extra space?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of reversing the entire word sequence, iterate and selectively reverse only even-length words before concatenation.",
                                            "question": "How would you modify this solution to reverse only words of even length?"
                                        },
                                        {
                                            "answer": "The problem can be modified to group every k words and reverse within each group, similar to reversing k nodes in a linked list.",
                                            "question": "What if we need to reverse the words in groups of k instead of completely?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_mediumproblems_minimumnumberofbracketreversalstomakeanexpressionbalanced",
                                "problem_name": "Minimum number of bracket reversals to make an expression balanced",
                                "problem_slug": "minimum-number-of-bracket-reversals-to-make-an-expression-balanced",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Red Hat",
                                        "Target",
                                        "Swiggy",
                                        "Docker",
                                        "OYO Rooms",
                                        "Rockstar Games",
                                        "Databricks",
                                        "Qualcomm",
                                        "Alibaba",
                                        "Shopify",
                                        "American Express",
                                        "Ubisoft",
                                        "AMD",
                                        "Freshworks",
                                        "Instacart",
                                        "eBay",
                                        "PwC",
                                        "MongoDB",
                                        "Lyft",
                                        "Goldman Sachs",
                                        "Medtronic",
                                        "GE Healthcare",
                                        "Zynga",
                                        "Electronic Arts",
                                        "Morgan Stanley",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fact: This problem is closely related to the way compilers and interpreters in programming languages such as Python, Java, and C++ check for correct use of parentheses in the source code. These tools use similar algorithms to maintain a stack of opening brackets and match them with closing ones, ensuring balanced usage. Such algorithms also inform how text editors and IDEs spot parenthesis errors and provide developers with suggestions to fix the errors or autofix them. Misuse of parentheses can lead to syntax errors, affecting the proper execution of the code.",
                                    "hints": [
                                        {
                                            "hint": "\"Traverse s, keeping track of opening and closing mismatches. If ( appears without a matching ), it becomes an opening mismatch. If ) appears without a matching (, it becomes a closing mismatch.\""
                                        },
                                        {
                                            "hint": "\"If the total number of unmatched brackets is odd, return -1 (odd-length strings can never be balanced). Otherwise, compute the minimum flips\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes, the order determines whether mismatches exist. The stack-based approach helps count unbalanced parts correctly.",
                                            "question": "Does the order of brackets affect reversibility?"
                                        },
                                        {
                                            "answer": "A balanced string must contain an equal number of ( and ). If the length is odd, one bracket will always remain unmatched.",
                                            "question": "Why is it impossible to balance an odd-length string?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "The approach would be extended to track multiple bracket types, ensuring separate counts for {}, [], and ().",
                                            "question": "How would the solution change if {} and [] brackets were included?"
                                        },
                                        {
                                            "answer": "This problem focuses on reversal-based correction, whereas redundant parentheses problems focus on removing excess brackets.",
                                            "question": "How does this compare to other bracket balancing problems, like finding redundant parentheses?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_mediumproblems_countandsay",
                                "problem_name": "Count and say",
                                "problem_slug": "count-and-say",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Qualcomm",
                                        "Boston Consulting Group",
                                        "Ubisoft",
                                        "Docker",
                                        "McKinsey & Company",
                                        "HCL Technologies",
                                        "Snowflake",
                                        "PwC",
                                        "Etsy",
                                        "Cloudflare",
                                        "NVIDIA",
                                        "Stripe",
                                        "Electronic Arts",
                                        "Cerner",
                                        "Goldman Sachs",
                                        "Ernst & Young",
                                        "Roche",
                                        "Philips Healthcare",
                                        "Morgan Stanley",
                                        "Zoho",
                                        "Medtronic",
                                        "Roblox",
                                        "Oracle",
                                        "Dropbox",
                                        "Mastercard",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "While the count-and-say problem seems abstract, it actually introduces the concept of run-length encoding, a simple form of data compression where sequences of the same data values are stored as a single data value and count. This concept is integral to numerous real-world applications, including computer graphics, where run-length encoding is used to compress image data keeping the file sizes minimal. This is reminiscent of the way the \"count-and-say\" sequence works, by 'compressing' consecutive elements into count/value pairs.",
                                    "hints": [
                                        {
                                            "hint": "\"Start with \"\"1\"\" as the base case. Iterate from 2 to n, constructing the next sequence by: Scanning the previous sequence character by character. Counting consecutive characters. Appending the count and character to form the new sequence. Repeat this process until reaching n.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "A naive recursive approach leads to redundant recomputation, causing stack overflow for large n. An iterative approach avoids this problem.",
                                            "question": "Why cant we use recursion directly?"
                                        },
                                        {
                                            "answer": "The problem requires processing consecutive characters, which is best handled with a two-pointer approach instead of splitting.",
                                            "question": "Why do we process characters one-by-one instead of using regex or string splits?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Instead of generating the full sequence, use on-the-fly processing to retrieve only the required k-th character, reducing memory usage.",
                                            "question": "How would you modify the approach if we needed to generate only the k-th character of countAndSay(n)?"
                                        },
                                        {
                                            "answer": "Fibonacci grows linearly in O(n) using DP.\nCount-and-say grows exponentially in length but remains O(n * m) due to processing constraints.",
                                            "question": "How does this compare to Fibonacci sequence generation?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "strings(advancedalgo)_advancedproblems(lessasked)",
                        "subcategory_name": "Advanced Problems (Less asked)",
                        "subcategory_slug": "advanced-problems-(less-asked)",
                        "subcategory_rank": 2,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_advancedproblems(lessasked)_rabinkarpalgorithm",
                                "problem_name": "Rabin Karp Algorithm",
                                "problem_slug": "rabin-karp-algorithm",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Siemens Healthineers",
                                        "Bain & Company",
                                        "Broadcom",
                                        "Deloitte",
                                        "Instacart",
                                        "Swiggy",
                                        "Databricks",
                                        "OYO Rooms",
                                        "Morgan Stanley",
                                        "Visa",
                                        "PwC",
                                        "Reddit",
                                        "Western Digital",
                                        "Mastercard",
                                        "Rockstar Games",
                                        "Flipkart",
                                        "Docker",
                                        "Medtronic",
                                        "Unity Technologies",
                                        "Roblox",
                                        "Uber",
                                        "AMD",
                                        "Bloomberg",
                                        "IBM",
                                        "Nutanix",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The Rabin-Karp algorithm is largely used in various programming applications like plagiarism detection. In most modern text editors and Integrated Development Environments (IDEs), Rabin-Karp string searching algorithm is used due to its efficiency in searching for duplicate strings or text. Its capability of detecting multiple pattern matches makes it widely used in data analysis and manipulation tools as well.",
                                    "hints": [
                                        {
                                            "hint": "\"Compute the hash of the pattern and the first window (substring of same length) in text. Slide the window across text, updating the hash incrementally (rolling hash). If a hash match occurs, verify the actual substring (to avoid false positives due to hash collisions). Store the starting index if pattern matches.\""
                                        },
                                        {
                                            "hint": "\"The hash function is computed as: H=(i=0 m1 ord(s[i])base (mi1))modprime, where base (e.g., 31 or 101) and prime (e.g., large prime like 1e9+7) are chosen for minimizing hash collisions. The rolling hash update (for next window) is: H new =(H oldord(s[i])base (m1))base+ord(s[i+m]).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Brute-force runs in O(nm) for worst case (e.g., repeated characters), while Rabin-Karp reduces comparisons via hashing.",
                                            "question": "Why use Rabin-Karp instead of brute-force string matching?"
                                        },
                                        {
                                            "answer": "Yes! Using hash sets, it can match multiple patterns simultaneously, useful in search engines and NLP.",
                                            "question": "Can Rabin-Karp be used for multiple pattern matching?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "By allowing a Levenshtein Distance (edit distance) threshold, we can match near-patterns.",
                                            "question": "How would you modify Rabin-Karp to find approximate matches?"
                                        },
                                        {
                                            "answer": "Use a larger base (e.g., 131 or 257) to accommodate extended character ranges.",
                                            "question": "How does Rabin-Karp handle Unicode or large character sets?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_advancedproblems(lessasked)_zfunction",
                                "problem_name": "Z function",
                                "problem_slug": "z-function",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "Johnson & Johnson",
                                        "IBM",
                                        "Bloomberg",
                                        "Cloudflare",
                                        "Zomato",
                                        "Cerner",
                                        "JPMorgan Chase",
                                        "Bain & Company",
                                        "Walmart",
                                        "AMD",
                                        "PayPal",
                                        "Docker",
                                        "OYO Rooms",
                                        "Chewy",
                                        "Micron Technology",
                                        "Unity Technologies",
                                        "Intel",
                                        "Snowflake",
                                        "Twilio",
                                        "Teladoc Health",
                                        "Freshworks",
                                        "Nutanix",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Rockstar Games",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: The underlying concept of this problem, finding the occurrences of a pattern in a text string, is commonly used in search engines and text editors. For example, the 'Find' or 'Search' function in text editors like Notepad or Word, uses similar algorithms to highlight or navigate to the occurrences of a search term within the open document. Similarly, search engines like Google also use more complex variations of this algorithm to find and display relevant web pages containing the user's search terms.",
                                    "hints": [
                                        {
                                            "hint": "\"Concatenate pattern, a separator ($), and text: S = \\text{pattern} + \"\"$\"\" + \\text{text} This ensures that if pattern exists in text, the Z-array will contain prefix matches at corresponding indices.\""
                                        },
                                        {
                                            "hint": "The Z-array at index i gives the longest prefix of S starting at i that matches the prefix of S. If Z[i] == len(pattern), it means pattern appears in text at index i - (len(pattern) + 1). If Z[i] matches pattern length, compute the starting index in text using offset correction."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The Z-function preprocesses the entire string in O(n) and does not require a separate prefix function computation like KMP.\nIt is easier to implement and works well for single pattern searching.",
                                            "question": "Why use the Z-function instead of other algorithms like KMP?"
                                        },
                                        {
                                            "answer": "The Z-array computes the longest matching prefix starting at each position.\nIf Z[i] == len(pattern), the pattern occurs at i - (len(pattern) + 1) in text.",
                                            "question": "How does the Z-function ensure pattern matching?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Z-function is deterministic (O(n)), while Rabin-Karp relies on hashing and can degrade to O(nm) in worst cases.",
                                            "question": "How does the Z-function compare to Rabin-Karp for multiple pattern searches?"
                                        },
                                        {
                                            "answer": "Yes, instead of exact matches, allow a threshold edit distance using dynamic programming techniques.",
                                            "question": "Can we modify the Z-function for approximate string matching?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_advancedproblems(lessasked)_kmpalgorithm",
                                "problem_name": "KMP Algorithm or LPS array",
                                "problem_slug": "kmp-algorithm-or-lps-array",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Square",
                                        "Wayfair",
                                        "OYO Rooms",
                                        "Goldman Sachs",
                                        "Flipkart",
                                        "Rockstar Games",
                                        "Activision Blizzard",
                                        "Target",
                                        "MongoDB",
                                        "Databricks",
                                        "Chewy",
                                        "AMD",
                                        "Uber",
                                        "Snowflake",
                                        "Morgan Stanley",
                                        "Airbnb",
                                        "Zomato",
                                        "Western Digital",
                                        "Reddit",
                                        "Lyft",
                                        "Teladoc Health",
                                        "Optum",
                                        "Cerner",
                                        "American Express",
                                        "Seagate Technology",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "The Knuth-Morris-Pratt (KMP) algorithm, the underlying concept for solving this problem, is exceptionally useful and widely applied in the real world. For instance, search functions in word processors, text editors, and browsers use pattern matching algorithms similar to KMP. It enables them to quickly find and highlight all occurrences of a user's input within the loaded document or webpage  important for productivity and usability. Particularly, KMP is known for its efficiency as it avoids backtracking, thus providing quicker search results.",
                                    "hints": [
                                        {
                                            "hint": "\"Use two pointers: one for text, one for pattern. If characters match, move both forward. If a mismatch occurs, use LPS to avoid unnecessary comparisons.\""
                                        },
                                        {
                                            "hint": "When the pattern completely matches, store its starting index in a result list."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of restarting after a mismatch, LPS shifts the pattern intelligently to align with previous matches.",
                                            "question": "How does the LPS array optimize the search?"
                                        },
                                        {
                                            "answer": "The LPS table efficiently skips redundant character comparisons, making KMP well-suited for such cases.",
                                            "question": "What happens when a pattern contains repeated characters?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "KMP already supports overlapping matches without modification.",
                                            "question": "What happens if we need to find overlapping occurrences?"
                                        },
                                        {
                                            "answer": "Yes, by allowing tolerances for mismatches using dynamic programming.",
                                            "question": "Can KMP be modified for approximate pattern matching?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_advancedproblems(lessasked)_shortestpalindrome",
                                "problem_name": "Shortest Palindrome",
                                "problem_slug": "shortest-palindrome",
                                "problem_rank": 4,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Qualcomm",
                                        "eBay",
                                        "Roche",
                                        "Walmart",
                                        "Zomato",
                                        "Rockstar Games",
                                        "Philips Healthcare",
                                        "AMD",
                                        "Roblox",
                                        "GE Healthcare",
                                        "Oracle",
                                        "Deloitte",
                                        "IBM",
                                        "Square",
                                        "American Express",
                                        "Bungie",
                                        "Electronic Arts",
                                        "Johnson & Johnson",
                                        "Cloudflare",
                                        "Chewy",
                                        "Snowflake",
                                        "Airbnb",
                                        "Freshworks",
                                        "Optum",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "Fun Fact: While the exact problem may not be directly applicable in real-life, the underlying concepts behind this problem are quite important. They involve working with strings, understanding palindromes and an essential grip on algorithm optimization. For instance, within Bioinformatics, algorithms with similar concepts are used in DNA sequence alignment. Furthermore, palindrome detection has its significance in error detection and correction in data transmission. A simple use could also be seen in developing certain types of games or in palindrome date detection used in some calendar related applications!",
                                    "hints": [
                                        {
                                            "hint": "\"The $ separator prevents false matches across original and reversed portions. Compute the LPS (Longest Prefix Suffix) array for this new concatenated string. The LPS value at the last index gives the longest palindromic prefix of s.\""
                                        },
                                        {
                                            "hint": "\"Take the remaining suffix (i.e., rev_s[:suffix_length]). Append it in front of s to form the shortest palindrome.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The separator ($) prevents unwanted overlapping between s and rev_s.",
                                            "question": "Why use s + \"$\" + rev_s instead of just s + rev_s?"
                                        },
                                        {
                                            "answer": "We extend s by adding characters only to the beginning instead of searching within.",
                                            "question": "How does this differ from finding the longest palindromic substring?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use Manachers algorithm to find the longest palindromic substring, then determine the shortest extension.",
                                            "question": "How would you modify the approach to allow adding characters anywhere (not just at the start)?"
                                        },
                                        {
                                            "answer": "Yes, a DP table can store minimum insertions needed, but it runs in O(n^2) instead of O(n).\n",
                                            "question": "Can we solve this using dynamic programming (DP)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "strings(advancedalgo)_strings(advancedalgo)_advancedproblems(lessasked)_longesthappyprefix",
                                "problem_name": "Longest happy prefix",
                                "problem_slug": "longest-happy-prefix",
                                "problem_rank": 5,
                                "misc": {
                                    "tags": [
                                        "Wayfair",
                                        "Intel",
                                        "American Express",
                                        "Databricks",
                                        "Epic Games",
                                        "Western Digital",
                                        "Mastercard",
                                        "Etsy",
                                        "PayPal",
                                        "McKinsey & Company",
                                        "Dropbox",
                                        "Shopify",
                                        "Texas Instruments",
                                        "KPMG",
                                        "JPMorgan Chase",
                                        "Target",
                                        "ARM",
                                        "Red Hat",
                                        "Electronic Arts",
                                        "Philips Healthcare",
                                        "Rockstar Games",
                                        "Cloudflare",
                                        "Docker",
                                        "Square",
                                        "Reddit",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "This type of problem is prevalent in the development of algorithms used in data compression, pattern recognition, and string matching. In the software industry, particularly in building search engines or plagiarism detectors, a common task is to find repeated strings or patterns. A real-world example is the KMP (Knuth-Morris-Pratt) algorithm, often used in the UNIX grep command, that searches for occurrences of a word within a main text string. This algorithm leverages the idea of happy prefixes to avoid backtracking - thus speeding up the search process.",
                                    "hints": [
                                        {
                                            "hint": "\"Compute the LPS Array:  The LPS array for s stores the length of the longest prefix that is also a suffix for each prefix of s. The last value in LPS gives the length of the longest happy prefix.\""
                                        },
                                        {
                                            "hint": "Extract the happy prefix:  If lps[-1] > 0, return s[:lps[-1]]. Otherwise, return \"\"\"\"."
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Yes! We can track all non-zero LPS values leading to multiple valid prefixes.",
                                            "question": "Can we extend this approach to find multiple happy prefixes?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "LPS (KMP) is best for prefix-suffix problems, while Z-algorithm is better for substring matching.",
                                            "question": "How does this compare to Z-algorithm for pattern matching?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "strings(advancedalgo)_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "strings-contest",
                        "subcategory_rank": 3,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "count_prefix_appearances",
                                "problem_name": "Count Prefix Appearances",
                                "problem_slug": "count-prefix-appearances",
                                "problem_rank": 0,
                                "misc": "{}",
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "distinct_substrings",
                                "problem_name": "Distinct Substrings",
                                "problem_slug": "distinct-substrings",
                                "problem_rank": 1,
                                "misc": "{}",
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "minimum_repetations",
                                "problem_name": "Minimum Repetations",
                                "problem_slug": "minimum-repetations",
                                "problem_rank": 2,
                                "misc": "{}",
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            },
            {
                "category_id": "maths",
                "category_name": "Maths",
                "category_slug": "maths",
                "category_rank": 18,
                "subcategories": [
                    {
                        "subcategory_id": "maths_sieveoferatosthenes",
                        "subcategory_name": "Sieve of Eratosthenes",
                        "subcategory_slug": "sieve-of-eratosthenes",
                        "subcategory_rank": 0,
                        "subcategory_type": "study",
                        "problems": [
                            {
                                "problem_id": "maths_maths_sieveoferatosthenes_printallprimestilln",
                                "problem_name": "Print all primes till N",
                                "problem_slug": "print-all-primes-till-n",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [
                                        "Roblox",
                                        "Twilio",
                                        "Rockstar Games",
                                        "Reddit",
                                        "Roche",
                                        "Optum",
                                        "Pinterest",
                                        "Bain & Company",
                                        "Medtronic",
                                        "HCL Technologies",
                                        "Alibaba",
                                        "Deloitte",
                                        "Epic Systems",
                                        "Ubisoft",
                                        "Wayfair",
                                        "Bloomberg",
                                        "Instacart",
                                        "Mastercard",
                                        "Robinhood",
                                        "Philips Healthcare",
                                        "ARM",
                                        "GE Healthcare",
                                        "McKinsey & Company",
                                        "Rakuten",
                                        "eBay",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would check each number from 2 to n and determine if it is prime by checking divisibility from 2 to sqrt(n). However, this results in O(nn) complexity, which is inefficient for large n."
                                        },
                                        {
                                            "hint": "\"A more efficient approach is the Sieve of Eratosthenes, which:  Assumes all numbers are prime initially. Iteratively marks multiples of known primes as non-prime. Outputs the remaining numbers as prime.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Instead of checking divisibility for each number, it eliminates non-primes in bulk by marking multiples.\nIt avoids redundant computations, making it significantly faster for large numbers.",
                                            "question": "Why is Sieve of Eratosthenes more efficient than brute force?"
                                        },
                                        {
                                            "answer": "Segmented Sieve: Breaks n into smaller chunks, reducing memory usage.\nMiller-Rabin Test: Probabilistic prime-checking used for huge numbers.",
                                            "question": "Can we generate primes more efficiently for very large numbers (n > 10^9)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Use the Miller-Rabin Primality Test for fast probabilistic prime checking.",
                                            "question": "How can we efficiently check if a single number is prime?"
                                        },
                                        {
                                            "answer": "Use the prime-counting function with binary search on the sieve output.",
                                            "question": "What if we needed only the k-th prime number instead of all primes?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "maths_maths_sieveoferatosthenes_primefactorisationofanumber",
                                "problem_name": "Prime factorisation of a Number",
                                "problem_slug": "prime-factorisation-of-a-number",
                                "problem_rank": 2,
                                "misc": {
                                    "tags": [
                                        "eBay",
                                        "Splunk",
                                        "Salesforce",
                                        "Medtronic",
                                        "Walmart",
                                        "AMD",
                                        "KPMG",
                                        "Etsy",
                                        "Activision Blizzard",
                                        "Riot Games",
                                        "Western Digital",
                                        "Siemens Healthineers",
                                        "Epic Games",
                                        "Visa",
                                        "Alibaba",
                                        "Pinterest",
                                        "Rakuten",
                                        "Flipkart",
                                        "Texas Instruments",
                                        "HashiCorp",
                                        "Seagate Technology",
                                        "Swiggy",
                                        "Boston Consulting Group",
                                        "Morgan Stanley",
                                        "Lyft",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach iterates through each number in queries and finds prime factors by checking divisibility from 2 to sqrt(num). This runs in O(nm) (where m is the largest number in queries), which is inefficient for large numbers."
                                        },
                                        {
                                            "hint": "\"A better approach is the Modified Sieve of Eratosthenes, which:  Precomputes the smallest prime factor (SPF) for all numbers up to the max(queries). Uses SPF to quickly factorize numbers in O(log m) time per number instead of checking divisibility repeatedly.\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "The Smallest Prime Factor (SPF) array allows factorization in O(log m) per number by iteratively dividing by precomputed smallest primes.\nBrute-force checking requires O(m) per number, which is slower.",
                                            "question": "Why use SPF instead of brute-force division?"
                                        },
                                        {
                                            "answer": "Standard Sieve finds primes, but Modified Sieve precomputes SPF, allowing faster factorization.",
                                            "question": "Can we use the Sieve of Eratosthenes directly for factorization?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Pollards Rho is used for extremely large numbers (e.g., 10+), whereas SPF is best for numbers  10.",
                                            "question": "How does this compare to Pollards Rho algorithm for factorization?"
                                        },
                                        {
                                            "answer": "Instead of storing factors in a list, use a dictionary to count occurrences.",
                                            "question": "How would you modify this approach to return factors with their exponents (e.g., {2:3, 5:1} for 40)?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "maths_maths_sieveoferatosthenes_countprimesinrangeltor",
                                "problem_name": "Count primes in range L to R",
                                "problem_slug": "count-primes-in-range-l-to-r",
                                "problem_rank": 3,
                                "misc": {
                                    "tags": [
                                        "Reddit",
                                        "Zomato",
                                        "Salesforce",
                                        "Zynga",
                                        "Target",
                                        "American Express",
                                        "Lyft",
                                        "Docker",
                                        "Walmart",
                                        "Unity Technologies",
                                        "eBay",
                                        "Mastercard",
                                        "JPMorgan Chase",
                                        "Bain & Company",
                                        "Twilio",
                                        "Byju's",
                                        "Optum",
                                        "Freshworks",
                                        "Siemens Healthineers",
                                        "PwC",
                                        "Broadcom",
                                        "Ubisoft",
                                        "Robinhood",
                                        "Texas Instruments",
                                        "Wayfair",
                                        "Google",
                                        "Microsoft",
                                        "Amazon",
                                        "Meta",
                                        "Apple",
                                        "Netflix",
                                        "Adobe"
                                    ],
                                    "facts": "",
                                    "hints": [
                                        {
                                            "hint": "A brute-force approach would check each number in the range [L, R] for primality using trial division, resulting in O(nm) complexity (where m is the largest number in queries). This is inefficient for large R."
                                        },
                                        {
                                            "hint": "\"A better approach is the Prefix Sum of Primes using the Sieve of Eratosthenes:  Precompute all primes up to max(R) using the Sieve of Eratosthenes (O(m log log m)). Build a prefix sum array where prime_count[i] stores the count of primes from 1 to i (O(m)).\""
                                        }
                                    ],
                                    "language": [],
                                    "difficulty": "Hard",
                                    "frequently_occuring_doubts": [
                                        {
                                            "answer": "Without a prefix sum, each query takes O(R) (checking primality individually).\nPrefix sum allows O(1) query lookups after an O(m log log m) preprocessing step.",
                                            "question": "Why use a prefix sum array instead of checking each range individually?"
                                        },
                                        {
                                            "answer": "Directly return 1 if L is prime, otherwise return 0.",
                                            "question": "What happens if L = R (query is a single number)?"
                                        }
                                    ],
                                    "interview_followup_questions": [
                                        {
                                            "answer": "Modify prime_count[] to track primes at even indices (is_prime[i] && i % 2 == 0).",
                                            "question": "How would you modify this to count only even-indexed primes?"
                                        },
                                        {
                                            "answer": "Yes! Build a twin prime prefix sum array, then query similar to prime counts.",
                                            "question": "Can we extend this to count twin primes (pairs (p, p+2)) in a range?"
                                        }
                                    ]
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    },
                    {
                        "subcategory_id": "maths_contest",
                        "subcategory_name": "Contest",
                        "subcategory_slug": "contest",
                        "subcategory_rank": 1,
                        "subcategory_type": "contest",
                        "problems": [
                            {
                                "problem_id": "win_or_lose",
                                "problem_name": "Win or Lose",
                                "problem_slug": "win-or-lose",
                                "problem_rank": 0,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            },
                            {
                                "problem_id": "longest_factor_chain",
                                "problem_name": "Longest Factor Chain",
                                "problem_slug": "longest-factor-chain",
                                "problem_rank": 1,
                                "misc": {
                                    "tags": [],
                                    "facts": "xyz",
                                    "hints": [],
                                    "difficulty": "Easy",
                                    "frequently_occuring_doubts": [],
                                    "interview_followup_questions": []
                                },
                                "problem_type": "DSA",
                                "hasIDE": true
                            }
                        ]
                    }
                ]
            }
        ],
        "isCoreSubject": 0
    }
}